<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一次装机过程与记录</title>
      <link href="/posts/54175/"/>
      <url>/posts/54175/</url>
      
        <content type="html"><![CDATA[<p>6月30号下的所有硬件单，7月1号就已经装好了，本来不想写的，但是想着最好还是记录一下，以便日后查看。</p><p>装机的配置清单是在蹲了几天的图吧和知乎，并结合微信小程序的装机助手里面别人的配置定下来的，总体还是有点超预算了。</p><p>因为是第一次装机，怕买到残次品点不亮，所以这次所有东西都是从京东自营买的，价格方面有些偏高，没有从更便宜的淘宝、拼多多、闲鱼二手购买，以后的话可以考虑从更便宜的渠道，或者去闲鱼捡垃圾，做一个垃圾佬。</p><table><thead><tr><th>项目</th><th>型号</th><th>价格</th></tr></thead><tbody><tr><td>CPU</td><td>i5 13490F</td><td>cpu和主板套装一起买的，总价格1491</td></tr><tr><td>主板</td><td>铭瑄终结者B760M WIFI 终结者</td><td></td></tr><tr><td>显卡</td><td>耕升 RTX5060 暴风</td><td>2688</td></tr><tr><td>内存</td><td>七彩虹16GB DDR4 3200</td><td>188</td></tr><tr><td>电源</td><td>酷冷至尊 GX650W 金牌 日系主电容</td><td>386</td></tr><tr><td>机箱</td><td>先马平头哥M2 五风扇全玻璃侧透</td><td>89</td></tr><tr><td>散热</td><td>利民AX120R SE 青春版 单塔</td><td>68</td></tr><tr><td>风扇</td><td>先马游戏风暴 3个</td><td>24</td></tr><tr><td>其中硬盘用的是之前机器上的一块ssd，所以就没有单独购买。</td><td></td><td></td></tr></tbody></table><p>装机基本上是按照B站赵德柱和硬件茶谈的视频来进行的， 总共花了大概6个小时，主要是一边装机一边看视频比较耗时间，有些视频还得反复查看。<br>不过结果是好的，一次性点亮。<br>当然，装机过程中有几个点需要注意一下：</p><ul><li>我是先将主板固定到机箱，将显卡也安装到主板之后，再将各种线插到主板上，由于主板与机箱的间隔很短，导致插线的时候很难插，特别是cpu供电的线和机箱电源的那些跳线， 因为缝隙太小，手不好对准，导致耗费了大量时间。<strong>下次装机的时候，记的先把线材都连接到主板上之后再固定主板</strong>。</li><li>全部装完机之后，有个小波折。当时我按机箱开关键，没有任何反应，心里有点发慌，检查了插线板等无问题，陷入了沉思。然后去网上搜索装机之后开机无反应的原因，找了半天也没发现原因，都准备拆了重新装的时候，突然看到一个视频里面的电源上面也有一个开关键，瞬间意识到了什么，赶紧看看自己的，果然是电源的开关没打开，虚惊一场。</li><li>第一次装机，所以对于理线没有什么要求，导致我将所有的线都从机箱最大的那个孔穿过来的，使得有些线材十分难看，比如cpu和显卡的线几乎横跨了整个机箱，不过当时能装上就行。后续怎么看怎么变扭，重新理线了一次，分别从各自的孔穿过去，机箱正面看上去就清爽多了。</li></ul><p><img src="https://pic.7billapp.com/2025/07/144d4b499bf3636ede47c746e46028a8.jpg"></p><p><img src="https://pic.7billapp.com/2025/07/d2b237478f351173b1ae51abc80474d4.jpg"><img src="https://pic.7billapp.com/2025/07/fbdae2567e61adb47cfff978e8e6e487.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装机 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下今年治牙的过程</title>
      <link href="/posts/22065/"/>
      <url>/posts/22065/</url>
      
        <content type="html"><![CDATA[<p>今年对牙齿做了多次治疗，记录一下治疗过程。<br>2月份的时候，口腔半边很疼，怀疑是牙的问题（其实去年也出现过一次，但是当时疼了没多长时间就好了，所以没怎么关心），所以去了一趟医院，拍了一下片子，医生诊断是左上部分的智齿坏了，并且已经触及到神经，所以很疼。因为是智齿，拔掉也没影响，于是拔牙。拔牙的时候打了麻药，所以没啥疼痛感，即使后面麻药失效了，也没啥疼痛感，只是因为是第一次拔牙，刚开始的时候还是有点小紧张的。<br>同时医生也建议我洗牙。<br>这是当时医生的诊断：<br><img src="https://pic.7billapp.com/2025/07/4c853c92d9eea95fa50736aa3849a7fb.jpg"></p><p>后面到5月份的时候，去了一家私人诊所洗牙（为啥去私人，因为近而且不需要验血，正规医院很多都得验血），洗完牙的时候诊所人员告知牙周炎比较严重，同时还有部分蛀牙，需要尽早治疗。</p><p>想着私人诊所可能会存在坑人的情况，所以挂了一个首都医科大学附属北京口腔医院的号（本来是计划挂北大口腔的，奈何号难挂，挂了三四天都没挂上），医生检查结果属于轻度牙周炎，但是最好也要及时治疗。<br>这是当时医生的诊断：<br><img src="https://pic.7billapp.com/2025/07/07527c184e6abe0adab8d6cb65edaf3d.jpg"></p><p>于是便开始了牙周刮治，期间共刮治了三次，总共持续了大约1个月，第一次是左上部分，第二次是右上部分和右下部分，第三次是左下部分，其中第二次刮的右边是最严重的，这次也打了麻药，可能是因为平时更过的是用右边进行咀嚼。<br>在整个的刮治过程中，牙齿的感觉是酸疼，不过处于还能忍受的范围，如果按痛觉满分10分算的话，洗牙大概是1，刮治大概是3。<br>同时在这期间，看了一下蛀牙，对左上部分一颗蛀牙进行了补牙， 补牙的时候感觉没啥疼痛感，可能是因为我补的比较少。</p><p>下面这个表格，列举了此次牙齿治疗的全过程。</p><table><thead><tr><th>项目</th><th>时间</th><th>地点</th><th>费用</th><th>说明</th></tr></thead><tbody><tr><td>拔牙</td><td>2025-02-09</td><td>北京中医药大学第三附属医院</td><td><br>医保个账：870</td><td>拔除智齿一颗</td></tr><tr><td>洗牙</td><td>2025-05-20</td><td>维乐口腔</td><td>自费：108</td><td></td></tr><tr><td>种植牙</td><td>2025-06-04</td><td>首都医科大学附属北京口腔医院</td><td>医保个账：367<br>医保基金：40<br></td><td></td></tr><tr><td>牙周刮治（第一次）</td><td>2025-05-28</td><td>首都医科大学附属北京口腔医院</td><td>医保个账：904<br>医保基金：40</td><td>本次刮治部位左上部分</td></tr><tr><td>牙周刮治（第二次）</td><td>2025-06-10</td><td>首都医科大学附属北京口腔医院</td><td>医保个账：804<br>医保基金：595</td><td>本次刮治部位右上部分和右下部分</td></tr><tr><td>牙周刮治（第三次）</td><td>2025-06-24</td><td>首都医科大学附属北京口腔医院</td><td>医保个账：249.69<br>医保基金：574.31</td><td>本次刮治部位左下部分</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预测未来</title>
      <link href="/posts/40045/"/>
      <url>/posts/40045/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic.7billapp.com/Image202504040934061.png"></p><p>现实世界是微妙且多变的，谁也没法预测下一个节点会发生什么，蝴蝶效应深刻的影响历史中的每一个进程。</p><p>那些大人物的某个看似很普通的一个决定，很可能就会导致后续一系列事件的发生。</p><p>而更多的芸芸众生，他们的决定可能影响的人更少，但是谁也没法确定在这更少的人中是否隐藏着下一个天选之子，从而推动世界的变革，引发洪水猛兽的到来。</p><p>所以，预测未来我认为是可笑的，黑天鹅事件会发生在各个领域，只不过有的领域可能影响范围更小而已。</p><p>写到这儿，我突然想到很久之前看的一部科幻小说，里面的主人公编写了一个程序，只需要输入一组参数，就可以模拟从宇宙大爆炸开始之后的一切事情，这个主人公很幸运的得到了他所处世界的宇宙初始参数，从此他就可以预测未来。</p><p>这个创意对于科幻小说而言是不错，但是如果思考其合理性， 我觉的根本不可能。首先我们不考虑要达到这个效果所需要的恐怖算力， 单是主人公预测未来这件事本身就是未来的一部分，当你去预测的时候，你的参数其实就已经发生变化了，在这之后的所有都会因为你的这个微小改变而改变，可能对于世界的影响是微乎其微的，但是对于自身的影响则是巨大的。当然，这个能力有一个巨大的好处，那就是可以还原历史，可以回溯历史上所发生的任何一件事，那么就再也不会存在什么未解之谜了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最终还是投向了obsidian</title>
      <link href="/posts/33335/"/>
      <url>/posts/33335/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇文章，讲述了一些<a href="https://acchw.top/posts/18945/">笔记软件的选择</a>, 当时主力使用的是思源笔记，同时为了解决多端同步的问题，我是将思源直接部署在了vps上，通过网页进行访问，这样间接实现了数据同步的问题。</p><p>但是用了许久下来，发现了一些问题，而最终是这些问题，导致我放弃了思源笔记。</p><p>对于我而言，最主要的几个问题如下：</p><ul><li>因为是部署在vps上的，一直担心哪天我的vps不续费了后续笔记就都丢失了（虽然做了备份，但是vps过期之后就无法公网访问了）</li><li>思源笔记更新太频繁，中间升级的过程会有一定的风险。依稀记的中间有一次为了使用它的一个新功能，将思源笔记进行了升级， 升级完之后，其中有几篇笔记的排版出现了错乱，不得已只能手工重新编辑。这次还好只是样式出现了问题，要是数据丢失了，那就真不知道去哪儿哭了。</li></ul><p>所以，最终我还是选择了obsidian。选择obsidian是因为其本身存储就是一个markdown文件，这样只要该文件存在，即使后期obsidian不维护，仍然可以使用。而且obsidian在我看来，只要不折腾，其实还是非常简单且易于使用的。</p><p>同时，将思源笔记内容迁移到obsidian的过程，也是一个知识收纳与整理的过程。</p><p>对于obsidian，我现在主要用到的几个插件（本着不折腾的缘故，尽量少装插件）：</p><ul><li>Remotely Save 数据同步，我是同步到阿里云oss</li><li>Kanban  看板工具，这个我主要是用来做一些简单的项目管理，已经足够了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pve lxc容器使用vnpy的问题</title>
      <link href="/posts/27377/"/>
      <url>/posts/27377/</url>
      
        <content type="html"><![CDATA[<p>最近在网上找较近时间的一些期货1分钟K线数据，发现基本上都是需要付费的，所以想着自己去录制行情数据。</p><p>录制这一块使用了vnpy。vnpy本身支持行情录制，但是有两个问题不符合我现在的需求，需要解决：</p><ol><li>需要手动指定合约名称，而我的需求是录制全市场行情</li><li>无法录制主力合约</li></ol><p>所以在网上找到了一个全市场行情录制的脚本, 修改了部分进行优化，同时对于主力合约，每天自己在后台合成。资源占用方面比较少（我这儿只录制了bar数据，没有录制tick数据，如果要录tick的话，所需的系统资源应该就更多了 )。</p><p>刚开始调试的时候，是在windows上运行的，没有问题，但是当我将脚本放到使用pve创建的lxc容器中（容器模板是ubuntu 22.04)，不知道为啥，CTP一直在报连接成功，然后再连接断开，也没有更详细的报错日志。猜测可能是lxc，抱着尝试的心态新创建了一个ubuntu 22.04的虚拟机， 果然成功了。</p><p>至于为啥lxc不行， 暂时还不知晓，写此文章仅记录一下。</p>]]></content>
      
      
      <categories>
          
          <category> 理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pve </tag>
            
            <tag> vnpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扔垃圾的感受</title>
      <link href="/posts/46394/"/>
      <url>/posts/46394/</url>
      
        <content type="html"><![CDATA[<p>今天去扔垃圾，</p><p>突然发现将垃圾扔出去的时候，</p><p>心里有一种莫名的快感。</p><p>为什么呢？</p><p>可能是将不要的东西丢掉，是对过去的一种告别（☺瞎矫情☺）。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决macos sierra重新安装时报错-准备安装时发生错误</title>
      <link href="/posts/49721/"/>
      <url>/posts/49721/</url>
      
        <content type="html"><![CDATA[<p>最近打算把之前的一个旧的苹果笔记本出售，型号是2015 macbook air，因为出售之前需要把系统整个清理干净，所以按照苹果官方的建议，先将磁盘抹掉，然后重新安装。</p><p>选择重新安装的时候使用了这个笔记本最刚开始的版本<code>macos sierra</code>（没得选择，只有这个选项），但是安装到最后几秒的时候，报错“准备安装时发生错误”，试了好几次，中途使用了网上说的网络时间错误、APFS等措施，还是不行。</p><p>最后想到了一个可能，因为我这个笔记本中途升级到了Monterey，现在这样直接降级安装可能有问题，那如果安装这个Monterey版本是不是可行？</p><p>最终证明是可行的，也不用U盘等进行安装，具体操作步骤如下：</p><ol><li>开机的时候按<code>Command+Option+R</code>进入网络恢复模式（注意千万不要使用<code>Command+R</code>那种方式进入，在这种恢复模式下只能安装sierra）</li><li>这个时候我们就能看到屏幕上有”重新安装macos Monterey” 选项， 此时如果直接进入安装，会发现没有磁盘。所以应该先进入磁盘工具，抹掉内置磁盘，格式选择APFS</li><li>点击菜单栏的退出磁盘工具，回到刚开始页面，此时再选择”重新安装macos Monterey” 选项，进行macos的安装，后面直接按流程来就行了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> macos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下使用vercel搭建umami中需要注意的地方</title>
      <link href="/posts/1106/"/>
      <url>/posts/1106/</url>
      
        <content type="html"><![CDATA[<p>在使用vercel搭建umami的时候，步骤比较简单，直接使用官网的deploy按钮，一步一步来就行。</p><p>其中有一个点需要注意，在填写环境变量DATABASE_URL的时候，按照官网说明，对于umami应该使用的是POSTGRES_PRISMA_URL，但此时如果直接使用POSTGRES_PRISMA_URL，在deploy的时候，连接数据库会报错，报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepared statement &quot;s0&quot; does not exist</span><br></pre></td></tr></table></figure><p>看到supabase下面有这句话，对于umami使用的是prepared statements。</p><p><img src="https://pic.7billapp.com/Snipaste_2025-02-07_15-32-40.png"></p><p>所以不能使用默认的6432端口， 改成5432端口就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres://xxx@xxxxx:5432/postgres?sslmode=require&amp;supa=base-pooler.x?pgbouncer=true&amp;connect_timeout=10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 博客 </tag>
            
            <tag> umami </tag>
            
            <tag> vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还是不能太依赖自建服务</title>
      <link href="/posts/50024/"/>
      <url>/posts/50024/</url>
      
        <content type="html"><![CDATA[<p>我发现有时还是不能太依赖自建的服务，否则后续升级的时候，可能会出现一系列问题。</p><p>比如我现在用来进行流量监控与分析的是自建的umami，最近因为需要用到其中的一些新功能，需要进行升级，但是发现升级比较困难，原因是旧版本umami用的mariadb版本比较老，新的umami用到了一些mariadb新的功能，所以需要同时升级mariadb，但是我的mariadb上还有其他的一些数据，不方便升级，所以只能放弃了。 </p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self-hosted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android应用在上架Google Play时封闭式测试的一些建议</title>
      <link href="/posts/40888/"/>
      <url>/posts/40888/</url>
      
        <content type="html"><![CDATA[<p>最近上架了一个自己写的App到Google Play上，其中的封闭式测试这一环节卡了很久，现在将其中的一些注意事项记录一下，方便后来人看到。当然，这个只适用于那些没有自己的测试渠道，和我一样，单纯只有自己一个人的情况下，怎样通过封闭式测试。</p><p>因为我是第一次弄这个，前后经过了二次被拒，第三次才成功通过。</p><p>这是我第一次申请失败的截图。</p><p><img src="https://pic.7billapp.com/Snipaste_2025-01-09_15-10-06.png"></p><p>Google Play对新注册的账号，如果需要发布应用，必须要有封闭式测试，且要求连续14天有20个人参与测试。</p><p>对于我这种没有自己测试渠道和测试人员的开发者，目前来看，成功率最高的是通过在reddit上发布帖子或者在别人发布的此类帖子下回帖，如此找到20个人参与测试，其中<a href="https://www.reddit.com/r/AndroidClosedTesting">https://www.reddit.com/r/AndroidClosedTesting</a> 这个板块热度较高，相对而言更容易。</p><p>首先是找人，可以在刚开始的前2天自己发帖或者回帖，凑齐20个人（可以多一点，因为中途可能会有人卸载），然后在之后的每天内都可以继续找人，还是为了防止中间有人卸载，不过之后的话就不用那么多了，每天找到几个就OK了。</p><p>还有一条是在这期间，可以发布几个版本，让Google认为你确实通过测试发现了一些问题并进行了修复，这在最后的调查问卷中可以填上去。</p><p>最后一条，对于别人发表的评价，要积极回复，也能够增加通过概率。</p><p>如果大家还有其他什么渠道或方法，也可以留言讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海外 </tag>
            
            <tag> Google Play </tag>
            
            <tag> Android </tag>
            
            <tag> 封闭式测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM中的Shallow Size 和 Retained Size解释</title>
      <link href="/posts/25621/"/>
      <url>/posts/25621/</url>
      
        <content type="html"><![CDATA[<p>在使用相关的JVM内存工具查看堆栈情况时， 有两个指标<code>Shallow Size</code>和<code>Shallow Size</code>不是很清楚其真正含义，现在通过一个例子来了解其含义。</p><p>先说一下概念描述：</p><ul><li>shallow size:  对象<strong>自身</strong>占用的内存, <strong>不包括</strong>它引用的其他实例。例如，对于一个简单的对象，如果它有几个基本数据类型的字段和对其他对象的引用，那么该值只计算这些字段所占的空间，而不计算被引用对象的空间</li><li>retained size: 当实例A被回收时, 可以<strong>同时被回收</strong>的实例的Shallow Size之和</li></ul><p>示例代码很简答， 构造一个List，然后插入100万个元素， 在程序运行的过程中使用IDEA自带的Profiler来获取堆栈快照，后面的一个无限循环是为了防止程序运行完终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     List&lt;Integer&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">            l.add(i);</span><br><span class="line">        &#125;  </span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;sdsdsds&quot;</span>);</span><br><span class="line">     &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://pic.7billapp.com/202403011555302.png"></p><p>可以看到，List实例的shallow size很小，因为其代表本身这个List对象占用的内存，不包含其引用的100万的Integer对象， 而retained size很大，接近29M。</p><p>在此处， 想验证一下long类型和int类型各自占用的空间占用区别有多大。</p><p>将Integer改成了Long, 其他不变，观察retained size，接近33M，和int的差距不是很大。</p><p><img src="https://pic.7billapp.com/202403011555651.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acme.sh自动生成泛域名证书的几个坑</title>
      <link href="/posts/16115/"/>
      <url>/posts/16115/</url>
      
        <content type="html"><![CDATA[<p>先说一下我的环境与配置：</p><ul><li>域名：在namesilo上购买的</li><li>证书使用方式：nginx</li><li>nginx部署方式：docker</li></ul><p>说一下在使用过程中可能会遇到的一些坑， 方便后来人正确处理。</p><h2 id="安装脚本过程"><a href="#安装脚本过程" class="headerlink" title="安装脚本过程"></a>安装脚本过程</h2><p>安装<code>acme.sh</code>前要将系统用户切换到和nginx服务使用的用户， 否则之后的relaod命令将没有权限执行。</p><p>比如我使用root用户安装的docker启动nginx, 就切换到root，并在此用户下安装acme.sh</p><h2 id="生成证书过程"><a href="#生成证书过程" class="headerlink" title="生成证书过程"></a>生成证书过程</h2><p>此处使用的是dns的api方式来验证，有几个点需要注意。</p><ol><li><p>生成api key的时候，<code>Generate key for read-only access</code> 一定不要勾选<br><img src="https://pic.7billapp.com/image-20240520113239334.png"></p></li><li><p>如果第一次没有注意勾选，并且使用脚本生成证书（不管是否生成失败），在新生成key之后， 需要先将.acme.sh account.conf Namesilo_Key 删除掉</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> 证书 </tag>
            
            <tag> namesilo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老了</title>
      <link href="/posts/16268/"/>
      <url>/posts/16268/</url>
      
        <content type="html"><![CDATA[<p>今天在公交上，一个应该是初中或高中的学生，让我帮忙弄一下行李箱，叫我 “叔叔”， 这好像是我印象中第一次有陌生人叫我这个称呼，看来是真老了。</p><p>但我的人生还有许多事没做，必须加紧步伐，把有限的时间花费在更有意义的事情上。</p><p>同时， 更重要的一点是身体，要加强锻炼，才能更好的应付之后可能发生的事。</p><p>希望今年心想事成，最重要的结婚和工作的事都能如意。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go学习笔记之指针</title>
      <link href="/posts/13710/"/>
      <url>/posts/13710/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><blockquote><p>一个变量，指向了另外一个变量的内存地址。</p><p>指针变量通常用于引用其他变量的内存地址，以便能够直接访问或修改该变量的值。</p></blockquote><h2 id="指针用法"><a href="#指针用法" class="headerlink" title="指针用法"></a>指针用法</h2><ul><li><code>*</code>    声明变量类型为指针；或者使用指针访问变量的值</li><li><code>&amp;</code>   指针指向的内存地址， 也是将一个普通变量赋值给一个指针变量的方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ip 变量储存的指针地址: %x\n&quot;</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">a 变量的地址是: <span class="number">20818</span>a220</span><br><span class="line">ip 变量储存的指针地址: <span class="number">20818</span>a220</span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="什么时候适合用指针"><a href="#什么时候适合用指针" class="headerlink" title="什么时候适合用指针"></a>什么时候适合用指针</h2><ul><li>如果需要修改外部变量的值，我们需要使用指针</li><li>不需要对map，slice等引用类型使用指针，因为他们本身就是一个指针</li><li>如果有超级大的结构体需要作为函数的参数，使用指针可以节省内存开销</li><li>因为指针可以修改其指向数据的值，所以最好不要随意在并发场景下使用</li><li>最好不要嵌套使用指针，比如b :&#x3D; &amp;a, c :&#x3D; &amp;b，这样代码会比较复杂难懂</li><li>对于一些特殊场景，比如接口传参，假如参数类型是布尔类型，因为go中变量必定会存在一个默认值，对于布尔类型是false， 如果不想有默认值，可以将这个参数设置为布尔类型的指针</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>指针也是变量，只不过存储的是地址</li><li>通过指针可以去修改其指向数据的值</li><li>指针可以帮助我们在任何地方修改其所指向数据的值</li><li>传递指针参数可以节省拷贝大结构体的内存开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pve主机使用smart_ctl监控磁盘信息</title>
      <link href="/posts/3239/"/>
      <url>/posts/3239/</url>
      
        <content type="html"><![CDATA[<p>pve中一块nvme磁盘最近偶尔会报温度过高， 所以需要加个监控， 之前已经装过node_expoter, 但是其磁盘硬件监控这一块的信息不够全面，其更多强调的是磁盘的性能，比如IO等。 温度监控这一块也有， 但是不够直观明显，而且缺少其他的一些磁盘硬件本身的信息， 下图是node_exporter监控硬件温度，在Hardware Misc里的Hardware temperature monitor中的显示信息：</p><p><img src="https://pic.7billapp.com/65b852743e7fc.png"></p><p>基于此， 需要一个专门用来收集磁盘硬件本身信息的exporter, prometheus提供了一个基于smart ctl的exporter, 地址是<a href="https://github.com/prometheus-community/smartctl_exporter">https://github.com/prometheus-community/smartctl_exporter</a> </p><p>因为这是直接监控硬件的， 所以我是直接安装在宿主机上的（包括之前的node_exporter)， 没有安装在虚拟机上。</p><h1 id="smartctl-exporter安装"><a href="#smartctl-exporter安装" class="headerlink" title="smartctl _exporter安装"></a>smartctl _exporter安装</h1><ol><li><p>进入 <a href="https://github.com/prometheus-community/smartctl_exporter/releases%E4%B8%8B%E8%BD%BD%E8%87%AA%E5%B7%B1%E6%9C%BA%E5%99%A8%E9%9C%80%E8%A6%81%E7%9A%84%E7%89%88%E6%9C%AC">https://github.com/prometheus-community/smartctl_exporter/releases下载自己机器需要的版本</a>, 此处以0.11.0版本为例， 登录宿主机执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus-community/smartctl_exporter/releases/download/v0.11.0/smartctl_exporter-0.11.0.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压 <code>tar -xzf smartctl_exporter-0.11.0.linux-amd64.tar.gz</code></p></li><li><p>移动 <code>cp smartctl_exporter /usr/bin</code></p></li><li><p>此时执行 <code>smartctl_exporter</code>命令， 如果有正确输出，则表示安装成功</p></li></ol><h1 id="设置开启自启"><a href="#设置开启自启" class="headerlink" title="设置开启自启"></a>设置开启自启</h1><ol><li><p>在 <code>/etc/systemd/system</code> 下新建一个配置文件 <code>smartctl_exporter.service</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=AutoStart smartctl_exporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/smartctl_exporter</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable smartctl_exporter.service</span><br><span class="line">systemctl start smartctl_exporter.service</span><br></pre></td></tr></table></figure></li></ol><h1 id="prometheus与grafana设置"><a href="#prometheus与grafana设置" class="headerlink" title="prometheus与grafana设置"></a>prometheus与grafana设置</h1><ol><li><p>prometheus的配置文件加上smart_ctl的监控（默认的端口是9633）， 配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;pve-smart-ctl-exporter&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;主机IP:9633&#x27;] </span><br></pre></td></tr></table></figure></li><li><p>grafana导入模板， 模板ID为<code>20204</code>, 效果如下</p><p><img src="https://pic.7billapp.com/65b8581ddf174.png"></p><p>至此， 大功告成。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> linux </tag>
            
            <tag> 监控 </tag>
            
            <tag> prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tailscale的设置与安装</title>
      <link href="/posts/3940/"/>
      <url>/posts/3940/</url>
      
        <content type="html"><![CDATA[<p>先说一下整体的环境和安装方式</p><ul><li>pve虚拟机专门开了一个lxc容器，用于安装tailscale，并利用此容器转发流量到局域网内的其他机器上，实现外部访问内网所有机器</li><li>由于tailscale本身的中转服务器derp没有中国的节点，测试了一下最近的节点是位于东京的，所以此处选择自己搭建一个中继节点</li></ul><p>下面描述一下安装步骤， 总共分为几大步：</p><ol><li>使用pve的lxc安装tailscale，并设置转发</li><li>搭建自定义的tailscale中继服务器</li><li>tailscale网页端配置</li></ol><h1 id="PVE-LXC安装tailscale"><a href="#PVE-LXC安装tailscale" class="headerlink" title="PVE LXC安装tailscale"></a>PVE LXC安装tailscale</h1><p>lxc模板使用的是<code>Debian 11(bullseye)</code>。</p><ol><li><p>创建一个非特权的CT容器， 模板选择<code>Debian 11(bullseye)</code>，其他配置都使用默认配置（网络那儿最好选择DHCP，让路由器自动分配一个IP）</p></li><li><p>安装完成后， 先不要启动，需要修改一些配置</p></li><li><p>在pve宿主机中，获取信息， 执行命令和返回结果如下, 记录 <code>10, 200</code> 这两个数字, 后面需要用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@pve:~# ls -al /dev/net/tun</span><br><span class="line">crw-rw-rw- 1 root root 10, 200 Jun 30 23:08 /dev/net/tun</span><br></pre></td></tr></table></figure></li><li><p>在pve宿主机中，修改 <code>/etc/pve/lxc/CTID.conf</code>文件， 新增如下两行：其中10和200是上一步中获取到的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc.cgroup2.devices.allow: c 10:200 rwm</span><br><span class="line">lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file</span><br></pre></td></tr></table></figure></li><li><p>上述配置完成后， 启动容器，在容器内安装tailscale,  安装文档：<a href="https://tailscale.com/kb/1038/install-debian-bullseye%EF%BC%8C">https://tailscale.com/kb/1038/install-debian-bullseye，</a> 安装完成后先不要启动tailscale</p></li><li><p>开启lxc的转发功能，进入lxc容器， 修改<code>/etc/sysctl.conf</code>配置文件（一般是有的，将注释去掉就行），修改为如下两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv6.conf.all.forwarding=1</span><br></pre></td></tr></table></figure></li><li><p>修改完成后， 使其生效， 执行命令：<code>sysctl -p /etc/sysctl.conf</code></p></li><li><p>启动tailscale， 因为此处是要使用此容器作为转发， 所以需要加上advertise-routes参数， 假设tailscale容器的IP为10.0.0.23， 要转发的网络段为 10.0.0.0&#x2F;24， 则使用如下命令启动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 此处使用的authKey来启动， 也可以不使用这个，具体方法参见tailscale文档</span><br><span class="line">tailscale up --authkey=xxxxx --accept-routes --advertise-routes=10.0.0.0/24</span><br></pre></td></tr></table></figure></li><li><p>上一步使用的authKey是在tailscale的web管理端生成的，具体位置见下图：<br><img src="https://pic.7billapp.com/65a9d86f4aa11.png"></p><ol start="10"><li>当tailsale成功连接之后， 登录web端，在对应设备上点击 <code>Edit route setting</code>， 在弹出框中将subnet routes勾选上，并保存， 至此， 当其他设备连接上tailscale之后，就可以直接通过10.0.0.X的IP直接访问和lxc容器属于同一网段的其他设备。<br><img src="https://pic.7billapp.com/65a9d9c9a660a.png"></li></ol></li></ol><h1 id="lxc设置tailscale开启自启"><a href="#lxc设置tailscale开启自启" class="headerlink" title="lxc设置tailscale开启自启"></a>lxc设置tailscale开启自启</h1><p>   这步的所有操作都是在lxc容器内进行的。</p><p>   使用systemd设置开机自启。在<code>/etc/systemd/system</code>下新建一个配置文件:  <code>tailscale.service</code>, 文件内容如下：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   [Unit]</span><br><span class="line">Description=AutoStart tailscale</span><br><span class="line">   After=tailscale.service</span><br><span class="line">Requires=tailscale.service</span><br><span class="line">   [Service]</span><br><span class="line">   Type=oneshot</span><br><span class="line">   ExecStart=/usr/bin/tailscale up --authkey=你的authKey --accept-routes --advertise-routes=你的转发范围</span><br><span class="line">   ExecStop=/usr/bin/tailscale down</span><br><span class="line">   RemainAfterExit=yes</span><br><span class="line">   Restart=on-failure</span><br><span class="line">   [Install]</span><br><span class="line">   WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>   然后执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable tailscale.service</span><br><span class="line">systemctl start tailscale.service</span><br></pre></td></tr></table></figure><h1 id="使用自定义中继服务器Derp"><a href="#使用自定义中继服务器Derp" class="headerlink" title="使用自定义中继服务器Derp"></a>使用自定义中继服务器Derp</h1><p>前提条件：</p><ul><li><p>公网VPS：配置不用太高，阿里云的最低配置就行</p></li><li><p>VPS开通端口8082和3478：我此处指定了derp的端口为8082， 你也可以指定其他端口</p></li><li><p>域名</p></li><li><p>域名对应的https证书： 我此处使用的是阿里云的免费证书</p><p> 此处为了方便，使用docker部署derp。</p><p> 在和docker-compose.yml文件的相同目录下，创建certs目录， 并将证书文件放入此目录中。</p><p> docker-compose.yml文件如下：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">derper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">fredliang/derper</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">derper</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/certs:/app/certs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8082</span><span class="string">:8082</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">3478</span><span class="string">:3478/udp</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">DERP_DOMAIN=你的域名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DERP_CERT_MODE=manual</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DERP_ADDR=:8082</span>  <span class="comment"># 自定义的端口，也可以换成其他</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DERP_HTTP_PORT=-1</span></span><br></pre></td></tr></table></figure><p> 然后启动，docker-compose up -d</p></li></ul><h1 id="tailscale配置"><a href="#tailscale配置" class="headerlink" title="tailscale配置"></a>tailscale配置</h1><p> 登录tailscale的web控制台， 在<code>Access Controls</code>选项卡下，编辑配置文件， 在配置文件加上如下一段：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的中继derp</span><br><span class="line">&quot;derpMap&quot;: &#123;</span><br><span class="line">&quot;Regions&quot;: &#123;</span><br><span class="line">&quot;900&quot;: &#123;</span><br><span class="line">&quot;RegionID&quot;:   900,</span><br><span class="line">&quot;RegionCode&quot;: &quot;随便填一个有标识性的即可&quot;,</span><br><span class="line">&quot;RegionName&quot;: &quot;随便填一个有标识性的即可&quot;,</span><br><span class="line">&quot;Nodes&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;:     &quot;随便填一个有标识性的即可&quot;,</span><br><span class="line">&quot;RegionID&quot;: 900,</span><br><span class="line">&quot;HostName&quot;: &quot;你的域名&quot;,</span><br><span class="line">&quot;StunPort&quot;: 3478,</span><br><span class="line">&quot;DerpPort&quot;: 8082, //之前配的端口</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>   具体加的位置如图所示：</p><p><img src="https://pic.7billapp.com/65a9deaa7c910.png"></p><p>验证是否生效：随便在一个已经连接上tailscale的机器上， 执行 <code>tailscale netcheck</code>，看到的中继列表里如果有你刚加的， 那就说明成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pve </tag>
            
            <tag> tailscale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go中获取某个包下定义的所有变量</title>
      <link href="/posts/50851/"/>
      <url>/posts/50851/</url>
      
        <content type="html"><![CDATA[<p>有这样一个场景， 我们在e这个包下， 有一个err_code.go文件，在其中自定义了一个错误码结构体和一些错误码，内容如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrCode <span class="keyword">struct</span> &#123;</span><br><span class="line">Code <span class="type">int</span></span><br><span class="line">Msg  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">Success            = ErrCode&#123;Code: <span class="number">10000</span>, Msg: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">UnknownErr         = ErrCode&#123;Code: <span class="number">10001</span>, Msg: <span class="string">&quot;未知错误&quot;</span>&#125;</span><br><span class="line">InvalidParams      = ErrCode&#123;Code: <span class="number">10002</span>, Msg: <span class="string">&quot;参数不合法&quot;</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在我们想获取到所有这些预先定义的错误码的code，应该如何做呢？</p><p>可以借助go标准库中AST语法树的能力遍历所有变量，然后过滤得到我们想要的变量类型， 具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_IntlDictMatchErrCodeEnum</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fset := token.NewFileSet()</span><br><span class="line">    <span class="comment">// 此处填写错误码所处包的相对路径</span></span><br><span class="line">pkgs, err := parser.ParseDir(fset, <span class="string">&quot;../pkg/e&quot;</span>, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处填写实际包的名字</span></span><br><span class="line">pkg := pkgs[<span class="string">&quot;e&quot;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历文件</span></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> pkg.Files &#123;</span><br><span class="line"><span class="comment">// 遍历文件的声明</span></span><br><span class="line"><span class="keyword">for</span> _, decl := <span class="keyword">range</span> file.Decls &#123;</span><br><span class="line"><span class="comment">// 检查声明是否是变量声明</span></span><br><span class="line"><span class="keyword">if</span> genDecl, ok := decl.(*ast.GenDecl); ok &amp;&amp; genDecl.Tok == token.VAR &#123;</span><br><span class="line"><span class="comment">// 遍历变量声明的规范</span></span><br><span class="line"><span class="keyword">for</span> _, spec := <span class="keyword">range</span> genDecl.Specs &#123;</span><br><span class="line"><span class="keyword">if</span> valueSpec, ok := spec.(*ast.ValueSpec); ok &#123;</span><br><span class="line">codeElt := valueSpec.Values[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> y, ok := codeElt.(*ast.CompositeLit); ok &#123;</span><br><span class="line"><span class="keyword">if</span> j, ok := y.Elts[<span class="number">0</span>].(*ast.KeyValueExpr); ok &#123;</span><br><span class="line"><span class="keyword">if</span> l, ok := j.Value.(*ast.BasicLit); ok &#123;</span><br><span class="line">                                    <span class="comment">// 此处能获取到错误码对应的Code</span></span><br><span class="line">                                    fmt.Printf(<span class="string">&quot;code:%s\n&quot;</span>, l.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql是如何解决不可重复读和幻读的</title>
      <link href="/posts/21511/"/>
      <url>/posts/21511/</url>
      
        <content type="html"><![CDATA[<p>Mysql的默认隔离级别是<strong>可重复读</strong>。并且在该级别下， 也不会出现幻读（一般意义上的可重复读是存在幻读的）， 那么Mysql是如何实现的呢？</p><h1 id="不可重复读的解决方案"><a href="#不可重复读的解决方案" class="headerlink" title="不可重复读的解决方案"></a>不可重复读的解决方案</h1><blockquote><p>不可重复读定义：在同一个事务中， 前后两次相同的查询， 返回的结果不一样， 针对的是 update 的操作</p></blockquote><p><strong>结论：通过使用MVCC实现不可重复读。</strong></p><p>每个事务在开始的时候， 都会创建一个递增的当前事务版本号。</p><p>mysql中每条记录都有两个隐藏字段：创建版本号create_version和删除版本号delete_version。</p><ul><li>当记录被insert的时候， 创建版本号就是当前事务的版本号， 删除版本号为null</li><li>当记录被delete的时候， 将删除版本号设置为当前事务的版本号</li><li>当记录被update的时候， 先进行delete，然后再进行add</li></ul><p>对于update的操作， 举例说明一下， 假设刚开始的表数据如下：</p><table><thead><tr><th>id</th><th>name</th><th>create_version</th><th>delete_version</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>1</td><td>NULL</td></tr><tr><td>2</td><td>小红</td><td>3</td><td>NULL</td></tr></tbody></table><p>现在要执行如下sql， 假设执行此sql的事务版本号为10:</p><p><code>update person set name=&#39;李梅&#39; where id =1 </code></p><p>执行完毕之后表中数据如下：</p><table><thead><tr><th>id</th><th>name</th><th>create_version</th><th>delete_version</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>1</td><td>10</td></tr><tr><td>2</td><td>小红</td><td>3</td><td>NULL</td></tr><tr><td>1</td><td>李梅</td><td>10</td><td>NULL</td></tr></tbody></table><p>查询的时候需要满足以下两个条件：</p><ol><li>当前事务的版本号需要 大于或等于创建版本号create_version</li><li>当前事务的版本号需要小于删除的版本号delete_version，或者当前删除版本号delete_version为NULL</li></ol><p>这样， 就能阻止在同一个事务中读取到其他事务提交的数据， 从而实现了可重复读。</p><p>根据上述结论， 如果执行 <code>select * from person where id=1</code>的查询， 假设开启此查询的事务版本号是11， 此时得到的结果如下：</p><table><thead><tr><th>id</th><th>name</th><th>create_version</th><th>delete_version</th></tr></thead><tbody><tr><td>1</td><td>李梅</td><td>10</td><td>NULL</td></tr></tbody></table><h1 id="幻读的解决方案"><a href="#幻读的解决方案" class="headerlink" title="幻读的解决方案"></a>幻读的解决方案</h1><blockquote><p>幻读定义： 在同一个事务中，前后两次相同的查询， 返回的结果不一样， 针对的是 insert 和 delete 的操作。</p></blockquote><p><strong>结论：</strong></p><ul><li><strong>对于快照读， MVCC就能实现</strong></li><li><strong>对于当前读， 是利用锁来实现的</strong></li></ul><p>首先说一下两种读的区别：</p><ul><li>快照读： 事务开始的时候，生成一个快照， 之后的数据都是从这个快照中读取。 普通的select语句就是快照读。</li><li>当前读：读取数据的最新版本。insert、update、delete、select..for update 都是当前读。</li></ul><p>由于快照读取的永远是事务刚开始的快照数据， 所以即使有其他事务进行了删除或新增操作，该事务也读取不到，所以天然的解决了幻读。</p><p>对于当前读， 首先要明白一个概念， 锁。</p><p><strong>mysql 什么时候会加锁？</strong></p><p>在进行insert、update、delete、select…for update操作。</p><p>需要注意的是，此处的锁指的是行锁， 都是针对索引进行加锁的， 如果没有索引，那么加的就是表锁， 锁住的是整个表。</p><p>mysql的行锁分为如下三种：</p><ul><li><strong>记录锁 record lock</strong>:  只针对唯一索引或主键索引， 锁住的是单条记录</li><li><strong>间隙锁 gap lock</strong>:  只针对非唯一索引，锁住的是一个区间， 但并不包含该记录本身</li><li><strong>临键锁 next key lock</strong>: 只针对唯一索引，可以理解为是行锁+间隙锁， 锁住一个区间和记录本身， 整体区间范围 左开右闭</li></ul><p>当事务进行当前读的时候， 使用间隙锁或临键锁，锁住一个区间，这样当其他事务在这个区间内进行删除或新增操作的时候，就只能阻塞，需要等待当前事务释放这个锁。 从而保证前后两次读取到的数据一致。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法解读</title>
      <link href="/posts/35513/"/>
      <url>/posts/35513/</url>
      
        <content type="html"><![CDATA[<p>首先理解一下哈希函数的意思。</p><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><blockquote><p>将任意长度的数据映射到有限长度的域上。</p><p>本质是对一段数据m进行杂糅，然后输出另一段固定长度的数据h，并将这个h作为这段数据的特征值。</p></blockquote><p>基本原理就是将数据块m分成多段，每一段长度固定（如128位），若某段长度不足，则进行补位（如0或者1），然后对每一块都进行hash运算，再将这些数据进行迭代（比如相邻两段进行异或），最终得到一个数据。</p><h1 id="普通哈希取模"><a href="#普通哈希取模" class="headerlink" title="普通哈希取模"></a>普通哈希取模</h1><p>先来看一下普通哈希取模是什么样的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = hash(key) % n</span><br></pre></td></tr></table></figure><p>其中n为节点数目，计算得到的c为对应的节点编号。</p><p>假设现在总共有A，B，C三台服务器节点， 现在对某个key值哈希之后得到的值为5， 则c &#x3D; 5 % 4 &#x3D; 1, 表示该值存储在B节点上。</p><p>现在若需要增加一台服务器节点D，则此时c&#x3D;5 % 5 &#x3D; 0，表明该值存储在A服务器上，前后就会出现不一致。</p><p>这样当出现服务器新增、删除、宕机的时候，这样就会请求后端数据库，造成缓存穿透。因此普通的哈希取模定位key所在的服务器的方法会有问题。</p><p><strong>综上， 普通哈希最大的缺点就是在扩容或缩容的时候， 会造成key定位的失效。</strong></p><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p><strong>一致性哈希算法不是对服务器数目取模，而是对2^32进行取模。</strong></p><p>将2^32个数组织成一个圆环，从0到2^32-1， 整个空间按照顺时针方向组织，圆环的正上方的数是0， 0 点右侧的第一个数是1， 左侧的第一个数是2^32-1, 这样就组成一个hash环。</p><p>现在假设有四台服务器1，2，3，4，利用哈希算法计算出这四台服务器的哈希值（具体可以是服务器的IP等），其在圆环上的分布如图所示，同时假设有三个key，其代号分别是A、B、 C，计算其哈希之后得到的值在圆环的分布如图所示。</p><p>根据哈希环的规定，确定一个值在哪个服务器上存储，只需要从该key在哈希环的位置开始，按照顺时针方向找到的第一个服务器节点，就是该key存储的服务器。如下图所示，A存储在节点1上，B存储在节点2上，C存储在节点3上。</p><p><strong>综上， 一致性哈希需要计算2次哈希值：</strong></p><ul><li>计算存储节点的哈希值，确定存储节点在环上的位置</li><li>计算key的哈希值， 确定key在环上的位置</li></ul><p><img src="https://pic.7billapp.com/202403011539734.jpg"></p><p>可以看到当节点3宕机的时候，对A、B无影响，只有C定位到节点4上，也就是说，当某个节点出现故障或者新增节点时，受影响的数据仅仅是此节点到其环空间中上一个节点的数据，其他的不会受到影响。故数据影响范围较小。</p><h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>这里有一个问题需要注意，当节点数量较少时，<strong>可能会导致环上节点分布不均匀，导致大部分数据会落在某一个或者某几个节点上</strong>。</p><p>为了保证数据能够均匀分布，一致性哈希算法引入了虚拟节点的概念，即对某一个实体节点计算多个哈希，每个计算结果都占据环上一个位置。</p><p>具体做法可以在服务器IP上增加编号来实现。在实际环境中，通常将每个实体节点设置32个虚拟节点甚至更大，保证数据均匀分布。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务详解</title>
      <link href="/posts/42346/"/>
      <url>/posts/42346/</url>
      
        <content type="html"><![CDATA[<p> 以下都是针对InnoDb引擎， 描述的都是单机事务，说明一下个人对事务的一些理解。</p><h1 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h1><p>这四个特性并不是平级的关系。准确的说， 一致性是最基本的属性，其他的属性都是为了保证一致性而存在的。</p><h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h2><blockquote><p>整个事务是一个整体，是程序运行时不可分割的最小工作单位。</p></blockquote><p>一个事务中的所有操作要么全部执行成功，要么全部都不执行。任何一条语句执行失败，都会导致事务回滚。</p><p><strong>实现方式</strong>：undo log，当执行失败的时候，使用undo log进行回滚。</p><h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h2><blockquote><p>一个事务所做的修改在该事务未提交之前，对其他事务不可见。</p></blockquote><p>为什么会出现隔离性的需求？ </p><p>本质是因为并发， 试想一下， 如果没有并发，所有事务都是串行执行的，那么也就不会存在隔离性的问题了。所以mysql提出了隔离级别的概念， 针对不同的隔离级别，进行不同的处理， 这在下文的隔离级别会有详细描述。</p><p>那么， 如何解决并发造成的数据一致性问题？</p><p>第一个想法自然是<strong>加锁</strong>，给数据加锁，相当于让各个事务串行执行，自然就不存在数据一致性的问题了。同时为了提高加锁的效率和粒度，mysql针对锁提出了不同的类别，比如间隙锁、排他锁等。</p><p>加锁会造成一个比较大的问题， 就是并发效率不高，即使在锁上面进行优化， 也只能治标不治本，所以要寻找一种不加锁的方式， 答案就是<strong>数据冗余</strong>， mysql基于此实现了mvcc(多版本并发控制)， 下文会有详细描述。</p><p><strong>实现方式</strong>：锁和mvcc</p><h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h2><blockquote><p>数据一旦提交，结果就是永久性的，并不因为宕机、重启等情况丢失。</p><p>一般理解就是写入硬盘保存成功。</p></blockquote><p><strong>实现方式</strong>：redo log。数据写入磁盘是通过redo log进行的， redo log存储的是对于每个页修改的物理描述。</p><h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><blockquote><p>数据库的记录总是从一个一致性状态转变成另一个一致性状态。</p><p>这里的一致性是语义上的一致性, 并不是语法上的一致性， 可以理解为需要达到用户期望的状态。</p></blockquote><p>比如经典的银行转账例子，若A转账200给B，则需要执行如下三步：</p><ol><li>检查A账户余额是否大于200</li><li>从A账户减去200</li><li>将B账户增加200</li></ol><p>用户期望的状态就是A减去200，同时B增加200。</p><p>在事务的概念中，以上三个步骤必须处于同一个事务中，若不是处于同一事务中，当程序执行到3的时候系统异常了，就会导致用户的钱被扣。在真正的银行事务中，不仅需要强事务来保证一致性，而且会有一个日终对账系统，来计算每天所有的资金流向，保证整个资金流动值为0。</p><p><strong>实现方式</strong>：通过回滚，恢复以及并发情况下的隔离从而实现的一致性，可以理解为其他三个特性是为了保持一致性。</p><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>首先介绍一下关于数据不一致的几个概念：</p><ul><li><strong>脏读</strong>：事务A读到了事务B未提交的数据， 此时事务A读到的数据就是一个脏数据</li><li><strong>不可重复读</strong>：在同一个事务中， 前后两次相同的查询， 返回的结果不一样， 针对的是update的操作</li><li><strong>幻读</strong>： 在同一个事务中，前后两次相同的查询， 返回的结果不一样， 针对的是insert和delete的操作</li></ul><p>隔离级别总共分为四大类（注意与上面数据不一致类型的区分）：</p><ul><li>未提交读</li><li>提交读</li><li>可重复读</li><li>串行读</li></ul><p>针对每个隔离级别是否会出现脏读、不可重复读、幻读的情况如下：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>提交读</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行读</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><h2 id="未提交读-Read-Uncommited"><a href="#未提交读-Read-Uncommited" class="headerlink" title="未提交读 Read Uncommited"></a>未提交读 Read Uncommited</h2><blockquote><p>一个事务所做的修改在该事务未提交前对其他事务可见。</p></blockquote><p>造成的结果就是会形成脏读， 因此一般不采用。</p><h2 id="提交读-Read-Commited"><a href="#提交读-Read-Commited" class="headerlink" title="提交读 Read Commited"></a>提交读 Read Commited</h2><blockquote><p>只能读取到其他事务已经提交的数据。</p><p>即一个事务所做的修改在该事务未提交之前对其他事务不可见。</p></blockquote><p>此级别能够解决脏读的问题，但是有可能会产生不可重复读的问题。</p><p>Orcale默认数据隔离级别就是提交读。</p><h2 id="可重复读-Repetable-Read"><a href="#可重复读-Repetable-Read" class="headerlink" title="可重复读 Repetable Read"></a>可重复读 Repetable Read</h2><blockquote><p>保证在同一个事务中，两次读取到的数据是一致的。</p></blockquote><p>该级别能解决数据不一致中的<code>不可重复读</code>的问题，但无法解决幻读（注意此处指的是一般意义上的概念，mysql InnoDB在该级别下是不存在幻读的，具体原因见后面分析)。</p><p>mysql  InnoDb引擎默认的数据库隔离级别就是可重复读。</p><h2 id="串行读"><a href="#串行读" class="headerlink" title="串行读"></a>串行读</h2><p>顾名思义，所有的读操作都是串行的，这样做肯定不会存在数据一致性问题， 但无疑效率是最低的。</p><h1 id="Spring中的-Transactional注意事项"><a href="#Spring中的-Transactional注意事项" class="headerlink" title="Spring中的@Transactional注意事项"></a>Spring中的@Transactional注意事项</h1><p>该注解是Spring中用来控制事务的注解，在使用时有以下几点需要注意：</p><ul><li>@Transactional 注解默认回滚<code>RuntimeExcepption</code>异常，注意此处即使异常被处理（即catch捕获了该类型的RuntimeException异常），Spring仍然会回滚事务</li><li>@Transactional注解有一个参数rollbackFor可用来指定当自定义Exception发生时，也会进行事务回滚</li><li>@Transactional注解只能作用于public方法上，虽然也能写在非public上且不会报错，但实际上是不起作用的</li></ul><h1 id="Spring中事务的传播级别"><a href="#Spring中事务的传播级别" class="headerlink" title="Spring中事务的传播级别"></a>Spring中事务的传播级别</h1><p>以下例子中用到的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1 (  </span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto increment,  </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span>,   </span><br><span class="line">    <span class="keyword">primary</span> key(id) </span><br><span class="line">) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2 (   </span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto increment,   </span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span>,   </span><br><span class="line">    <span class="keyword">primary</span> key(id) </span><br><span class="line">) engine<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure><p>在Spring中定义的事务的传播级主要有如下几种，现就其中几个主要的说明如下</p><h2 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h2><p><strong>按需加载。Spring默认的传播级别。</strong></p><p>当上下文中已经存在事务，则加入到该事务执行。若上下文不存在事务，则新建一个事务执行。</p><p>此处上下文可以理解为@Transactional注解作用的地方，当该注解作用于方法时，上下文从方法最先开始的地方开启，也就是说在刚进入方法时，首先就会开启一个事务。</p><p>以下分几种情况进行说明：</p><p><strong>（1）当外部方法未开启事务时, 若外部方法抛出异常, 如何运行？</strong></p><p>User1Service代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User1Service</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;User1Mapper, User1Entity&gt; &#123;   </span><br><span class="line">    <span class="meta">@Resource</span>   </span><br><span class="line">    <span class="keyword">private</span> User1Mapper user1Mapper;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser1</span><span class="params">(User1Entity user1Entity)</span> &#123;     </span><br><span class="line">        user1Mapper.insert(user1Entity);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User2Service代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User2Service</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;User2Mapper, User2Entity&gt; &#123;    </span><br><span class="line">    <span class="meta">@Resource</span>   </span><br><span class="line">    <span class="keyword">private</span> User2Mapper user2Mapper;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser2</span><span class="params">(User2Entity user2Entity)</span> &#123;     </span><br><span class="line">        user2Mapper.insert(user2Entity);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;     </span><br><span class="line">    <span class="type">User1Entity</span> <span class="variable">user1Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1Entity</span>();     </span><br><span class="line">    user1Entity.setId(<span class="number">100</span>);     </span><br><span class="line">    user1Entity.setName(<span class="string">&quot;sju&quot;</span>);     </span><br><span class="line">    user1Service.addUser1(user1Entity);  </span><br><span class="line">    </span><br><span class="line">    <span class="type">User2Entity</span> <span class="variable">user2Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User2Entity</span>();     </span><br><span class="line">    user2Entity.setId(<span class="number">200</span>);     </span><br><span class="line">    user2Entity.setName(<span class="string">&quot;fdf&quot;</span>);     </span><br><span class="line">    user2Service.addUser2(user2Entity);     </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:  user1, user2 均插入成功</p><p>分析: 因为外围方法未开启事务，所以程序执行到两个addUser方法时都会开启一个新的事务，这两个事务是相互独立的,分别执行自己的逻辑，插入成功，外部方法异常不影响内部.</p><p><strong>（2）当外部方法未开启事务时, 若内部方法抛出异常, 如何运行？</strong></p><p>User1Service代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User1Service</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;User1Mapper, User1Entity&gt; &#123;   </span><br><span class="line">    <span class="meta">@Resource</span>   </span><br><span class="line">    <span class="keyword">private</span> User1Mapper user1Mapper;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser1</span><span class="params">(User1Entity user1Entity)</span> &#123;     </span><br><span class="line">        user1Mapper.insert(user1Entity);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User2Service代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User2Service</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;User2Mapper, User2Entity&gt; &#123;    </span><br><span class="line">    <span class="meta">@Resource</span>   </span><br><span class="line">    <span class="keyword">private</span> User2Mapper user2Mapper;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser2</span><span class="params">(User2Entity user2Entity)</span> &#123;     </span><br><span class="line">        user2Mapper.insert(user2Entity);     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;     </span><br><span class="line">    <span class="type">User1Entity</span> <span class="variable">user1Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1Entity</span>();     </span><br><span class="line">    user1Entity.setId(<span class="number">100</span>);     </span><br><span class="line">    user1Entity.setName(<span class="string">&quot;sju&quot;</span>);     </span><br><span class="line">    user1Service.addUser1(user1Entity);      </span><br><span class="line">    </span><br><span class="line">    <span class="type">User2Entity</span> <span class="variable">user2Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User2Entity</span>();     </span><br><span class="line">    user2Entity.setId(<span class="number">200</span>);     </span><br><span class="line">    user2Entity.setName(<span class="string">&quot;fdf&quot;</span>);     </span><br><span class="line">    user2Service.addUser2(user2Entity);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果: user1插入成功, user2插入失败</p><p>分析: 还是因为外部方法未开启事务, 所以user1, user2会开启两个独立的事务, 互不影响。 所以user1插入成功, user2插入失败。</p><p><strong>（3）当外部方法开启事务时, 若内部方法或者外部方法抛出异常, 如何运行？</strong></p><p>User1Service和User2Service代码同之前, 只是在测试方法上也加上@Transactional注解。</p><p>测试方法代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;     </span><br><span class="line">    <span class="type">User1Entity</span> <span class="variable">user1Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1Entity</span>();     </span><br><span class="line">    user1Entity.setId(<span class="number">100</span>);     </span><br><span class="line">    user1Entity.setName(<span class="string">&quot;sju&quot;</span>);     </span><br><span class="line">    user1Service.addUser1(user1Entity);      </span><br><span class="line">    </span><br><span class="line">    <span class="type">User2Entity</span> <span class="variable">user2Entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User2Entity</span>();     </span><br><span class="line">    user2Entity.setId(<span class="number">200</span>);     </span><br><span class="line">    user2Entity.setName(<span class="string">&quot;fdf&quot;</span>);     </span><br><span class="line">    user2Service.addUser2(user2Entity);     </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果: user1, user2都未插入</p><p>分析: 外部方法开启事务，内部两个方法都会加入到该事务中成为一个事务，外部方法回滚，则所有回滚</p><h2 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h2><p>事务之间是嵌套的。若上下文存在事务，则嵌套执行，若不存在事务，则新建事务执行。</p><p>原理：子事务是父事务的一部分，当进入子事务之前，会先在父事务建立一个回滚点save point，然后执行子事务。待子事务执行结束，再执行父事务。</p><p>总结起来就是: <strong>子事务的执行不会影响父事务，但父事务的执行会影响子事务。</strong></p><p>举个例子， 若methodA以PROPAGATION_REQUIRED修饰， methodB以PROPAGATION_NESTED修饰， 并且在methodA中调用methodB， 此时A为父事务， B为子事务。 其执行情况如下：</p><table><thead><tr><th>异常情况</th><th>执行结果</th></tr></thead><tbody><tr><td>A抛异常，B正常</td><td>A, B 都回滚</td></tr><tr><td>A正常， B异常</td><td>B先回滚， A再正常提交</td></tr><tr><td>A，B都抛异常</td><td>A , B 都回滚</td></tr></tbody></table><p>问题1： 若子事务回滚，会发生什么？</p><p>若子事务回滚，则父事务会回滚到之前建立的save point,然后执行其他业务逻辑，父事务之前的操作不受影响，更不会自动回滚。所以父事务不受子事务的影响。</p><p>问题2：若父事务回滚，子事务会回滚吗？</p><p>答：子事务会回滚</p><p>问题3：子事务和父事务谁先提交？</p><p>答：子事务先提交</p><h2 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h2><p>支持当前事务，若没有当前事务，则以非事务执行</p><h2 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h2><p>使用当前事务，注意这是强制性的（mandatory),因为当发现当前没有事务时，直接抛出异常</p><h2 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h2><p>不管上下文中是否存在事务，每次都新建一个独立事务。</p><p>若上下文中存在事务，则先会将上下文事务挂起，然后执行本方法事务，待本方法事务执行完毕之后，继续执行上下文事务。</p><p>若上下文未开启事务，其行为逻辑与requires级别一致,即新建一个自己独立的事务。</p><p>当外部方法开启事务时，requires_new修饰的内部方法依然会单独开启独立事务，且与外部方法的事务相互独立，内部方法之间、内部方法和外部方法的事务均相互独立，互不影响。</p><h2 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h2><p>以非事务方式执行代码，若当前存在事务，则将当前事务挂起</p><h2 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h2><p>以非事务执行，该处语气比上一个更强，因为当发现当前存在事务时，则直接抛出异常</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则表达式总结</title>
      <link href="/posts/24604/"/>
      <url>/posts/24604/</url>
      
        <content type="html"><![CDATA[<h4 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h4><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配字符输入的开始</td></tr><tr><td>$</td><td>匹配字符输入的结束</td></tr><tr><td>\d</td><td>数字字符, 等效于[0-9]</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等</td></tr><tr><td>\S</td><td>匹配任何非空白字符</td></tr><tr><td>{n}</td><td>正好匹配n次</td></tr><tr><td>{n,}</td><td>至少匹配n次</td></tr><tr><td>{n, m}</td><td>n&lt;&#x3D;m, 匹配至少n次,至多m次</td></tr><tr><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以供以后使用</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式, 等效于{0,}</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式,等效于{1,}</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式,等效于 {0,1}</td></tr><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符</td></tr><tr><td>|</td><td>或的关系</td></tr><tr><td>\u<em>n</em></td><td>匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr><tr><td>\w</td><td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效</td></tr><tr><td>[\u4e00-\u9fa5]</td><td>匹配中文字符</td></tr></tbody></table><h4 id="常见示例"><a href="#常见示例" class="headerlink" title="常见示例"></a>常见示例</h4><p>以Java写法为例， 其他语言类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能输入n到m位的数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^\\d&#123;n,m&#125;$&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//只能输入英文字母和数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^[A-Za-z0-9]+$&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能输入数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^[0-9]+$&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11位数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;11&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中文字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[\\u4e00-\\u9fa5]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配任意字符且长度为1到5位</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[\\s\\S]&#123;1,5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配任意ascii码中字符且长度为1到5位</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[\\x00-\\x7F]&#123;1,5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只要出现一次月份即可，例如 hu01jk, 11klo</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;.*([0-1][0-9])+.*&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还是阳了</title>
      <link href="/posts/37012/"/>
      <url>/posts/37012/</url>
      
        <content type="html"><![CDATA[<p>还是记录一下为好。时间是2023年5月17号， 我终于还是阳了。</p><p>5月17号早上起来的时候， 就感觉头很疼，还以为是昨天晚上吹空调导致的，但是后来越来越疼，于是买了个体温计和检测试剂，不出所所料，确实阳了，当时的体温是38.9度。</p><p>前后总共持续4天左右， 除了头疼和发烧， 其他的症状到还好， 但是这个头疼真的很难受，是既不能睡又不能不睡。</p><p>之前疫情三年一直都没阳过， 包括最后解封的时候， 我周边的同事都阳了， 就只有我没阳， 还以为自己体质很好（其实我的体质确实感觉还行， 已经有七八年没去过医院，吃过药了，最近的一次生病我记的应该是高中的时候吃东西吃坏肚子）。</p><p>但最终还是没躲过去。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红米AC2100 openwrt下无法进入breed</title>
      <link href="/posts/64412/"/>
      <url>/posts/64412/</url>
      
        <content type="html"><![CDATA[<p>之前的红米路由器AC2100刷的是openwrt，想换回pandavan，使用如下方法无法进入breed的web页面：</p><blockquote><p>先断电，然后找个针戳住路由器背后 Reset 小孔并插电，等路由器蓝灯一直闪烁后，浏览器输入 192.168.1.1，即可进入 breed 网页。</p></blockquote><p><strong>现象是路由器的system一直闪黄灯</strong>，突然想到之前刷openwrt的时候， 刷入了官方的bootloader， 所以自然无法进入。下面介绍一下在openwrt的系统下，如何刷breed的bootloader。</p><p>在openwrt的web页面，将breed的固件<code>breed-mt7621-xiaomi-r3g.bin</code>上传到&#x2F;tmp路径下（其他路径也可以），然后ssh进入路由器命令行， 执行 如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">mtd_write -r write breed-mt7621-xiaomi-r3g.bin Bootloader</span><br></pre></td></tr></table></figure><p>之后重启路由器， 登录192.168.1.1就ok了。</p><p>上面的操作有一点需要注意，openwrt下ssh的默认用户名和密码， 网上找了半天都没找到（如果有人知道，可以留言告诉我一下）， 所以一直无法登录，后来发现我装的这个openwrt上面已经集成了ssh的设置， 可以使用秘钥的方式登录， 具体操作如下：</p><ul><li>windows下执行命令<code>ssh-keygen</code> 生成秘钥文件，在你的用户目录下的.ssh文件夹下会有两个文件：id_rsa和id_rsa.pub</li><li>在openwrt的页面下（具体哪个页面忘记截图了，是关于ssh设置的地方），将id_rsa.pub文件上传</li><li>使用xshell登录， 秘钥文件选择id_rsa， 即可在不知道ssh密码的情况下登录路由器的命令行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> AC2100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从alpine编译nginx的docker镜像</title>
      <link href="/posts/61959/"/>
      <url>/posts/61959/</url>
      
        <content type="html"><![CDATA[<p>因为需要接入nginx监控，用的是vts模块，原生nginx并没有包含该模块，原本想着用别人已经编译好的， 但是一想后期可能还需要加入其他的模块，所以还是自己编译一个。</p><p>下面说一下具体的步骤。</p><h1 id="编写dockerfile文件"><a href="#编写dockerfile文件" class="headerlink" title="编写dockerfile文件"></a>编写dockerfile文件</h1><p>此处用的几个主要软件版本：</p><ul><li>alpine: 3.17</li><li>nginx: 1.22.1</li><li>nginx-module-vts: 0.2.1</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">alpine:3.17</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">NGINX_VERSION</span> <span class="string">nginx-1.22.1</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">echo</span> <span class="string">https://mirrors.aliyun.com/alpine/v3.17/main/</span> <span class="string">&gt;</span> <span class="string">/etc/apk/repositories</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">     <span class="string">echo</span> <span class="string">https://mirrors.aliyun.com/alpine/v3.17/community/</span> <span class="string">&gt;&gt;</span> <span class="string">/etc/apk/repositories</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">apk</span> <span class="string">--update</span> <span class="string">add</span> <span class="string">openssl-dev</span> <span class="string">pcre-dev</span> <span class="string">zlib-dev</span> <span class="string">wget</span> <span class="string">build-base</span> <span class="string">libxslt-dev</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/tmp/src</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">cd</span> <span class="string">/tmp/src</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">wget</span> <span class="string">-O</span> <span class="string">nginx-module-vts.tar.gz</span> <span class="string">https://github.com/vozlt/nginx-module-vts/archive/refs/tags/v0.2.1.tar.gz</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">wget</span> <span class="string">http://nginx.org/download/$&#123;NGINX_VERSION&#125;.tar.gz</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">nginx-module-vts.tar.gz</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">$&#123;NGINX_VERSION&#125;.tar.gz</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">cd</span> <span class="string">/tmp/src/$&#123;NGINX_VERSION&#125;</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">./configure</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--prefix=/etc/nginx</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--sbin-path=/usr/sbin/nginx</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--conf-path=/etc/nginx/nginx.conf</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--error-log-path=/var/log/nginx/error.log</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--http-log-path=/var/log/nginx/access.log</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--pid-path=/var/run/nginx.pid</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--lock-path=/var/run/nginx.lock</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-compat</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-pcre-jit</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_ssl_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_stub_status_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_realip_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_auth_request_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_v2_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_dav_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_slice_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-threads</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_addition_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_gunzip_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_gzip_static_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_sub_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-http_xslt_module=dynamic</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-stream=dynamic</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-stream_ssl_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-mail=dynamic</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--with-mail_ssl_module</span> <span class="string">\</span></span><br><span class="line">        <span class="string">--add-module=/tmp/src/nginx-module-vts-0.2.1</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">make</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">apk</span> <span class="string">del</span> <span class="string">build-base</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/src</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/var/cache/apk/*</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/etc/nginx</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="string">CMD</span> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="编译镜像"><a href="#编译镜像" class="headerlink" title="编译镜像"></a>编译镜像</h1><p>编译镜像可以直接使用docker命令来编译， 我这儿为了方便，就使用jenkins来编译。</p><p>新建一个jenkins项目，项目类型选择”流水线”， 然后编写流水线脚本， 具体jenkins使用步骤这里就不描述了，这里贴一下我的脚本， 包含了代码拉取 -&gt; 镜像构建 -&gt; 镜像推送几个步骤。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">&quot;git pull&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                git <span class="attr">credentialsId:</span> <span class="string">&#x27;拉取凭证&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;你的git仓库地址，dockerfile文件要在仓库根路径&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker build -t 镜像tag .&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker push&#x27;</span>) &#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker login --username=*** --password=*** ***&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;docker push ***&#x27;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h1><p>在运行镜像的时候， 需要将nginx.conf文件挂载出来， 方便后续修改。</p><p>下面贴一个支持vts模块的nginx配置文件。</p><p>nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">load_module /etc/nginx/modules/ngx_stream_module.so;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    gzip  on;</span><br><span class="line">    # nginx-vts</span><br><span class="line">    vhost_traffic_status_zone;</span><br><span class="line">    vhost_traffic_status_filter_by_host on;   #开启此功能，会根据不同的server_name进行流量的统计，否则默认会把流量全部计算到第一个上。</span><br><span class="line">    vhost_traffic_status_filter on;</span><br><span class="line">    vhost_traffic_status_filter_by_set_key $status $server_name;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /status &#123;</span><br><span class="line">           vhost_traffic_status_display;</span><br><span class="line">           vhost_traffic_status_display_format html;</span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> docker - jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题使用css添加网格背景</title>
      <link href="/posts/65472/"/>
      <url>/posts/65472/</url>
      
        <content type="html"><![CDATA[<p>给hexo的博客添加一个网格背景， 此处不想使用图片， 而是直接使用css来实现，效果图如下：</p><p><img src="https://pic.7billapp.com/63e30db50697e.png"></p><p>css文件内容如下（文件名background.css）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:white;</span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,<span class="built_in">rgba</span>(<span class="number">241</span>,<span class="number">243</span>,<span class="number">244</span>,<span class="number">1</span>) <span class="number">10%</span>,transparent <span class="number">0</span>),<span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">241</span>,<span class="number">243</span>,<span class="number">244</span>,<span class="number">1</span>) <span class="number">10%</span>,transparent <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background-size</span>:<span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了各个hexo主题都能通用， 此处使用hexo提供的注入功能将css注入到博客中。</p><p>在博客根目录下新建一个scripts文件夹， 然后在该文件下新建一个js文件（命名随便都行），复制如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">injector</span>.<span class="title function_">register</span>(<span class="string">&#x27;head_end&#x27;</span>,<span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/background.css&quot;&gt;&#x27;</span>,<span class="string">&#x27;default&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中，<code>background.css</code>文件就是上文提到的css文件， 位于博客根目录的source&#x2F;css文件夹，注意此处一定要在博客根目录的source文件夹下创建，如果在其他文件夹下，可能识别不到或被主题覆盖。</p><p>同理， 其他想脱离特定主题（有些主题提供了自定义css、js的功能， 但是不通用，换了一个主题就无法使用）而实现注入css、js的功能， 都可以使用这种方法来实现。</p><p>具体hexo的注入功能查阅hexo的文档即可，地址：<a href="https://hexo.io/zh-cn/api/injector.html">https://hexo.io/zh-cn/api/injector.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>live555搭建流视频服务播放视频文件</title>
      <link href="/posts/16866/"/>
      <url>/posts/16866/</url>
      
        <content type="html"><![CDATA[<p>为了方便，使用docker搭建，用的是docker hub上使用人数最多的一个镜像， <code>docker-compose.yml</code>文件内容如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">live555:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">vimagick/live555</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">live555</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">554</span><span class="string">:554</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/data</span></span><br></pre></td></tr></table></figure><p>视频文件放在当前目录的data文件夹下， 然后使用vlc播放rtsp流地址测试一下， rtsp地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://ip:554/demo.264</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selfhost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存分配机制介绍</title>
      <link href="/posts/17167/"/>
      <url>/posts/17167/</url>
      
        <content type="html"><![CDATA[<p>本文针对的是hotspot虚拟机， jdk版本1.8的虚拟机进行介绍。</p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>线程私有，可以看做是当前线程所执行的字节码的行号，用于下一次线程切换的时候虚拟机定位到上一次执行的位置。 </p><p>‍</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>在一个时间点，只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈。</p><p>总结几点如下：</p><ul><li>线程私有，生命周期与线程相同。描述的是方法执行的内存模型。</li><li>进入方法时对应入栈，方法结束的时候对应出栈。</li><li>该区域存储着局部变量，操作数，方法出口等信息。</li></ul><p>‍</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><blockquote><p>线程共享。用于存储类信息、常量池、静态变量、JIT编译后的代码等数据。具体放在哪里，不同的实现可以放在不同的地方。</p><p><strong>一般情况可以理解成class文件在内存中的存放位置。</strong></p></blockquote><p>在1.7和1.8之后的实现逻辑有所不同。</p><p>由于该区域大小一般较小，所以不会对该区域进行垃圾回收。所以在1.7之前的版本，有可能会因为字符串常量池过大导致该区域内存溢出(Permgen space out of memory error)。</p><p><strong>永久代（PermGen)和方法区之间是什么关系？</strong></p><ol><li><p>方法区是虚拟机规范中的一部分，而永久代是hotspot虚拟机用来实现方法区的， 是hotspot虚拟机特有的。</p></li><li><p><strong>在1.7之前，永久代就是方法区</strong>。</p></li><li><p><strong>从1.8开始，hotspot移除了永久代，将方法区的实现分为两部分</strong>：</p><ol><li>将原先永久代中的<strong>类的</strong>​<strong>静态变量</strong>和<strong>常量池</strong>放入堆中</li><li>将类的元信息放入<strong>元空间（metaspace</strong> ）中</li></ol></li></ol><p>‍上文中介绍到的几个概念分别做一一说明：</p><ul><li>类型信息：包括类的完整名称，父类名称等，该类型信息是在类加载器加载类的时候从类文件中提取出来的。</li><li><strong>元空间：metaspace ，是与堆不相连的一块本地内存</strong>。Java将其放在本地内存中， 默认只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大。可以使用参数  <code>-XX:MaxMetaspaceSize</code> 参数来指定 metaspace 区域的大小</li><li>字面量：给基本类型变量赋值的方式就叫做字面量或者字面值</li><li>常量池：java中的常量池分为两种， 静态常量池和运行时常量池（此处指的是运行时常量池）：<ul><li>静态常量池。即class文件中的常量池，主要用于存放两大类常量：<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)。 其中字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul></li><li>运行时常量池。jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中</li></ul></li></ul><p>‍</p><h1 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h1><p>不是虚拟机运行时数据区的一部分。JDK中主要是NIO库中一些直接操作本地内存的类， 例如DirectByteBuffer。</p><p>其内存大小虽然不受堆最大内存的制约，但是也会受到操作系统最大内存的制约。</p><p>Java中NIO的核心缓冲ByteBuffer，所有的IO操作都是通过这个ByteBuffer进行的。Bytebuffer有两种： HeapByteBuffer和DirectByteBuffer，下面是这两种内存的分配方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="type">int</span> capacity);</span><br><span class="line"><span class="comment">//分配DirectByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="type">int</span> capacity);</span><br></pre></td></tr></table></figure><p>两者之间的区别：</p><table><thead><tr><th></th><th><strong>DirectByteBuffer</strong></th><th><strong>HeapByteBuffer</strong></th></tr></thead><tbody><tr><td><strong>涉及到IO时拷贝情况</strong></td><td>不需要拷贝，直接使用</td><td>需要拷贝到HeapByteBuffer后再使用</td></tr><tr><td><strong>创建开销</strong></td><td>需要调用原生方法从系统申请内存， 所以创建开销较大。 不过一般应用会提前申请一大块内存， 然后自己实现内存管理机制， 例如netty</td><td>从JVM堆上分配，速度很快，所以创建开销小</td></tr><tr><td><strong>对于GC的影响</strong></td><td>不存在于堆栈中， 但是有冰山现象的问题</td><td>频繁申请新的对象会引发GC</td></tr></tbody></table><p><strong>为啥要使用堆外内存？</strong></p><ol><li>可以在进程间共享，减少虚拟机间的复制</li><li>对垃圾回收停顿的改善：如果应用中包含大量长期存活的对象，发生YGC或者FullGC的频率就会比较高，此时如果将这些内存放到堆外，就会减少堆中发生GC的次数，提高垃圾回收效率</li><li>在某些场景下可以提升程序I&#x2F;O操纵的性能。因为少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ol><p>‍</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>JVM中空间占比最大的一块区域。被所有线程共享。几乎所有的对象实例和数组都会存储在此地。垃圾收集主要是针对此处进行工作。</p><p>主要分为新生代和老年代，见下图分配示意。</p><p><img src="https://pic.7billapp.com/63df190e0e114.jpg"></p><p><strong>先讲述一下新生代的事。以下垃圾回收的算法其实也就是复制算法的实现。</strong></p><p>新生代，顾名思义，<strong>Java中绝大部分对象都是在该区域被创建，存放新建创建的对象</strong>。其特点是对象更新速度快，因为Java中大多数对象都不需要存活很长时间（典型的就是局部变量）。该区域是进行垃圾回收频繁的区域，且进行的垃圾回收类型是Minor GC（GC发生的区域不是整个新生代，而是新生代中的Eden区）。</p><p><strong>新生代</strong>又被分为Eden区，S0区，S1区（S代表Survivor)。默认参数是Eden区占新生代的绝大部分空间（8:1）。当一个对象被创建的时候，首先会在Eden区分配空间（对于大数组， 也有可能第一次就直接在老年代分配）。当Eden区没有足够的空间时，会触发一次<code>Minor GC</code>，此时会将存活的对象移动到S0，再将Eden清空。若再次发生Minor GC,则将Eden,S0中存活的对象移动到S1，再将Eden，S0清空。</p><p>这样对象就会反复在新生代的三个区之间来回移动，随着对象的移动，其GC年龄也会不断增加，当GC年龄达到一个默认值（15）的时候，就会将该对象实例移动到老年代，如此，老年代的数据就出来了。所以，老年代的数据都是新生代中那些存活年龄很大的对象。</p><p>经过以上步骤，老年代已经呼之欲出了。当老年代空间不足时，也会触发一次GC，此时的GC又叫<code>Full GC</code>，比新生代发生的Minor GC要慢得多。</p><p>‍比如常见的在方法中new一个对象的写法， 如下所示：</p><p><code>Object obj = new Object();</code></p><p>在等于号右边 <code>new Object()</code>出来的对象是存储在堆上；</p><p>在等于号左边<code>obj</code>这个对象引用是存储在该方法的虚拟机栈上；</p><p>表示<code>Object</code>这个对象的class属性是存储在方法区上（运行时常量池）；</p><h1 id="jvm问题排查工具"><a href="#jvm问题排查工具" class="headerlink" title="jvm问题排查工具"></a>jvm问题排查工具</h1><h2 id="1-排查是否频繁full-gc"><a href="#1-排查是否频繁full-gc" class="headerlink" title="1. 排查是否频繁full gc"></a>1. 排查是否频繁full gc</h2><p>当整个服务出现响应缓慢的时候， 一个可能的原因是此时jvm正在频繁的进行full gc， 那么如何确定是不是这个原因呢？可以使用<code>jstat</code>命令来判断（如果使用的是openjdk的docker， 一般路径在&#x2F;usr&#x2F;lib&#x2F;jvm下）， 步骤如下：</p><ol><li><code>jps -l</code> 获取java进程的进程号 </li><li>查询GC状态 <code>jstat -gc 6 1000</code> , 其中 6表示JVM的进程号， 1000表示每隔1000ms打印<br> 一次， 输出结果如下：<br> <img src="https://pic.7billapp.com/202403011536666.png"></li></ol><p>  其中倒数第三列FGC表示full gc的次数， 如果一直在增长， 则很有可能是发生了OOM， 导致一直在full gc</p><ol start="3"><li><p>若出现了full gc, 需要导出堆栈，命令如下：(有时候JVM已经处于假死状态，可能不会响应该命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6是进程号</span></span><br><span class="line">jmap -dump:format=b,file=/var/logs/heap.hprof 6</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-JVM参数设置"><a href="#2-JVM参数设置" class="headerlink" title="2. JVM参数设置"></a>2. JVM参数设置</h2><p>启动参数加上如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># oom的时候自动生成dump文件</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/heapdump.hprof</span><br><span class="line"></span><br><span class="line"># 输出gc日志到文件</span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/gc.log</span><br></pre></td></tr></table></figure><p>注意， 有时候即使设置了此参数，也有可能无法生成对应的dump文件， 可能的原因有如下几个：</p><ol><li>JVM本身内存已经所剩无几：JVM 可能没有足够的内存来生成堆转储文件，特别是在堆栈溢出或其他严重内存问题发生时。</li><li>磁盘不够或目录权限错误：这个一般修改参数或增大磁盘即可</li><li>OOM是发生在GC线程中：不过这个一般不太会可能发生</li></ol><h2 id="3-分析工具使用"><a href="#3-分析工具使用" class="headerlink" title="3. 分析工具使用"></a>3. 分析工具使用</h2><p>除了一些常用的命令之外， 一些图形化的工具也非常有助于分析问题</p><ul><li>分析gc的log日志用 <code>gcviewer</code>,  下载之后直接使用 <code>java -jar</code> 命令启动即可</li><li>分析堆栈文件用MAT(Eclipse Memory Analyzer)、visualvm或者jprofile</li></ul><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/161939673">https://zhuanlan.zhihu.com/p/161939673</a></li><li>深入理解Java虚拟机</li><li>[<a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/]">https://www.sczyh30.com/posts/Java/jvm-metaspace/]</a>(</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins使用流水线打包springboot和vue镜像</title>
      <link href="/posts/22182/"/>
      <url>/posts/22182/</url>
      
        <content type="html"><![CDATA[<p>使用jenkins的流水线功能，可以很方便的知道各个步骤的执行进度和所用时间，还是比较方便的。</p><p>在流水线中可以使用docker进行打包， 这样就可以很方便的使用任何docker镜像，而不需要安装对应的环境。</p><p><img src="https://pic.7billapp.com/63df1911d4739.png"></p><p>本文要实现的目的如下：</p><ol><li>从git仓库拉取代码，并允许指定分支或tag</li><li>jenkins编译代码</li><li>构建镜像</li><li>push镜像到远程仓库（此处是阿里云仓库）</li></ol><h1 id="使用前准备"><a href="#使用前准备" class="headerlink" title="使用前准备"></a>使用前准备</h1><p>本文的jenkins本身也是docker安装的， 为了直接使用宿主机的docker，需要在安装jenkins容器的时候将宿主机的docker映射到jenkins容器中，比如使用docker-compose时其部分配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">- /usr/bin/docker:/usr/bin/docker</span><br></pre></td></tr></table></figure><h1 id="Java镜像构建"><a href="#Java镜像构建" class="headerlink" title="Java镜像构建"></a>Java镜像构建</h1><h2 id="springboot工程"><a href="#springboot工程" class="headerlink" title="springboot工程"></a>springboot工程</h2><p>需要有一个springboot工程的仓库，并且在项目的根文件下新建一个Dockerfile文件， 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> target/app.jar app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">15800</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;-Dspring.profiles.active=prod&quot;</span>, <span class="string">&quot;app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>同时还需要在项目的根目录下新建一个 settings.xml文件，用于指定中央仓库地址和本地仓库地址， 方便缓存，国内一般可以指定maven的仓库地址为阿里云， 文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/root/.m2<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="jenkins项目"><a href="#jenkins项目" class="headerlink" title="jenkins项目"></a>jenkins项目</h2><p>jenkins新建项目， 风格选择“流水线”，然后在流水线处加入groovy脚本， 下面这个是结合git仓库所使用的groovy脚本内容， 可以直接粘贴到jenkins上。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> branchTransform(branch) &#123;</span><br><span class="line"><span class="keyword">return</span> branch.replace(<span class="string">&quot;origin/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> t = branchTransform(<span class="string">&quot;$&#123;TAG&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            image <span class="string">&#x27;maven:3.8.5-openjdk-17&#x27;</span></span><br><span class="line">            args <span class="string">&#x27;-v /opt/docker/jenkins/repo/mvn:/root/.m2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">&quot;git pull&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="attr">$class:</span> <span class="string">&#x27;GitSCM&#x27;</span>, <span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&#x27;$&#123;TAG&#125;&#x27;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;.....&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;....&#x27;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        stage(<span class="string">&#x27;mvn package&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn clean package -DskipTests=true -s settings.xml -B -U&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker build -t your_registry/service:&#x27;</span> + t + <span class="string">&#x27; .&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker push&#x27;</span>) &#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker login --username=username --password=password your_registry&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;docker push your_registry/service:&#x27;</span> + t</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面脚本的内容进行一一说明：</p><ol><li><p>branchTransform函数， 是在之前指定了一个构建参数， 此处是git的分支或tag， 这样可以在构建的时候手动指定分支或tag, 设置过程如下图所示（需要提前安装git paramter插件才会有这个界面）：<img src="https://pic.7billapp.com/202403011540752.png"></p></li><li><p>由于此处使用的是java版本是17，所以使用的maven镜像是<code>maven:3.8.5-openjdk-17</code>, 同时为了加快构建，此处选择将maven的本地仓库地址持久化，注意，此处的maven镜像其实是宿主机上的，所以在进行目录映射的时候， 映射的也是宿主机的路径和maven容器中的路径，对于本例：</p><ul><li>&#x2F;opt&#x2F;docker&#x2F;jenkins&#x2F;repo&#x2F;mvn  宿主机上的路径，maven仓库都会被缓存到此处</li><li>&#x2F;root&#x2F;.m2 maven镜像中的路径，是在上一步中settings.xml文件中指定的</li></ul></li><li><p>git pull  从仓库中拉取代码， 可以直接使用jenkins自带的流水线语法来生成， 注意， 需要提前生成一个凭证，用于从git仓库获取代码<br><img src="https://pic.7billapp.com/202403011540801.png"></p></li><li><p>mvn package  编译java代码</p></li><li><p>docker build 构建docker镜像</p></li><li><p>docker push 将镜像push到远程仓库</p></li></ol><h1 id="vue镜像构建"><a href="#vue镜像构建" class="headerlink" title="vue镜像构建"></a>vue镜像构建</h1><h2 id="vue工程"><a href="#vue工程" class="headerlink" title="vue工程"></a>vue工程</h2><p>此处是使用nginx来运行编译后的vue项目，所以实际上构建的是一个nginx镜像。</p><p>需要在vue项目根目录下新建一个Dockerfile文件， 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.22</span>.<span class="number">1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">15802</span></span><br></pre></td></tr></table></figure><p>同时，还需要在项目根目录下新建一个nginx.conf文件，用于nginx的一些配置，比如端口转发等。</p><h2 id="jenkins项目-1"><a href="#jenkins项目-1" class="headerlink" title="jenkins项目"></a>jenkins项目</h2><p>基本过程同springboot一样， 此处就不在赘述，直接贴一个groovy脚本， 内容如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> branchTransform(branch) &#123;</span><br><span class="line"><span class="keyword">return</span> branch.replace(<span class="string">&quot;origin/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> t = branchTransform(<span class="string">&quot;$&#123;TAG&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            image <span class="string">&#x27;node:12.5.0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">&quot;git pull&quot;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="attr">$class:</span> <span class="string">&#x27;GitSCM&#x27;</span>, <span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&#x27;$&#123;TAG&#125;&#x27;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;......&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;......&#x27;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(<span class="string">&#x27;npm run build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;npm config set registry https://registry.npm.taobao.org&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;npm install&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;npm run build&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker build -t your_registry/service:&#x27;</span> + t + <span class="string">&#x27; .&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;docker push&#x27;</span>) &#123;</span><br><span class="line">           when &#123; environment <span class="attr">name:</span> <span class="string">&#x27;PUSH&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;true&#x27;</span> &#125;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker login --username=username --password=password your_registry&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;docker push your_registry/service:&#x27;</span> + t</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> springboot </tag>
            
            <tag> jenkins </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用prometheus监控clickhouse</title>
      <link href="/posts/34295/"/>
      <url>/posts/34295/</url>
      
        <content type="html"><![CDATA[<p>较新版本的clickhouse内部已经支持暴露监控数据给prometheus, 所以此处就不用另外部署clickhouse-exporter服务来获取监控数据。</p><h1 id="clickhouse配置"><a href="#clickhouse配置" class="headerlink" title="clickhouse配置"></a>clickhouse配置</h1><p>修改clickhouse的配置文件<code>config.xml</code>, 将<code>prometheus</code>这一项原先的注释放开，使其生效。</p><p>官方文档路径：<a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-prometheus">https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-prometheus</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prometheus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endpoint</span>&gt;</span>/metrics<span class="tag">&lt;/<span class="name">endpoint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9363<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">metrics</span>&gt;</span>true<span class="tag">&lt;/<span class="name">metrics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">events</span>&gt;</span>true<span class="tag">&lt;/<span class="name">events</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asynchronous_metrics</span>&gt;</span>true<span class="tag">&lt;/<span class="name">asynchronous_metrics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">status_info</span>&gt;</span>true<span class="tag">&lt;/<span class="name">status_info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">prometheus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后重启服务，此处配置的端口是9363，可以执行如下命令验证配置是否成功：</p><p><code>curl http://localhost:9363/metrics|less</code></p><p>如果有输出如图所示，则表示配置生效。</p><p><img src="https://pic.7billapp.com/63df190a07d8b.png"></p><h1 id="prometheus配置"><a href="#prometheus配置" class="headerlink" title="prometheus配置"></a>prometheus配置</h1><p>修改<code>prometheus.yml</code>文件，增加一个clickhouse的job。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;clickhouse-exporter&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;10.0.0.239:9363&#x27;</span>]</span><br></pre></td></tr></table></figure><p>注意此处的端口就是之前clickhouse配置prometheus的端口。</p><p>重启prometheus服务，打开prometheus web页面上的targets页面， 如果看到clickhouse状态是up的话，表示集成成功。</p><p><img src="https://pic.7billapp.com/63df190a847d8.png"></p><h1 id="grafana-配置"><a href="#grafana-配置" class="headerlink" title="grafana 配置"></a>grafana 配置</h1><p>可以自己手动添加dashboard，也可以在grafana官网上找一个图表，直接导入即可。本人用的ID是：14432</p><p>导入这个ID之后， 效果如下：</p><p><img src="https://pic.7billapp.com/63df190ad8e45.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> clickhouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
            <tag> prometheus </tag>
            
            <tag> clickhouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>克服自己</title>
      <link href="/posts/14802/"/>
      <url>/posts/14802/</url>
      
        <content type="html"><![CDATA[<p>要克服自己的缺陷，打败自己， 这句话说起来容易做起来却是很难。</p><p>你会因为惯性去做使自己舒适的事，这样就容易在舒适的道路上越走越远，也就与你自己制定的目标相去甚远。</p><p>如此，要怎样克服自己？</p><p>我觉的有如下几点需要注意。</p><p>首先不要给自己过于遥远的目标，这样你是一定无法完成的，就会产生懈怠心理。</p><p>其次，对于目标一定要检验成果，并且记录下来，不要欺骗自己。</p><p><strong>共勉之！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构中关于事务的一些思考</title>
      <link href="/posts/56453/"/>
      <url>/posts/56453/</url>
      
        <content type="html"><![CDATA[<p><strong>分布式事务</strong> 指的是当事务的操作分布在不同的节点上时， 需要保证事务的ACID特性。 其中最重要的一点是要保证在各个节点上的事务要么同时成功，要么同时失败。</p><p>分布式事务的解决方案有多种，下面对几种常见的进行一一说明。</p><h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><p>2PC， Two-phase Commit 。两阶段提交，通过引入协调者（Coordinator）来协调所有参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p>两个阶段分别如下：</p><ul><li>第一阶段：<strong>准备阶段</strong>。由协调者询问各个参与节点事务是否执行成功，参与节点返回事务执行结果。参与节点收到通知之后，会进行准备操作，例如执行insert（此时并未commit)，准备完成之后会告诉协调节点自己已经准备完成。</li><li>第二阶段：提交阶段。协调节点在收到所有参与节点都执行成功之后，就会通知所有节点进行提交操作。若任一节点执行失败，协调节点则会通知所有参与节点回滚数据。</li></ul><p>主要缺点如下：</p><ul><li><strong>阻塞</strong>。 需要等待所有参与者确认OK之后才能commit， 其处理的时间取决于处理事务最慢的那个参与节点。所以不适合并发高的场景。</li><li><strong>单点故障</strong>。 特别是对协调节点的依赖很大，若协调节点发生故障，则整个事务都将不可用</li><li><strong>数据不一致。</strong>比如在第二阶段，某些参与节点在接收到commit之后发生故障，将会导致这些参与节点的数据与其他节点数据不一致</li></ul><h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><blockquote><p>其核心思想是对于每个操作，都需要有一个与其对应的补偿（或者叫撤销）操作</p></blockquote><p>一般分为三个阶段：</p><ul><li><p>try: 尝试去执行，完成所有业务的一致性检查，预留必须的业务资源</p></li><li><p>confirm: 该阶段对业务进行确认提交，不做任何检查，因为 try 阶段已经检查过了，默认 Confirm 阶段是不会出错的</p></li><li><p>cancel: 若业务执行失败，则进入该阶段，它会释放 try 阶段占用的所有业务资源，并回滚 Confirm 阶段执行的所有操作</p></li></ul><p>TCC有一个大的前提，就是这三个动作必须都是幂等的，对业务有一定的要求。拿资金转账来说，try就是冻结金额；confirm就是完成扣减；cancel就是解冻，只要对应的订单号是一样的，多次执行也不会有任何问题。</p><p><strong>由于TCC中事务的发起方是直接在各个业务节点上，所以不需要协调者</strong>， 这样也就不会存在2PC中所说的资源阻塞的问题，因为在confirm阶段每个参与节点都已经提交事务了，不需要等待其他节点，所以其并发能力较好。</p><p> 其最大的缺点是对代码的侵入性太强，相当于业务层去保证事务，需要业务自己去将confirm和cancel抽象出来，对于某些场景会造成大量的编码，甚至难以执行。</p><h1 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h1><blockquote><p>通过mq来实现，当发起事务的系统发送mq之后，需要消费的服务接受到该mq之后，就会执行自己的相应处理逻辑，从而达到最终一致性。</p></blockquote><p><img src="https://pic.7billapp.com/63fdff784c4ce.png"></p><p><strong>本地消息表</strong></p><p>业务系统写数据库和发送mq不是一个事务过程， 所以可能会存在写数据库成功，但发送mq失败， 此时就需要引入一个<code>本地消息表</code>，在写数据的同时写入一条消息到本地消息表中，一般状态分为“进行中”、“完成”等状态，由于写业务表和写本地消息表都是操作同一个DB，所以是一个本地事务，能够保证同时完成或同时失败。</p><p>引入本地消息表还有两个注意点：</p><ol><li>需要有一个定时任务，去定期扫描消息表中不是完成状态的消息，进行重新发送</li><li>由于mq存在重复发送的问题，需要其他的业务系统做好幂等处理</li></ol><p><strong>缺点：</strong></p><ol><li>本地消息表与业务系统耦合比较严重， 对代码的抽象不好处理</li><li>由于每条消息都要写本地消息表，对数据库的压力比较大</li></ol><h1 id="支持事务的mq"><a href="#支持事务的mq" class="headerlink" title="支持事务的mq"></a>支持事务的mq</h1><p>其实是对本地消息表的一个封装，如前文所说，普通的mq消息无法和单机数据库一样，具备提交、回滚的能力，所以支持事务的mq，比如rocketmq相当于将本地消息表在mq内部进行了实现。</p><p>其他方面的实现和本地消息表类似。</p><p>参考资料：</p><ol><li><a href="https://www.cnblogs.com/lfs2640666960/p/12300585.html">https://www.cnblogs.com/lfs2640666960/p/12300585.html</a></li><li><a href="https://juejin.cn/post/7012425995634343966#heading-19">https://juejin.cn/post/7012425995634343966#heading-19</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式事务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>drone和gitea集成以及hexo博客的自动部署</title>
      <link href="/posts/46218/"/>
      <url>/posts/46218/</url>
      
        <content type="html"><![CDATA[<p>未完待续！</p><p>目的是为了实现hexo博客的自动部署， 每次push完之后， 触发drone ci自动进行部署。</p><p>选用drone的原因还是因为轻量， 且功能够用，如果用其他的CI工具，比如jenkins，我这小小的VPS部署服务一多，就扛不住了。</p><p>本文中drone是和gitea进行集成的， 如果要和其他仓库集成， 参考官方文档即可：<a href="https://docs.drone.io/">https://docs.drone.io/</a></p><p>部署服务还是通过docker来进行。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>登录gitea, 进入设置-&gt;应用， 新建一个给drone用的OAuth2授权</p><p><img src="https://pic.7billapp.com/63df1905ddfbb.png"></p><p>注意， 重定向URI(Redirect URI)是你的drone服务的域名加上login。</p><p>生成授权之后， 会得到一个客户端ID和客户端秘钥， 记下来， 后面会用到。</p><h1 id="drone搭建"><a href="#drone搭建" class="headerlink" title="drone搭建"></a>drone搭建</h1><p>本文在部署的时候， 是将drone和gitea进行集成， </p><p>drone的服务分为两部分：</p><ul><li>drone-server</li><li>drone-runner-docker</li></ul><p>本人将这两个服务都部署在同一个docker-compose.yml中，同时数据库还是连接的一个单独的mysql容器服务，所以需要先创建数据库， 命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database drone <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>下面是docker-compose.yml文件， 其中<code>db-net</code>就是一个包含mariadb容器的docker网络， 具体创建过程见另外一篇博客：个人博客工具搭建。各个参数见说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">drone-server:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">drone/drone:2.12.1</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">drone-server</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="attr">db-net:</span></span><br><span class="line">                <span class="attr">aliases:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">drone</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;6340:80&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/data</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_SERVER_HOST=drone服务的域名</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_SERVER_PROTO=https</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=自已生成的一个随机字符串即可</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_GITEA_CLIENT_ID=之前在gitea上生成的客户端ID</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_GITEA_CLIENT_SECRET=之前在gitea上生成的客户端密钥</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_GITEA_SERVER=gite的地址</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_DATABASE_DATASOURCE=数据库连接地址，格式</span> <span class="string">username:password@tcp(host:port)/drone</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_DATABASE_DRIVER=mysql</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_USER_CREATE=username:sobriver,admin:true</span> <span class="comment"># 一定要配，否则无法登录gitea</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">drone-runner-docker:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">drone/drone-runner-docker:1.8.2</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">drone-runner-docker</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">drone-server</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RPC_HOST=drone服务的域名</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RPC_PROTO=https</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=自已生成的一个随机字符串即可,和server的要一样</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RUNNER_CAPACITY=2</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">DRONE_RUNNER_NAME=docker-runner</span></span><br></pre></td></tr></table></figure><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> 你的域名</span><br><span class="line">    charset utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>   域名pem文件;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> 域名key文件;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:6340;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务启动之后，打开登录页面， 会自动跳转到gitea的登录， 登录成功之后， 对应于相应的仓库， 激活即可。</p><h1 id="drone-yml文件编写"><a href="#drone-yml文件编写" class="headerlink" title=".drone.yml文件编写"></a>.drone.yml文件编写</h1><p>此处实现当我们写完一篇文章，push到远程之后，自动触发hexo的构建，并将构建完成之后的文件移动到博客文件目录。</p><p>在项目的根目录下创建<code>.drone.yml</code>文件， 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">kind: pipeline</span><br><span class="line">type: docker</span><br><span class="line">name: blog-job</span><br><span class="line">steps:</span><br><span class="line">- name: Hexo Build</span><br><span class="line">  image: node:12-alpine</span><br><span class="line">  commands:</span><br><span class="line">  - npm install hexo-cli -g</span><br><span class="line">  - npm install hexo-generator-sitemap --save</span><br><span class="line">  - npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">  - npm install</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo g</span><br><span class="line">- name: Origin File Clean</span><br><span class="line">  image: appleboy/drone-ssh</span><br><span class="line">  settings:</span><br><span class="line">    host: </span><br><span class="line">      from_secret: SSH_HOST</span><br><span class="line">    port: </span><br><span class="line">      from_secret: SSH_PORT</span><br><span class="line">    username: </span><br><span class="line">      from_secret: SSH_USERNAME</span><br><span class="line">    password:</span><br><span class="line">      from_secret: SSH_PASSWORD</span><br><span class="line">    script:</span><br><span class="line">      - rm -rf /blog/public/*</span><br><span class="line">- name: SCP File Transfer</span><br><span class="line">  image: appleboy/drone-scp</span><br><span class="line">  settings:</span><br><span class="line">    target: /blog</span><br><span class="line">    source: ./public</span><br><span class="line">    host: </span><br><span class="line">      from_secret: SSH_HOST</span><br><span class="line">    port: </span><br><span class="line">      from_secret: SSH_PORT</span><br><span class="line">    username: </span><br><span class="line">      from_secret: SSH_USERNAME</span><br><span class="line">    password:</span><br><span class="line">      from_secret: SSH_PASSWORD</span><br><span class="line">    rm: true</span><br><span class="line">  </span><br><span class="line">trigger:</span><br><span class="line">  event:</span><br><span class="line">  - push</span><br></pre></td></tr></table></figure><p>说一下几个步骤含义：</p><ul><li>Hexo Build  使用hexo构建文件</li><li>Origin File Clean  清除原先文件， 此处设置的构建文件的存储路径为<code>/blog/public/</code></li><li>SCP File Transfer 将构建完的文件移动到指定目录</li></ul><p>其中from_secret的值是利用drone的secret来新建的，如下图所示：</p><p><img src="https://pic.7billapp.com/63df1906572d3.png"></p><p>几个值含义如下：</p><ul><li>SSH_HOST  远程登录主机的IP</li><li>SSH_PORT 远程登录端口</li><li>SSH_USERNAME  远程登录用户名</li><li>SSH_PASSWORD 远程登录密码</li></ul><p>参考资料：</p><ol><li><a href="https://docs.drone.io/server/provider/gitea/">https://docs.drone.io/server/provider/gitea/</a></li><li><a href="https://www.qikqiak.com/post/drone-with-k8s-2/">https://www.qikqiak.com/post/drone-with-k8s-2/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> selfhost </tag>
            
            <tag> 博客 </tag>
            
            <tag> drone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录服务异常重启导致clickhouse启动失败</title>
      <link href="/posts/41380/"/>
      <url>/posts/41380/</url>
      
        <content type="html"><![CDATA[<p>测试环境中某个clickhouse实例由于意外断电而终止，重新启动报错，报错的关键信息 DB::ParsingException: Cannot parse input: expected ‘columns format version: 1\n’ at end of stream</p><p>其中报错的日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; &lt;Error&gt; auto DB::MergeTreeData::loadDataParts(bool)::(anonymous class)::operator()() const: Code: 27. DB::ParsingException: Cannot parse input: expected &#x27;columns format version: 1\n&#x27; at end of stream. (CANNOT_PARSE_INPUT_ASSERTION_FAILED), Stack trace (when copying this message, always include the lines below):</span><br></pre></td></tr></table></figure><p>可以搜一下github上面的issue，也有几个类似的问题， 例如：<a href="https://github.com/ClickHouse/ClickHouse/issues/37397%E3%80%82">https://github.com/ClickHouse/ClickHouse/issues/37397。</a></p><p>这个报错是因为clickhouse在启动服务的时候会检查损坏的数据文件块数量，如果超过一个特定值（默认是10，对应于max_suspicious_broken_parts配置），就会发生这个异常，导致无法启动。</p><p>而出现这么多损坏的文件块数据，是因为在系统异常断电的时候，有些数据还存在于内存中，并没有完全写入磁盘，导致出现数据不一致的情况。</p><p>解决方案有两个：</p><p><strong>（1）调整max_suspicious_broken_parts值</strong></p><p>让其在启动时能允许更多的损坏，但是这个值不好把控，主要取决于在断电的那一瞬间，不一致的数据量有多大，本人自测当调整到10000的时候，才能正常启动。</p><p>修改配置文件中如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;yandex&gt;</span><br><span class="line">     &lt;merge_tree&gt;</span><br><span class="line">         &lt;max_suspicious_broken_parts&gt;50&lt;/max_suspicious_broken_parts&gt;</span><br><span class="line">     &lt;/merge_tree&gt;</span><br><span class="line">&lt;/yandex&gt;</span><br></pre></td></tr></table></figure><p><strong>(2) 强制启动</strong></p><p>在clicckhouse数据根目录下的flags文件夹下创建一个force_restore_data文件，然后再重启服务即可。假设现在clickhouse的数据根目录是&#x2F;var&#x2F;lib&#x2F;clickhouse， 则执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /var/lib/clickhouse/flags/force_restore_data</span><br></pre></td></tr></table></figure><p>注意，无论上面哪种方式，都有可能会导致数据丢失。</p><p>参考文档：</p><ol><li><a href="https://github.com/ClickHouse/ClickHouse/issues/37397">https://github.com/ClickHouse/ClickHouse/issues/37397</a></li><li><a href="https://kb.altinity.com/altinity-kb-setup-and-maintenance/suspiciously-many-broken-parts/">https://kb.altinity.com/altinity-kb-setup-and-maintenance/suspiciously-many-broken-parts/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> clickhouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clickhouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中undo、redo、binlog日志区别和说明</title>
      <link href="/posts/50187/"/>
      <url>/posts/50187/</url>
      
        <content type="html"><![CDATA[<p>本文针对的都是MySQL的Innodb引擎。</p><h1 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1. binlog"></a>1. binlog</h1><p>二进制日志。记录数据库的所有写操作。注意此处记录的是逻辑日志。</p><p>可用于主从复制、增量备份、监听binglog实现缓存一致性。</p><h2 id="1-1-常用命令"><a href="#1-1-常用命令" class="headerlink" title="1.1 常用命令"></a>1.1 常用命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog配置信息</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看所有的binlog文件</span></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前正在使用的binlog文件</span></span><br><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><h2 id="1-2-写入策略"><a href="#1-2-写入策略" class="headerlink" title="1.2 写入策略"></a>1.2 写入策略</h2><p>通过<code>show binary logs</code>命令可以看到当前数据库使用的哪些binlog文件， 如下图所示：</p><p><img src="https://pic.7billapp.com/63df191118e8a.png"></p><p>mysql会按照一定的规则，生成对应的日志文件，并按照编号从小到大依次生成。</p><p>binlog日志在写入时， 按照其日志记录类型不同， 分为如下三种情况：</p><ul><li><p><strong>statement</strong>：  记录的是sql原文， 每一条对数据的写操作都会记录在binlog中</p><ul><li>优点： 不需要记录每一行的变化， 能够减少binlog日志量，提升性能。</li><li>缺点：由于记录的是sql原文，所以还需要记录一些额外的相关信息，用来确保在master和slave上执行都是相同的效果。另外有一些函数是无法被复制的， 例如 UUID()</li></ul></li><li><p><strong>row</strong>：记录的是每一行的变化</p><ul><li>优点：可以清楚的表示每一行的数据变化，所以不需要记录额外信息，同时也无需担心函数执行在不同的节点上会有不同的效果</li><li>缺点：会产生大量的日志，特别是那些涉及到整个表的操作，比如增加一个字段，会对该表的所有记录都会产生一条binlog</li></ul></li><li><p><strong>mixed</strong> 混合模式。普通操作使用statement，当无法使用statement时，则使用row</p></li></ul><h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2. redo log"></a>2. redo log</h1><blockquote><p>重做日志。redo log 是物理日志格式, <strong>存储的是对于每个页的修改</strong>的物理情况。</p><p>用来保证事务的<strong>原子性和持久性</strong>。</p></blockquote><h2 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h2><p>mysql为了提高效率，对于数据的修改首先都是在内存中进行的，也就是下图中的Buffer Pool，然后按照一定的策略刷新到磁盘中去。</p><p>此时就会存在一个问题， 当数据被写入到内存， 但是还没有刷新到磁盘，此时若数据库宕机，那么该数据页上的数据就会丢失。</p><p>为了解决这个问题，mysql引入了redo log， 每次对数据页的修改，都会存储到一个redo log日志文件中去，当出现异常宕机后，数据库实例重新启动时，就会去检查这个redo log文件，并对事务进行重放，从而恢复数据。</p><h2 id="2-2-写入策略"><a href="#2-2-写入策略" class="headerlink" title="2.2 写入策略"></a>2.2 写入策略</h2><p>redo log 也并不是直接写入磁盘的，而是先写入到redo log buffer， 然后按照一定的条件顺序的写入到磁盘中去。</p><p><img src="https://pic.7billapp.com/63df1911651cb.png"></p><p><strong>redo log文件路径</strong>： 在数据根目录下会有两个文件<code>ib_logfile0</code>和<code>ib_logfile1</code>两个文件， 都是用来存储redo log的， 并且写入的时候是轮流写入的。</p><p>redo log 分为两部分:</p><ul><li>redo log buffer 内存中的重做日志缓存, 易丢失</li><li>redo log file 磁盘中的重做日志文件, 持久化</li></ul><p>参数<code>innodb_flush_log_at_trx_commi</code> 控制重做日志redo log buffer刷新到磁盘的策略, 默认值为1, 其取值含义如下:</p><ul><li>取值1：  <strong>事务提交时必须调用一次fsync操作， 默认值</strong>。这种情况不会造成redo log本身的丢失， 假设一种极端情况， 当事务未提交时，数据库宕机，当数据库重新启动的时候， 因为这个事务没有写入到redo log, 所以也没有办法进行恢复， 但这种情况本身也是符号预期的。</li><li>取值0：事务提交时不进行fsync操作。那么什么时候将其刷新到磁盘呢? 在master thread中, 每隔1秒就会进行一次fsync操作。这种情况可能会造成这一秒内的数据丢失。</li><li>取值2： 事务提交时, 仅将重做日志刷新到文件系统系统缓存, 不进行fsync操作，由文件系统来负责进行刷盘操作。 当服务器发生宕机时，当文件系统的缓存还未刷新到磁盘，也会造成数据的丢失。</li></ul><p>综上， 要想保证数据一定不会丢失， 需要将 <code>innodb_flush_log_at_trx_commi</code>设置为1， 其他两种情况都有可能会造成数据的丢失。</p><p>此处有一个问题， 既然redo log也要写入文件， 那为啥不直接将buffer pool中的数据直接刷新到磁盘呢？</p><p>有两个原因：</p><ol><li>redo log 写入的时候是顺序写入的， 而buffer pool中的数据页在磁盘中是随机存储的，所以其写入也是随机写的， 而我们直到磁盘顺序写入和随机写入的性能差距很大</li><li>通常一次数据修改，涉及到的数据很小，此时redo log就会很小，可能只有几个字节。而buffer pool中的每个数据页大小都是16KB， 写入的时候是以数据页为单位进行的，所以最小也是16KB， 相对而言， 写入的数据量更小，性能也会更高</li></ol><p>注意，在8.0之后， mysql将AUTO_INCREMENT计数器的变化也写入到重做日志中， 当 MySQL 服务被重启或者处于崩溃恢复时，它可以从持久化的检查点和重做日志中恢复出最新的 <code>AUTO_INCREMENT</code> 计数器，避免出现不单调的主键。</p><h2 id="2-3-redo与bin区别"><a href="#2-3-redo与bin区别" class="headerlink" title="2.3 redo与bin区别"></a>2.3 redo与bin区别</h2><ul><li><strong>写入时机不同</strong>。 binlog只有在事务提交完成后才会写入，所以一个事务中，只会存在一次写。而redo log在事务进行中会不断的写入到重做日志文件中</li><li><strong>记录内容不同</strong>。 无论binlog按照哪种方式进行存储，其存储的都是对数据的一个变更， 可以理解为我们平时写的一个sql。而redo log记录的则是对于数据页的物理修改</li><li><strong>产生地点不同。</strong> redo是在InnoDb存储引擎层产生的，而bin是在数据库上层产生的， 其bin日志所有的存储引擎都会产生</li></ul><h1 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3. undo log"></a>3. undo log</h1><blockquote><p> 回滚日志。<strong>存储的是逻辑方面的日志</strong>。</p><p>可以用来实现事务的<strong>原子性</strong>。</p></blockquote><p>undo log日志存放在数据库内部一个特殊的段中，这个段就是undo段。undo段存储在共享表空间中。</p><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><p>undo log主要有两个作用：</p><ul><li><strong>回滚</strong>:  如果由于某种异常需要回滚或者用户主动发起回滚， 此时通过undo log就能实现。 注意， 由于undo log 是逻辑日志，所以在回滚的时候也只是逻辑的恢复数据， 但是数据结构和页本身在回滚之后， 可能和之前的不一定相同。</li><li><strong>MVVC</strong>: 多版本并发控制。在进行快照读的时候，如果记录此时被其他事务占用， 那么此时就直接通过undo log读取之前的行版本信息， 从而非锁定读。</li></ul><h2 id="3-2-写入策略"><a href="#3-2-写入策略" class="headerlink" title="3.2 写入策略"></a>3.2 写入策略</h2><p>undo log 为了保证更好的并发以及多版本控制，所以其存储不应该因为物理存储变化而变化，所以undo log采用了逻辑存储的方式，来保存这些数据的历史版本。所以在数据库中， 是可能存在一行数据的多个历史版本的， 这些数据在InnoDb看来，和其他的数据没有什么区别，所以，同样的，也会写自己的redo log，通过redo log来保证自己的原子性。</p><p>对于undo log, 分为两种：</p><ul><li>Insert Undo: 对于插入操作，由于其并没有历史版本，所以此处并不需要MVCC，记录undo的目的仅仅是为了回滚</li><li>Update Undo: 对于更新操作，MVCC需要存储多个历史版本，所以需要存储的信息就比insert类型的多。</li></ul><h2 id="3-3-undo与redo区别"><a href="#3-3-undo与redo区别" class="headerlink" title="3.3 undo与redo区别"></a>3.3 undo与redo区别</h2><ul><li>在对数据库进行修改时, 不仅会产生redo log, 还会产生一定的undo log</li><li>redo log是存储在文件里的, 但是undo log是存储在共享表空间一个特殊的段segment内的(undo segment)</li></ul><p>参考资料：</p><ol><li>《MySQL技术内幕》</li><li><a href="http://mysql.taobao.org/monthly/2015/04/01/">http://mysql.taobao.org/monthly/2015/04/01/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客工具搭建</title>
      <link href="/posts/28646/"/>
      <url>/posts/28646/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>记录一下本人VPS上搭建的几个专门为个人博客使用的一些工具软件，为了方便， 都是使用docker进行部署，并且为了便于保存，使用<code>docker-compose</code>方式启动，方便后续修改。</p><p>因为vps的规格较低，所以在挑选工具时，会尽量偏向于内存占用小的。</p><p>下面介绍一下用到的一些工具， 都采用docker自建服务。</p><h1 id="公用数据库搭建"><a href="#公用数据库搭建" class="headerlink" title="公用数据库搭建"></a>公用数据库搭建</h1><p>为了尽量减小资源，专门部署了一个mysql实例（docker方式），各个需要数据库的服务都会建立一个自己的库，然后都连接到这个实例上。</p><p>mysql实例的<code>docker-compose.yml</code>文件如下， 在这之前，需要创建一个docker网络，然后将所有需要连接到该数据库的docker服务都连接到该网络上即可，具体连接方法可参考下面的umami或waline中的配置。</p><p>此处创建的docker网络名为<code>db-net</code>，创建命令：<code>docker network create db-net</code></p><p>mysql的<code>docker-compose.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">mariadb:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mariadb:10.5.9</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">mariadb</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=******</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_USER=root</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=******</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="attr">db-net:</span></span><br><span class="line">                <span class="attr">aliases:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">mariadb</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/var/lib/mysql</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据统计umami搭建"><a href="#数据统计umami搭建" class="headerlink" title="数据统计umami搭建"></a>数据统计umami搭建</h1><p>一个个人站点数据统计工具， 界面看上去比较清新简洁。</p><p>需要先连接到mysql上先创建一个数据库 umami，登录到数据库， 然后执行如下命令：</p><p><code>create database umami default character set utf8mb4 collate utf8mb4_unicode_ci;</code></p><p><code>docker-compose.yml</code>文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">umami:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/mikecao/umami:mysql-latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">umami</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;12000:3000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">        <span class="attr">db-net:</span></span><br><span class="line">            <span class="attr">aliases:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">umami</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DATABASE_URL:</span> <span class="string">mysql://root:*****@mariadb:3306/umami</span></span><br><span class="line">      <span class="attr">DATABASE_TYPE:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">HASH_SALT:</span> <span class="string">******</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>在hexo博客根目录下的scripts目录，找到一个index.js文件（如果没有就自己创建一个)，在里面加上如下一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">injector</span>.<span class="title function_">register</span>(<span class="string">&#x27;head_end&#x27;</span>,<span class="string">&#x27;&lt;script async defer data-website-id=&quot;****&quot; src=&quot;*******&quot;&gt;&lt;/script&gt;&#x27;</span>,<span class="string">&#x27;default&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中 script 内容是从umami上获取的跟踪代码</p><p><img src="https://pic.7billapp.com/63df1906b5219.png"></p><h1 id="评论系统waline搭建"><a href="#评论系统waline搭建" class="headerlink" title="评论系统waline搭建"></a>评论系统waline搭建</h1><p>一个博客的评论系统。可以自己部署。</p><p>需要先连接到mysql上先创建一个数据库 waline，登录到数据库， 然后执行如下命令：</p><p><code>create database waline default character set utf8mb4 collate utf8mb4_unicode_ci;</code></p><p><code>docker-compose.yml</code>文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">db-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">waline:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">waline</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lizheming/waline:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8360</span><span class="string">:8360</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/app/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">            <span class="attr">db-net:</span></span><br><span class="line">                <span class="attr">aliases:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">waline</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">mariadb</span></span><br><span class="line">      <span class="attr">MYSQL_PORT:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">waline</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">******</span></span><br><span class="line">      <span class="attr">JWT_TOKEN:</span> <span class="string">&#x27;******&#x27;</span></span><br><span class="line">      <span class="attr">SITE_NAME:</span> <span class="string">&#x27;******&#x27;</span></span><br><span class="line">      <span class="attr">SITE_URL:</span> <span class="string">&#x27;*******&#x27;</span></span><br><span class="line">      <span class="attr">SECURE_DOMAINS:</span> <span class="string">&#x27;*********&#x27;</span></span><br><span class="line">      <span class="attr">AUTHOR_EMAIL:</span> <span class="string">&#x27;**********&#x27;</span></span><br><span class="line">      <span class="attr">IPQPS:</span> <span class="number">10</span> <span class="comment">#基于 IP 的评论发布频率限制,单位s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这上面的一些配置可以自己查看文档， 传送门 <a href="https://waline.js.org/">https://waline.js.org/</a></p><p>上面的关键配置是SECURE_DOMAINS， 需要加上自己博客的域名， 否则你的博客将无法访问。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> selfhost </tag>
            
            <tag> 博客 </tag>
            
            <tag> umami </tag>
            
            <tag> waline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人笔记软件的选择</title>
      <link href="/posts/18945/"/>
      <url>/posts/18945/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的目的， 主要是为了记录一下自己使用的笔记软件的过程以及最终选择（当然也只是目前的选择， 后续会不会变就不清楚了）， 给其他同样有此问题的人一个参考。</p><p>先说一下本人选择笔记软件的一些原则：</p><ul><li>数据要掌握在自己手上，放在云上的我感觉都不安全， 因为开发该软件的公司哪天收费或倒闭了， 你自己的数据就没了或者不好弄出来</li><li>要多端都能使用</li><li>方便同步</li><li>最好能自己部署</li></ul><h1 id="为知笔记"><a href="#为知笔记" class="headerlink" title="为知笔记"></a>为知笔记</h1><p>推荐星级：★</p><p>这是我个人早起用的时间比较长的一个笔记软件， 是一个传统的笔记软件， 使用过程中陆陆续续出现过一些问题， 后来为知强制收费， 加上对其富文本格式的担心，花了一天的时间把数据都迁移出来了。</p><p>为知笔记有一个官方的docker镜像， 可以自己部署使用， 但是有些功能还是需要连接到官方使用， 所以不是很友好。</p><p>最终弃之。</p><h1 id="typora-坚果云"><a href="#typora-坚果云" class="headerlink" title="typora + 坚果云"></a>typora + 坚果云</h1><p>推荐星级：★★★</p><p>在不使用为知笔记之后， 我一直在寻找替代品， 包括印象笔记，有道笔记等， 但都不符合预期， 且不符合数据掌握在自己手中的原则。在这个过程中，了解到了markdown这一文本格式， 就迅速的爱上他了。</p><p>再结合数据同步与备份， 便使用了 <code>typora + 坚果云</code>这一组合。这个组合其实还蛮好用的， 但是有三个致命缺点：</p><ul><li>不能全文搜索， 特别是笔记一多，有时想找个之前记录的东西又不记得文件名， 很费事</li><li>目录树的组织不够清晰明了</li><li>坚果云的免费额度较低， 不过只作为笔记同步的话一般够用了</li></ul><p>当然，这个组合我目前还在轻微使用， 但是很少用来记录笔记了。</p><h1 id="confluence"><a href="#confluence" class="headerlink" title="confluence"></a>confluence</h1><p>推荐星级：★★★</p><p>这是在公司使用的一个wiki系统， 感觉挺好用的， 然后网上找了一下， 发现有它的docker镜像， 然后就在自己的VPS上部署用了一下， 确实还可以。</p><p>这个是完全基于web的应用， 所以只要有浏览器， 都能用， 不用考虑跨平台的问题， 且结合其他插件， 功能还是很强的。</p><p>但是也有几个不尽如人意的地方：</p><ul><li>资源占用较大。 咱的VPS是一个小水管， 属实有点耗不起</li><li>对markdown的支持不是很全面。 有些操作还是需要手动点击相应的按钮才能实现</li></ul><p>总体来说， 这个还是比较好用的。本人也有一篇使用docker介绍其安装过程的[博客][<a href="https://acchw.top/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/docker%E5%AE%89%E8%A3%85confluence.html]%E3%80%82">https://acchw.top/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/docker%E5%AE%89%E8%A3%85confluence.html]。</a></p><h1 id="notion"><a href="#notion" class="headerlink" title="notion"></a>notion</h1><p>推荐星级：★★★</p><p>说实话， 这个软件我是非常喜欢的， 不管是文字输入还是排版等方面， 都很舒适， 特别是其<code>database</code>功能，真的很强大。</p><p>但是其有一个致命缺点， 其服务器在国外， 虽然现在国内在不挂梯子的情况下也能访问， 但是网速还是比较慢， 而且谁也不知道哪天就被ban了。</p><p>同时也不支持自建服务， 所以最终还是放弃了。 但是这个软件给我带来的结果就是， 我后面寻找的软件很多都是以它为标准的， 或者说就是寻找它的替代品。 </p><p>github上有个非常火的项目<a href="https://github.com/AppFlowy-IO/AppFlowy">AppFlowy</a> 就是它的一个替代品， 但是现在还很不完善， 所以暂时放弃。</p><p>如果你对上面这些缺点不是很在乎， 那么notion将是一个很好的选择。</p><h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p>推荐星级：★</p><p>支持自建服务。但是其登录选项不好弄， 个人弄了半天才成功， 而且使用之后， 感觉也不是很惊艳， 所以试用了一下就放弃了。</p><h1 id="trilium"><a href="#trilium" class="headerlink" title="trilium"></a>trilium</h1><p>推荐星级：★</p><p>支持自建服务。 说实话， 它的颜值确实不敢恭维，这也是我放弃他的最大原因，所以在试用了一下也放弃了。</p><p><img src="https://pic.7billapp.com/63df190795465.png"></p><h1 id="思源笔记"><a href="#思源笔记" class="headerlink" title="思源笔记"></a>思源笔记</h1><p>推荐星级：★★★★★</p><p>这是我目前在用的主力软件。和notion比较像，功能还是很强大的。</p><p>对mardown的支持也非常好， 基本上我平时用的markdown语法都支持， 也支持将文章导出为markdown格式。</p><p>搜索功能也很强大， 总之，比较完美的符合了我现在的一切要求。</p><p>支持docker伺服，所以我直接部署在VPS上了， 只需要做好VPS的数据备份即可。</p><p>下面这张是我用的集市里面的notion主题， 颜值一下子就上去了。</p><p><img src="https://pic.7billapp.com/63df1907eee08.png"></p><p>贴一个<code>docker-compose.yml</code>文件，内容如下， 使用<code>docker-compose up -d</code>命令直接启动即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">siyuan:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">b3log/siyuan</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">siyuan</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/siyuan/workspace/</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">--workspace=/siyuan/workspace/</span>]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6806</span><span class="string">:6806</span></span><br></pre></td></tr></table></figure><p>配置nginx转发的时候， 需要注意一下， &#x2F;ws的也需要配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name 你的域名</span><br><span class="line">    charset utf-8;</span><br><span class="line">    ssl_certificate   /etc/nginx/cert/域名pem文件;</span><br><span class="line">    ssl_certificate_key   /etc/nginx/cert/域名key文件;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:6806;</span><br><span class="line">    &#125;</span><br><span class="line">    location /ws &#123;</span><br><span class="line">        proxy_pass http://localhost:6806;</span><br><span class="line">        proxy_read_timeout 60s;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &#x27;Upgrade&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> selfhost </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码分析</title>
      <link href="/posts/42939/"/>
      <url>/posts/42939/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap的实现机制是一直在变化的， 其中8的变化较大， 下面分别说明一下在Java7和Java8中他们的实现机制。</p><h2 id="Java-7-实现原理"><a href="#Java-7-实现原理" class="headerlink" title="Java 7 实现原理"></a>Java 7 实现原理</h2><p>主要是基于<strong>分离锁</strong>来实现的。这样做的目的是， 在进行并发操作的时候， 只需要锁住相应的Segment, 而不需要去锁住整个数据， 提高并发性能。</p><p>存储数据的是一个个的Segment，Segment是继承自ReentrantLock，所以它本质上就是一个锁。 </p><p>每个Segment内部都有一个HashEntry的数组， 这个HashEntry数组存储方式和HashMap内部的table数组类似， 哈希相同的元素也是以链表形式存储。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>在并发的时候，get操作只要能保证可见性即可， 所以没有同步操作。</p><ol><li>定位元素所属的segment</li><li>利用jdk提供的Unsafe方法保证以可见性的方式获取元素，<code>UNSAFE.getObjectVolatile()</code></li></ol><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol><li>利用<code>UNSAFE.getObject()</code> 方法获取元素所属的segment</li><li>利用所属的segment获取可重入锁，从而将该segment锁住， 防止其他的线程进行并发写</li><li>会有一个无线循环， 在该循环内部， 会确定该元素的key是否在HashEntry数组中， 从而决定是进行插入还是更新。</li></ol><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>由于需要考虑并发， 计算总容量的时候， 如果锁住整个数据，会导致性能很差。所以ConcurrentHashMap在此处使用了重试机制。</p><p>在进行size操作的时候， 通过重试机制（默认2次）获取值，如果重试的时候没有发生变化， 则直接返回旧值， 如果发生了变化，则还是要通过获取锁来进行计算。</p><h2 id="Java-8-实现原理"><a href="#Java-8-实现原理" class="headerlink" title="Java 8 实现原理"></a>Java 8 实现原理</h2><p>和HashMap类似，其内部存储数据的结构是也是一个大的桶数组<code>Node[]</code>， 数组节点是链表或者是红黑树。其数组定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>总结几点：</p><ol><li>内部虽仍然有Segment的定义, 但是只是为了保证序列化的兼容性， 并没有任何用处</li><li>Node中的value和next都是用volatile来修饰， 保证变量的可见性</li><li>大量使用CAS操作， 可以有效减少锁的使用</li></ol><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p><img src="https://pic.7billapp.com/63df190bcaca4.png"></p><p>对上面源码几处关键处进行一下说明：</p><ol><li>当数组为空的时候进行初始化， 说明初始化的调用时机是第一次put的时候， 和HashMap类似</li><li>定位当前数组下标处是否存在节点， 若不存在，则利用CAS尝试写入， 如果失败则自旋保证成功，因为<strong>此处是使用CAS进行写入</strong>， 所以是不需要加锁的。<br>定位索引的方法（与HashMap一样）： <code>i = (n - 1) &amp; hash</code></li><li>如果检测到当前正在扩容， 则帮助其进行扩容</li><li>当以上条件都不满足时， 说明此处已经存在节点， <strong>则对该节点上锁， 此处直接使用synchronized进行加锁， 且加锁的对象只是该节点而不是整个数据</strong></li><li>获取该节点的锁之后， 判断该节点类型， 若是链表，则遍历链表插入</li><li>若是红黑树，则遍历红黑树插入</li><li>判断是否要将链表转换为红黑树，临界值和HashMap一样也是8</li></ol><p>其整体流程与HashMap较为相似， 就其中几个关键不同之处进行说明：</p><ol><li>当插入一个新节点的时候， HashMap是直接插入，而ConcurrentHashMap使用CAS进行无锁插入</li><li>ConcurrentHashMap多了一个状态判断， 当发现Map正在扩容，则调用<code>helpTransfer()</code>帮助其进行扩容， 以加快扩容速度。</li><li>当索引处已经存在节点， 此时往该索引处添加元素时， ConcurrentHashMap 首先对该节点加锁， 在获取到该节点的锁之后再进行后续操作， 这样既能保证插入操作的线程安全性，同时因为只对该节点加锁，没有对整个数据加锁， 从而减少锁竞争， 提高效率。</li></ol><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>get方法没有加锁， 而是利用CAS来进行处理， 可以提高查询效率。</p><p>下面是源码对应的关键几步进行分析：</p><ol><li>利用CAS获取数组列表下标处的节点</li><li>如果当前节点（链表头结点）刚好是要找的节点， 则直接返回当前节点值</li><li>如果eh&lt;0, 表示当前正在扩容或者该位置是红黑树， 调用find查找</li><li>以上条件都不满足， 表明该位置是链表， 遍历链表进行查找</li></ol><h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><p>其调用的是<code>sumCount()</code>方法，采用<code>分而冶之</code>进行计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CAS简单介绍"><a href="#CAS简单介绍" class="headerlink" title="CAS简单介绍"></a>CAS简单介绍</h2><p>上面章节中多次提到cas，下面简单介绍一下。</p><p>Compare and Swap， 比较并交换， 包含了两个动作。在现代CPU中，提供了一个<code>CAH</code>指令，保证这两个动作的原子性。</p><p>CAS的核心有三个参数：</p><ul><li>V 内存位置</li><li>A 旧的预期值</li><li>B 要修改的值，也就是新值</li></ul><p>首先要明白， 每个线程都会有一个自己的内存空间，在进行操作时， 首先会将主内存的值copy一份到自己的线程内存空间， 然后再刷新到主内存。</p><p>举一个简单例子， 比如<code>a+1</code> 这个操作，此时a的值时0， 当有thread1、thread2两个线程都执行的时候， 其情况是怎么样的？</p><ol><li>thread1、thread2将主内存中的a的值copy到自己的线程内存空间，此时对于这两个线程而言，他们的 预期值 A 都是0， 要修改的值 B 都是1</li><li>然后就会执行 比较并交换的动作， thread1将a的旧预期值与主内存中a的值进行比较， 此时发现两者相等，就会直接将要修改的值a&#x3D;1刷新到主内存， 此时主内存中a的值就变成了1</li><li>此时thread2在提交的时候，发现a的预期值0与主内存中a的值1不相等， 就会放弃本次提交。提交失败之后，会继续重复执行步骤1的操作， 直到成功。</li></ol><p>使用<code>UnSafe</code>操作cas是不推荐的， 在Java9之后， 提供了<code>VarHandle</code>来进行CAS操作， 一般流程都是首先获取变量句柄，然后调用其cas方法。</p><p>CAS中常见的一个<code>A-B-A</code>问题，由于CAS是在更新时比较新值与旧值，如果刚好新值从A变为B再改为A， 此时这个比较实际上就无效了， Java提供了一个<code>AtomicStampedReference</code>类， 为引用建立版本号， 每次变更值的时候， 版本号都会发生变化， 从而确定该值是否真的改变。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析</title>
      <link href="/posts/41417/"/>
      <url>/posts/41417/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>HashMap是由数组<code>Node&lt;K,V&gt;[] table</code> 和链表（或者树）组成的一个复合结构。</p><p>数组被分成一个个的桶（buket），通过下面的这个算法决定元素在桶中的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为数组长度，hash为key的哈希值</span></span><br><span class="line">p = tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p>若p相同，则以链表形式存储。当链表长度超过阈值（TREEIFY_THRESHOLD&#x3D;8）时，则将链表<br>转换为红黑树。</p><p><img src="https://pic.7billapp.com/63df190c9b1f9.jpg"></p><p>此处为什么需要这么做?</p><p>主要是基于查询的效率考虑。链表查询元素的时间复杂度为O(n)，随着链表长度的增大，查询时间也会递增。而红黑树的时间复杂度为O(logn)，此处是一个<code>以空间换时间</code>的典型案例。</p><p>HashMap中几个特殊值说明：</p><ul><li><strong>initialCapacity</strong>：HashMap初始容量，默认为16</li><li><strong>loadFactor</strong>：负载因子，默认0.75</li><li><strong>threshold</strong>：键值对数量的最大值（不是table数组的长度），超过这个值，则需要扩容，会变为原先值的两倍</li><li><strong>TREEIFY_THRESHOLD</strong>：链表转换红黑树阈值，默认为8， 当超过该值时， 链表就会转换为红黑树</li></ul><h2 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h2><p>key本身的哈希值不是通过hashCode得到的， 而是HashMap自己实现的一个算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object kye)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现了<strong>将高位数据移位到低位进行异或运算</strong>，是因为有些数据计算出来的哈希值差异主要就在高位，而其哈希寻址是忽略容量以上的高位的，所以通过这样处理， 就能有效避免上述情况的哈希碰撞。现实中，构造哈希冲突并不是很难，恶意代码就有可能会通过该手段造成大量的哈希碰撞，造成服务器CPU大量占用。</p><h2 id="插入流程"><a href="#插入流程" class="headerlink" title="插入流程"></a>插入流程</h2><p>首先计算key的哈希值， 然后调用putVal()函数。</p><p>下图是putval()函数的源码， 就其中的关键几步进行说明</p><p><img src="https://pic.7billapp.com/63df190d2060b.png"></p><ol><li><p>当数组为空，则调用<code>resize()</code>函数进行数组的初始化操作。该处代码表明HashMap中数组的初始化并不是在new的时候，而是在第一次put的时候。</p></li><li><p>使用<code>(n - 1) &amp; hash</code>计算数组下标，若当前项不存在，则调用<code>newNode()</code>函数在数组下标处新建一个节点。</p></li><li><p>当以上条件都不满足， <strong>说明该处索引已经存在节点，此时就该进行链表或树操作了</strong>。3、4、5是对应不同类型的。其中3是直接判断当前节点， 4则是树节点， 5是链表。 此处需要判断该节点处的key和待存入数据的key是否相等。判断相等的条件如下（之间是且的关系）：</p><ul><li>将要存入数据key的哈希值和数组下标处节点的哈希值相等</li><li>将要存入数据的key和数组下标处节点的key相等（此处相等是内存地址相等或者equals比较相等都可以）</li></ul></li><li><p>该代码表明该处数组下标处的节点是树节点， 所以此时调用<code>putTreeVal()</code>函数插入树节点。</p></li><li><p>当3和4都不满足时，则表明该处是一个链表，则进行链表的遍历。</p></li><li><p>若一直能遍历到链表尾部，则在链表尾部新建一个节点储存当前待存入数据。<strong>然后判断是否要将链表（TREEIFY_THRESHOLD）转化为红黑树</strong>， 若是则调用<code>treeifyBin()</code>函数进行链表的树化。</p></li><li><p>若链表中某个节点的key与待存入数据的key相等（与第3步的判断条件一样），则退出遍历。</p></li><li><p>判断之前是否已经存在key值相同的节点，若是此时根据onlyIfAbsent参数来决定是否将之前节点的值更新为本次要插入的值（实际上map默认的put操作该值为true,表明是覆盖插入）</p></li><li><p>判断是否要进行扩容操作， 若是则调用<code>resize()</code>函数进行扩容。注意此处的++resize操作可能导致线程不安全。</p></li></ol><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>resize()函数。该函数有两个用途：</p><ul><li>创建初始的存储数组</li><li>容量不足的时候， 进行扩容</li></ul><p>下面是resize函数关键几步分析：</p><p><img src="https://pic.7billapp.com/63df190d891f2.png"></p><p>基本流程：</p><ol><li>当扩容之前的数组长度大于最大值时，直接返回未扩容之前数组（也就是不进行扩容），<strong>此处表明当HashMap容量达到最大值时（Integer.MAX_VALUE)，继续插入新值虽然不会报错， 但实际上并没有生效， 返回的仍是原数组。</strong></li><li>当元素个数大于阈值（默认初始容量16 * 负载因子0.75 &#x3D; 12）时进行扩容，将新数组长度和阈值都扩大为原先2倍</li><li>能进入该分支表明是第一次初始化，设置数组容量大小（指定值或者默认值）和阈值大小</li><li>重新初始化一个新的数组，数组长度是原先的2倍</li><li><strong>开始进行重哈希</strong>，<strong>将原数组项的数据重新放入新的数组项里面，这是扩容时消耗时间最长的地方</strong>。此处需要遍历原数组， 具体步骤如下：<ol><li>6处表明当前下标处没有值，则直接将元素插入到新数组项中</li><li>7处表明当前数组项是一个红黑树，进行红黑树的重新赋值</li><li>8处，当以上两种情况都不符合，肯定是链表节点，则进行链表的重哈希，需要遍历链表</li></ol></li></ol><p><strong>链表节点的重哈希</strong> 有必要说明一下，此处设计的比较巧妙,具体描述可见文章：<a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p><p>JDK中解释resize函数的说明大意如下：</p><blockquote><p>当进行扩容时，因为我们每次扩容容量都是之前的2倍，任意元素在新数组中要么是原先的位置，要么是原位置移动2次幂的位置。</p></blockquote><p>其具体原理是利用0与0或者1进行&amp;运算结果都是0，这样在进行重hash的时候，<strong>不需要重新计算Hash值</strong>，只需要判断原先的Hash值新增的那一位是0还是1，若为0，则原先位置，若为1，则索引变为“oldCap+原索引”。</p><p>这地方有几点需要注意：</p><ol><li>判断索引是否改变用的是 <strong>hash &amp; oldCap</strong>，此处与计算索引值**(n - 1) &amp; hash**需要区分开来</li></ol><h2 id="链表转化红黑树"><a href="#链表转化红黑树" class="headerlink" title="链表转化红黑树"></a>链表转化红黑树</h2><p>treeifyBin()函数。在链表长度超过8的时候，使用该函数将链表转化为红黑树。</p><p>其主要思路如下：</p><ol><li>当整个数组桶的长度小于64时，此时并不会进行树化操作，只是进行扩容。注意，在进行扩容的时候，链表的长度有可能会变短</li><li>将链表中的节点转化为树节点TreeNode，形成一个新的链表</li><li>将新链表节点赋值给给定的数组项</li><li>调用TreeNode的treefify()方法将该处的链表转化为红黑树，该函数大致步骤如下：<ol><li>插入树节点元素，具体可以参考二叉搜索树的插入操作。在进行插入的时候，比较key的hash值来决定插入的方向。</li><li>插入完成之后开始调整红黑树，使其符合红黑树的特性</li></ol></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>getNode()函数。提供常数时间复杂度的查找效率。</p><ol><li><p>根据<code>(n - 1) &amp; hash</code>计算得到该key所在的桶bucket，若桶不存在或者数组table为空，则直接返回null，根据这一点我们可以知道HashMap取元素的方法get和判断元素是否存在的<code>contanins</code>方法的时间复杂度都是O(1)</p></li><li><p>当桶存在时，首先判断该桶上第一个节点是否就是要找的节点，若是直接返回该节点值</p></li><li><p>若不是，判断节点类型，若是红黑树，则遍历红黑树查找，若是链表，则遍历链表查找</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java大图片压缩与裁剪时防止oom</title>
      <link href="/posts/59491/"/>
      <url>/posts/59491/</url>
      
        <content type="html"><![CDATA[<p>常规使用java进行图片裁剪或压缩的时候， 比如使用<code>ImageIO.read()</code>读取图片信息的时候， 或者使用<code>Thumb nails</code>框架进行压缩时， 都会调用<code>DataBufferByte</code>类的下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataBuffe</span><br><span class="line"><span class="title function_">rByte</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> numBanks)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(STABLE, TYPE_BYTE, size, numBanks);</span><br><span class="line">        bankdata = <span class="keyword">new</span> <span class="title class_">byte</span>[numBanks][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; numBanks; i++) &#123;</span><br><span class="line">            <span class="comment">// 构造数组</span></span><br><span class="line">            bankdata[i] = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">        data = bankdata[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图片像素很大时， size的值会很大， 此时构造这个数据就有可能会出现oom，比如当一张6.4M的图片， 宽高是5472*7296， size的值是114M。</p><p>基于此， 可以基于采样的方式进行， 不需要引用任何第三方库， 具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] resize(<span class="type">byte</span>[] srcFileData, <span class="type">int</span> width, <span class="type">int</span> height) &#123;</span><br><span class="line">    <span class="type">ImageInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ImageReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = ImageIO.createImageInputStream(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(srcFileData));</span><br><span class="line">        Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(input);</span><br><span class="line">        reader = readers.next();</span><br><span class="line">        reader.setInput(input);</span><br><span class="line">        <span class="comment">//原始图像的长和宽</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">srcWidth</span> <span class="operator">=</span> reader.getWidth(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">srcHeight</span> <span class="operator">=</span> reader.getHeight(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ImageReadParam</span> <span class="variable">param</span> <span class="operator">=</span> reader.getDefaultReadParam();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sampling</span> <span class="operator">=</span> Math.min(srcWidth/width, srcHeight/height);</span><br><span class="line">        <span class="comment">//采样压缩, 其中sampling的值表示每隔多少个像素点取一个像素</span></span><br><span class="line">        param.setSourceSubsampling(sampling, sampling, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        param.setSourceRegion(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, srcWidth, srcHeight));</span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> reader.read(<span class="number">0</span>, param);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        ImageIO.write(bufferedImage, <span class="string">&quot;jpg&quot;</span>, outputStream);</span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.close();</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>)&#123;</span><br><span class="line">                reader.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arthas中如何获取Bean</title>
      <link href="/posts/28416/"/>
      <url>/posts/28416/</url>
      
        <content type="html"><![CDATA[<p>现在大部分应用都是通过Spring来管理对象， 在使用arthas分析线上问题时， 如何获取Spring中已经注入到容器中的Bean， 主要是使用tt命令。</p><p>首先执行如下命令，等待输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</span><br></pre></td></tr></table></figure><p>假设要搜索的类名为<code>com.example.DemoService</code>， 注意此处需要使用类的全限定名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;com.example.DemoService&quot;).getTargetSource().target&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> arthas </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arthas的一些使用技巧</title>
      <link href="/posts/28416/"/>
      <url>/posts/28416/</url>
      
        <content type="html"><![CDATA[<h1 id="arthas获取spring中的bean"><a href="#arthas获取spring中的bean" class="headerlink" title="arthas获取spring中的bean"></a>arthas获取spring中的bean</h1><p>现在大部分应用都是通过Spring来管理对象， 在使用arthas分析线上问题时， 如何获取Spring中已经注入到容器中的Bean， 主要是使用tt命令。</p><p>首先执行如下命令，等待输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</span><br></pre></td></tr></table></figure><p>假设要搜索的类名为<code>com.example.DemoService</code>， 注意此处需要使用类的全限定名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;com.example.DemoService&quot;).getTargetSource().target&#x27;</span><br></pre></td></tr></table></figure><h1 id="arthas获取http请求的入参和出参"><a href="#arthas获取http请求的入参和出参" class="headerlink" title="arthas获取http请求的入参和出参"></a>arthas获取http请求的入参和出参</h1><p>有时我们需要线上跟踪某个请求的入参和出参， 此时可以使用arthas的watch命令。</p><p>基于spring的工程，所有请求都会走RequestMappingHandlerAdapter的invokeHandlerMethod方法， 所以跟踪此方法。</p><p>有两点说明一下：</p><ul><li>此处只打印了request，所以是params[0] </li><li>使用uri来过滤请求地址</li></ul><p>当然能看到的信息还有很多， 具体可以参考watch命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod &#x27;params[0]&#x27; &#x27;params[0].getRequestURI().contains(&quot;/ai/img&quot;)&#x27; -x 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> arthas </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中文件权限说明</title>
      <link href="/posts/47908/"/>
      <url>/posts/47908/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Linux下的文件权限包括读， 写， 执行， 英文简写分别是 <code>r</code>, <code>w</code>, <code>x</code></li><li>文件权限包含三个方面： 拥有者， 用户组， 其他组。每个文件可分别对这三个方面设置不同的rwx权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li></ul><h1 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h1><p><code>ls -l</code></p><p>输出格式如下：</p><p><code>-rw-r--r-- 1 root root 25934 Jun 26 10:35 X120</code></p><p>其中第一列除了第一个表示文件类型外， 剩下9个则表示该文件在上面三个粒度下的权限，具体信息</p><ul><li>2,3,4列表示文件所有者权限</li><li>5,6,7列表示该文件所属用户组的权限</li><li>7,8,9列表示其他组的权限</li></ul><h1 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h1><p><code>chmod</code>命令， 其参数如下：</p><ul><li>-R  以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更</li></ul><p>下面只介绍一下使用数字来表示的权限使用方法。</p><p>基本规定如下：</p><ul><li>4 读r</li><li>2 写w</li><li>1 执行x</li></ul><p>其他的权限组合用这几个进行相加就行， 示例如下：</p><ul><li>7  可读+可写+可执行 rwx  （4+2+1&#x3D;7）</li><li>6 可读+可写 rw-（4+2&#x3D;6）</li><li>5 可读+可执行 r-x（4+1&#x3D;5)</li></ul><p>在使用数字进行设置权限的时候， 其语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [可选项] &lt;abc&gt; file</span><br></pre></td></tr></table></figure><p>其三位数字分别表示拥有者，群组， 其他组的权限详情，也就是a代表拥有者权限，b代表群组权限， c代表其他权限。</p><p>例如： <code>chmod 777 file</code>则表示所有用户都有读写和执行的权限（当然这是比较危险的）</p><p>下面列举一下常见的权限表现形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw------- (600)    只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700)    只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)    所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure><h1 id="更改文件所有者"><a href="#更改文件所有者" class="headerlink" title="更改文件所有者"></a>更改文件所有者</h1><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-hvR] user[:group] file...</span><br></pre></td></tr></table></figure><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li><li>-h :修复符号链接</li><li><strong>-R : 处理指定目录以及其子目录下的所有文件</strong></li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件的所有者设置为root</span></span><br><span class="line">chown root file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件拥有者设为rob, 组设置为robGroup</span></span><br><span class="line">chown rob:robGroup file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅改变文件的组设置为512（组ID）， 不改变所有者</span></span><br><span class="line">chown :512 file</span><br></pre></td></tr></table></figure><p>顺便说一下查看用户组ID的命令：</p><p><code>id</code></p><p><code>cat /etc/password</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell语法参考</title>
      <link href="/posts/41179/"/>
      <url>/posts/41179/</url>
      
        <content type="html"><![CDATA[<h1 id="几点注意事项"><a href="#几点注意事项" class="headerlink" title="几点注意事项"></a>几点注意事项</h1><ul><li><p>一次执行多条命令,可以有如下三种方法, 其区别如下:</p><ul><li>分号： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行</li><li>&amp;&amp;  ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的</li><li>||   ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的</li></ul></li><li><p>设置shell脚本遇到错误时自动退出, 不执行后续命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash -e 或者 <span class="built_in">set</span> -e</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="特殊符号使用"><a href="#特殊符号使用" class="headerlink" title="特殊符号使用"></a>特殊符号使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 覆写原先的内容</span><br><span class="line">&gt;&gt; 在原先的内容后追加</span><br><span class="line">$? 前一个命令或者函数的返回码, 0表示执行成功</span><br><span class="line">$1 表示第一个参数,$2 表示第二个</span><br><span class="line">$# 命令行参数的个数</span><br><span class="line">$0 当前程序的名称</span><br><span class="line">$* 以&quot;参数1 参数2 ...&quot;的形式保存所有参数</span><br><span class="line">$ 本程序进程PID</span><br><span class="line">$! 上一个命令的PID</span><br><span class="line">脚本内取得输入命令时的参数:  $n n代表第几个参数</span><br></pre></td></tr></table></figure><h1 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h1><ul><li>&#x2F;dev&#x2F;null  重定向到此文件的数据都会被系统丢掉</li><li>&#x2F;dev&#x2F;tty 自动重定向到一个终端</li></ul><h1 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h1><blockquote><p>注意： 函数的定义要放在使用之前， 否则的话会报错</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">函数定义</span></span><br><span class="line">function funname() &#123;</span><br><span class="line">    echo &quot;第n个参数为$&#123;n&#125;&quot;</span><br><span class="line">    action</span><br><span class="line">    retun</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">函数使用</span></span><br><span class="line">funname param1 param2</span><br></pre></td></tr></table></figure><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><blockquote><p>一般用于在if条件中，用[]包裹，注意前后空格。 </p><p>同时注意为了防止空情况下导致的语法错误， 变量都加上双引号</p></blockquote><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><ul><li>-ne 不等于则为真</li><li>-eq 等于则为真(用来判断数字）</li><li>-gt 大于则为真</li><li>-ge 大于等于为真</li><li>-lt 小于为真 </li><li>-le 小于等于为真</li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><ul><li>var1 &#x3D; var2 判断两个字符串是否相等</li><li>var1 !&#x3D; var2 判断两个字符串是否不相等   </li><li>-n “$var” 当字符串的长度大于零时为真(要用双引号包括—）</li><li>-z “$var” 当字符串的长度等于零时为真(要用双引号包括—）</li></ul><h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><ul><li>-d  file   检查file是否存在并且是一个目录</li><li>-f   file   检查file是否存在并且是一个文件</li><li>-e  file   检查file是否存在</li></ul><h2 id="逻辑操作运算"><a href="#逻辑操作运算" class="headerlink" title="逻辑操作运算"></a>逻辑操作运算</h2><ul><li>[ condition1 ]  &amp;&amp; [ condition2 ]  与</li><li>[ condition1 ]   || [ condition2 ]   或</li></ul><h1 id="控制语句语法"><a href="#控制语句语法" class="headerlink" title="控制语句语法"></a>控制语句语法</h1><blockquote><p>控制条件condition用[]包起来,或者使用test语句.注意空格</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span>语句:</span></span><br><span class="line">if [ condition ];then</span><br><span class="line">command</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">if-else:</span></span><br><span class="line">if [ condition ];then</span><br><span class="line">command</span><br><span class="line">elif [ condition2 ];then</span><br><span class="line">command</span><br><span class="line">else</span><br><span class="line">command</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">while</span>语句:</span></span><br><span class="line">while [ condition ];do</span><br><span class="line">command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><p><strong>推荐使用 $[] 这种格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.使用 $[]，推荐使用(注意在引用变量的时候需要加$)</span></span><br><span class="line">n1=4</span><br><span class="line">n2=3</span><br><span class="line">n3=$[$n1 * $n2] #输出12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.<span class="built_in">let</span>用法,提供常用运算符,</span></span><br><span class="line">注意: 变量前不需要加$运算符且let之后的表达式不要有空格</span><br><span class="line">no1=4;</span><br><span class="line">no2=5;</span><br><span class="line">let result=no1+no2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.<span class="built_in">expr</span>用法，只识别部分比较简单的运算符</span></span><br><span class="line">result=`expr 3 + 4`</span><br><span class="line">result=`$no1 + 4`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.注意,已上只能用于整数计算,下面这个也可用于浮点计算(使用bc命令)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出2.24</span></span><br><span class="line">echo &quot;4 * 0.56&quot; |bc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出81.0</span></span><br><span class="line">no=54</span><br><span class="line">result=`echo &quot;Sno * 1.5&quot; |bc`</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><blockquote><p>以每一行为单位依次读取文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while read line; do</span><br><span class="line">echo $line</span><br><span class="line">done &lt; /home/db2inst1/temp1.txt</span><br></pre></td></tr></table></figure><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义数组(数组下标从0开始)</span></span><br><span class="line">my_array=(A B &quot;C&quot; D)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个空数组</span></span><br><span class="line">my_array=()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取数组</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;my_array[index]&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给数组某一项赋值(注意此处不需要使用$)</span></span><br><span class="line">my_array[0]=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取数组的长度</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#my_array[@]&#125;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历数组(每一项为具体值)</span></span><br><span class="line">for item in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo $item</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历数组(每一项为数组下标)</span></span><br><span class="line">for  i $&#123;!arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将某条命令执行的结果全赋值给数组</span></span><br><span class="line">my_arr=(`awk &#x27;&#123;print $2&#125;&#x27; file.txt`)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="for循环写法"><a href="#for循环写法" class="headerlink" title="for循环写法"></a>for循环写法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环10次</span></span><br><span class="line">for i in $(seq 1 10)</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式可用于sed, awk,grep等命令.</p><p>注意, sed只能使用基本正则表达式,不能使用扩展的正则表达式,sed在使用时需要使用&#x2F;&#x2F;来包裹</p><h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 基础用法, 匹配含有word的行</span></span><br><span class="line">grep &#x27;word&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. ^word 匹配word在行首的行</span></span><br><span class="line">grep &#x27;^word&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. word$ 匹配word在行尾的行</span></span><br><span class="line">grep &#x27;word$&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. .  匹配除换行符之外的任意一个字符(空格也是一个字符),该处必须有字符存在</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配行中含有at的字符,且at前面有一个字符,如下面第一行,第三行可以匹配,第二行不能匹配,因为at在行首,前面无任何字符</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">This is at dog</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">at a dog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">th hs <span class="built_in">cat</span> fd</span></span><br><span class="line">sed -n &#x27;/.at/p&#x27; file_name </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. * 匹配0个或任意多个前一个正则表达式字符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下全部匹配</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">i ha kg</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kkkkg</span></span><br><span class="line">grep &#x27;k*g&#x27; file_name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. [] 搜索集合字符, []括号内的^表示除[]内的字符之外的所有字符</span></span><br><span class="line">grep &#x27;[0-9]&#x27; file_name # 匹配出现数字的行</span><br><span class="line">grep &#x27;[abc]&#x27; file_name # 匹配出现a或者b或者c的行</span><br><span class="line">grep &#x27;[a-z]&#x27; file_name # 匹配出现小写字母的行</span><br><span class="line">grep &#x27;[A-Z]&#x27; file_name # 匹配出现大写字母的行</span><br><span class="line">grep &#x27;[a-zA-Z0-9]&#x27; file_name # 匹配出现字母或数字的行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7. x\&#123;\&#125; 匹配字符连续出现的次数,注意若是单词需要分别写</span></span><br><span class="line">grep &#x27;m\&#123;2\&#125;&#x27; file_name #匹配字母m连续出现2次的行, 如 hsjmmjs</span><br><span class="line">grep &#x27;m\&#123;2,4\&#125;&#x27; file_name #匹配字母m出现次数在2到4次的文本</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配一个IP地址</span></span><br><span class="line">grep &#x27;[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配形如 <span class="string">&quot;13445676789&quot;</span> 的字符串,开始和结束是双引号,中间是个11位数字</span></span><br><span class="line">grep &#x27;&quot;[0-9]\&#123;11\&#125;&quot;&#x27; file_name</span><br></pre></td></tr></table></figure><h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>grep使用时要加-E参数(好像不加也行?)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. ? 与星号类似,但前面的字符只能出现0次或1次</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bet   匹配</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bt    匹配</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">beet  不匹配</span></span><br><span class="line">grep -E &#x27;be?t&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. + 与星号类似,但前面的字符至少出现1次(注意点号是指当前位置必须有一个字符)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bt  不匹配</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bet 匹配</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">beeet 匹配</span></span><br><span class="line">grep -E &#x27;be+t&#x27; file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.管道符 |, 逻辑或的意思</span></span><br></pre></td></tr></table></figure><h1 id="EOF用法"><a href="#EOF用法" class="headerlink" title="EOF用法"></a>EOF用法</h1><p>将<code>EOF</code>与<code>&lt;&lt;</code>结合使用时，表示后续的输入作为子命令或子Shell的输入，直到遇到EOF为止，再返回到主程序中。</p><p>注意， 在编写代码的时候，<strong>最后一个EOF前面不要有任何符号</strong>，包括空格， 否则会报语法错误，所以一般为了书写美观， 我都是将涉及到EOF操作的封装为一个函数， 然后调用这个函数。</p><p>比如使用lftp命令登录sftp服务器， 然后上传文件，可以使用EOF来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function upload() &#123;</span><br><span class="line">lftp -u $&#123;ftp_user&#125;,$&#123;ftp_pwd&#125; sftp://$&#123;ftp_host&#125;:$&#123;ftp_port&#125; &lt;&lt;EOF</span><br><span class="line">cd $&#123;ftp_remote_path&#125;</span><br><span class="line">put file_name.txt</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令参考</title>
      <link href="/posts/55955/"/>
      <url>/posts/55955/</url>
      
        <content type="html"><![CDATA[<p><strong>当做个人字典使用， 会进行不定期更新！</strong></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>打包与压缩命令。</p><p>常用参数：</p><ul><li>-c  (–create)  建立新的备份文件</li><li>-x (–extract) 从备份文件中还原文件</li><li>-z (–gzip或–ungzip)   通过gzip指令处理备份文件</li><li>-v (–verbose)  输出执行过程中的详细信息</li><li>-f  (–file)  指定备份文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/home文件夹下所有内容打包压缩成home.tar.gz文件</span></span><br><span class="line">tar -czvf home.tar.gz /home</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将home.tar.gz文件解压到当前目录</span></span><br><span class="line">tar -xzvf home.tar.gz</span><br></pre></td></tr></table></figure><h1 id="getops"><a href="#getops" class="headerlink" title="getops"></a>getops</h1><p>该命令可以用来解析命令行参数。</p><p>以下表示获取命令行参数 -d -t的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while getopts &#x27;d:t:&#x27; OPT; do</span><br><span class="line">  case $OPT in</span><br><span class="line">    d)</span><br><span class="line">      echo &quot;d $OPTARG&quot;</span><br><span class="line">      exit 0;;</span><br><span class="line">    t)</span><br><span class="line">      echo &quot;t $OPTARG&quot;;;</span><br><span class="line">    ?)</span><br><span class="line">      echo &quot;no match&quot;</span><br><span class="line">  esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>其中getopt和getopt的区别以及getopt的详细用法示例见：<a href="https://blog.sigoden.com/how-to-use-getopt-to-build-cli/">https://blog.sigoden.com/how-to-use-getopt-to-build-cli/</a></p><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>工作流程: 读入有\n换行符分割的一条记录,然后将该记录按指定的域分隔符划分域(默认的域分隔符是空格符)</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>awk  参数  ‘BEGIN{ commands } pattern  { commands} END{commands}’</p></blockquote><p>参数: -F  指定字段定界符,默认是空格,可以是正则表达式， 注意分隔符直接跟在后面， 不需要任何符号</p><p>pattern: 模式,可以是正则表达式,用来匹配每一行,使用&#x2F;&#x2F;包裹, 如 &#x2F;^tcp&#x2F;表示匹配每一行开头以tcp开始</p><p>BEGIN内指定参数: </p><ul><li>FS 同-F; FS&#x3D;”” 表示以空行切分记录</li></ul><p>特殊参数:</p><ul><li>$0 所有域, $1 第一个域, $2 第二个域,以此类推</li><li>$NF 表示一行中的最后一个字段</li></ul><p>流程控制语法:</p><p><code>if(condition)&#123;&#125; else if(condition)&#123;&#125; else&#123;&#125;</code></p><p>循环语法:</p><p><code>for (i=0; i&lt;3;i++)&#123;&#125;</code></p><h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>有三种方法，下面分别是指定分隔符为逗号时的写法：</p><ol><li>使用 -F 指定，注意其后不需要任何符号， 语法：<code>awk -F, file</code></li><li>使用FS指定，加上-v参数， 语法： <code>awk -v FS=&quot;,&quot; file</code></li><li>在BEGIN内部指定， 语法： <code>awk &#39;BEGIN &#123;FS=&quot;,&quot;&#125;&#39; file</code></li></ol><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><p>length(string)  获取字符串长度(字符数)</p></li><li><p>拼接字符串时不需要使用任何修饰符,直接即可</p></li><li><p>printf() 格式化输出,默认不输出换行符.<br>%s 字符; %d 整数,小数取整直接去除尾数; %.2f 小数,2表示小数点保留两位,最后一位四舍五入<br>printf(“%.2f\n”, 1.3374)  输出1.34</p></li><li><p>split(string,array [,r])  字符串拆分,返回拆分后数组大小string:待拆分的字符串,array:拆分后结果保存的数组,r:分隔符,可选,默认FS值;拆分后的数组下标从1开始,<br><code>for(k in arr)&#123;print arr[k]&#125;</code></p></li><li><p>substr(s,i [,n]) 字符串截取<br>s:待截取字符串;i:索引位置,从1开始;n:要截取的长度.默认截取到字符尾。</p></li><li><p>字符串查找:index(s,t), match(s,r [,a])<br>返回第一次匹配成功的索引位置,从1开始,失败返回0<br>s: 待查找的字符串;t:目标子串<br>r: 查询的正则表达式, a 结果二维数组</p></li><li><p>字符串替换</p><ul><li>sub(r,s[,t]) 替换首次匹配到的子串,返回成功替换子串的数目,r 用于匹配的正则表达式,s 要替换的字符串值,t 目标字符串n,默认$0</li><li>gsub(r,s[,t]) 用法同sub,替换所有匹配到的子串</li><li>gensub(r,s,h[,t])  h: “g”表示全局替换,或是用数字指定子串出现的位置</li></ul></li></ul><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><ul><li>systime() 返回精确到秒的当前时间戳</li><li>mktime(date) 获取指定时间的时间戳,date格式: “YYYY MM DD HH MM SS”</li><li>strftime() 转化时间字符串</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p><strong>中间命令的编写一定要用单引号包裹，不能用双引号</strong></p></li><li><p>当字符串中含有单引号，转义写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此为打印单引号，比较字符串的单引号同理</span></span><br><span class="line">awk &#x27;&#123;print &quot;&#x27;\&#x27;&#x27;&quot;&#125;&#x27; </span><br></pre></td></tr></table></figure></li><li><p>awk中比较在一个范围之内不能用连写方式，如 2&lt;x&lt;7是错误的,应写成 x&gt;2 &amp;&amp; x&lt;7</p></li><li><p>awk 使用外部变量，需要在Action之后定义变量，如下所示使用外部test变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=hhhhfudfhdhf</span><br><span class="line">awk &#x27;&#123;print test&#125;&#x27; test=&quot;$test&quot; filename</span><br></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设一个目录下的文件按照时间进行命名， 如202204011628.tar.gz,现在要取出每个文件名的前8位（也就是年月日）， 操作如下</span></span><br><span class="line">ls|awk &#x27;BEGIN &#123;FS=&quot;.&quot;&#125; &#123;a=substr($1,1,8);print a&#125;&#x27;</span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>在命令之前加上<strong>LANG&#x3D;C</strong>之后可大幅提高检索速度, 如 LANG&#x3D;C grep -ia -B 1 Exception filename</p><p><strong>参数说明:</strong></p><ul><li>-i 忽略大小写</li><li>-a 显示文本(当使用通配符搜索文件内容时，有时只显示匹配的文件名而不显示匹配的内容，用此参数即可）</li><li>-e 指定多个匹配样式</li><li>-c 计算找到的符合行的次数</li><li>-n 输出匹配行的行号</li><li><strong>-v 反转查找</strong></li><li>-w 只显示全字符合的列</li><li>-A n 打印匹配行和匹配行之后的n行</li><li>-B n 打印匹配行和匹配行之前的n行</li><li>-C n 打印匹配行和匹配行之前,之后的n行,共2n+1</li><li>-h 在显示匹配行的那一列之前,不显示该列的文件名称</li><li>-o 只输出文件中匹配到的部分</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">过滤时间段内的数据, 例如[15:10:00,15:20:00)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注意，正则表达式中的数字范围只能是一位整数</span></span><br><span class="line">grep &quot;15:1[0-9]&quot; file</span><br></pre></td></tr></table></figure><h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><p>可以搜索gz压缩文件内的内容。用法同grep</p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><code> sed  options script file</code></p><p>默认不对原文件进行修改,处理的是原文件的拷贝</p><p><strong>options参数:</strong> </p><ul><li>-n 取消默认的输出,仅显示处理后的结果</li><li>-e 以选项中指定的script处理</li><li><strong>-i  直接修改原文件,慎用</strong></li></ul><p><strong>script 参数:</strong></p><ul><li>d 删除</li><li>p 打印</li><li>s 替换</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>若在sed命令中使用外部的变量，此时匹配规则必须使用双引号</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印第三行</span></span><br><span class="line">sed -n &#x27;3p&#x27; file </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印第200行到300行</span></span><br><span class="line">sed -n &#x27;200,300p&#x27; file </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除文件中的所有空白行</span></span><br><span class="line">sed -n &#x27;/^$/d&#x27; file </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每个有Statement行的下一行添加一个空行</span></span><br><span class="line">sed &#x27;/Statemt/G&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件中含有<span class="built_in">test</span>字符串的行打印出来</span></span><br><span class="line">sed -n &#x27;/test/p&#x27; test.txt </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件中my字符替换为Bob</span></span><br><span class="line">sed &#x27;s/my/Bob/g&#x27; test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件中第三行替换为huang</span></span><br><span class="line">sed -i &#x27;3s/.*/huang/&#x27; file</span><br></pre></td></tr></table></figure><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p>-n 省略结尾的换行符,直接在文本后面输入</p><h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><p>read value 读取用户输入</p><h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><p>显示磁盘信息</p><ul><li>-a 所有</li><li>-h 可读性较好显示</li></ul><h1 id="tail-amp-head"><a href="#tail-amp-head" class="headerlink" title="tail &amp; head"></a>tail &amp; head</h1><p>从文件开头或文件结尾查看文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 显示文件最后n行</span></span><br><span class="line">tail -n file </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实时查看文件内容, 一般查看实时查看日志文件用此命令</span></span><br><span class="line">tail -f file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件的前n行</span></span><br><span class="line">head -n file </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示文件的m到n行</span></span><br><span class="line">head -n file | tail -m</span><br></pre></td></tr></table></figure><h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>压缩文件</p><ul><li>-q 不显示指令执行过程</li><li>-r 递归处理</li></ul><p><strong>示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/db2/ddl目录下所有文件和文件夹压缩至当前目录的test.zip文件</span></span><br><span class="line">zip -q -r test.zip  /home/db2/ddl </span><br></pre></td></tr></table></figure><h1 id="typeset"><a href="#typeset" class="headerlink" title="typeset"></a>typeset</h1><p>设置变量</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><blockquote><p>显示系统进程信息(linux中线程是伪线程，用轻量级进程来实现的，所以查看线程信息也是用此命令）</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>-ef 显示系统运行的所有进程信息</li></ul><h2 id="返回信息"><a href="#返回信息" class="headerlink" title="返回信息"></a>返回信息</h2><ul><li>PID ：该进程的进程ID号</li><li>%CPU：该进程使用掉的 CPU 资源百分比</li><li>%MEM：该进程所占用的物理内存百分比</li><li>VSZ ：该进程使用掉的虚拟内存量 (单位KB)</li><li><strong>RSS ：该进程占用的固定的内存量</strong> (单位KB)</li><li>TTY ：该进程表示在哪个终端机上面运作，其取值可能有如下几种<ul><li>?   与终端机无关</li><li>tty1-tty6  本机上面的登入者程序</li><li>pts&#x2F;0  由网络连接进主机的程序</li></ul></li><li>STAT：该程序目前的状态，主要的状态有<ul><li>R ：该程序目前正在运作，或者是可被运作</li><li>S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒</li><li>T ：该程序目前正在侦测或者是停止了</li><li>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</li></ul></li><li>START：该进程被触发启动的时间</li><li>TIME ：该进程实际使用 CPU 运作的时间</li></ul><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p> 定时任务</p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li>-l  查看现有cron表中的内容</li><li>-e 编辑</li></ul><p>cron文件的语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每一分钟执行一次</span></span><br><span class="line">* * * * * program</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天7:50执行一次</span></span><br><span class="line">50 7 * * * program</span><br></pre></td></tr></table></figure><h2 id="创建定时任务步骤"><a href="#创建定时任务步骤" class="headerlink" title="创建定时任务步骤"></a>创建定时任务步骤</h2><p>crontab -e </p><p>其他常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当有service命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">service crond start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">service crond stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">service crond restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当没有service命令</span></span><br><span class="line">/etc/init.d/cron stop</span><br><span class="line">/etc/init.d/cron start</span><br><span class="line">/etc/init.d/cron restart</span><br></pre></td></tr></table></figure><h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>将命令运行结果同时输出到终端和文件</p><p><code>ls |tee log.log</code></p><h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><blockquote><p>显示文件或目录大小</p></blockquote><ul><li>-c 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</li><li>-h 按友好模式显示</li><li>-s 只显示目录总大小</li><li>-l 重复计算硬件连接的文件</li><li>–max-depth 超过指定层数的目录后，予以忽略</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前目录总大小</span></span><br><span class="line">du -sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前目录下一级子文件和子目录占用的磁盘容量</span></span><br><span class="line">du -lh --max-depth=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计当前文件夹(目录)大小，并按文件大小排序</span></span><br><span class="line">du -sh * | sort -n</span><br></pre></td></tr></table></figure><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>Linux服务器之间传输文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传输aa.txt文件到206服务器的home目录下</span></span><br><span class="line">scp aa.txt usroot@22.5.229.206:/home/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">206服务器下载aa.txt文件到本服务器当前路径：</span> </span><br><span class="line">scp usroot@22.5.229.206:/home/aa.txt .</span><br></pre></td></tr></table></figure><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>排序. 排序时以行为单位</p><ul><li>-r 下降排序,默认升序</li><li>-n 按照数值大小排序</li><li>-k 指定排序所依据的列数,从1开始</li><li>-t 指定排序时的列分隔符</li><li>-u 输出行中去除重复行</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照文件大小从大到小进行排序</span></span><br><span class="line">ls -l|sort -nr -k 5</span><br></pre></td></tr></table></figure><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><blockquote><p>忽略文件中的重复行，常与sort一起使用</p></blockquote><ul><li>-c 在每列旁边显示该行重复出现的次数</li><li>-d 仅显示重复出现的行</li><li>-u 仅显示唯一出现的行</li></ul><p>注意： <strong>uniq的去重是将当前行与上一行进行对比， 所以为了得到整体去重， 需要先进行排序，在执行去重</strong></p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>实时显示系统进程情况.</p><p><img src="https://pic.acchw.top/63df1910a913a.png" alt="20210104190258"></p><p>以下命令为进入该命令之后执行：</p><ul><li>M 根据内存大小进行排序</li><li>P 根据CPU使用百分比进行排序</li><li>T 根据时间&#x2F;累计时间排序</li></ul><p>输出参数说明:</p><ul><li>第一行相当于uptime命令输出<ul><li>第一列时间表示当前系统时间</li><li>第二列 up 6 days 58min, 表示系统已经运行时间</li><li>第三列 2 users, 表示表示当前有2个用户在登陆</li><li>第四列 load average三个值分别表示系统1分钟,5分钟,15分钟平均负载</li></ul></li><li>第二行 tasks信息表示系统运行的整体进程数量和状态信息<ul><li>zombie  僵尸进程数.</li></ul></li><li>第三行 %Cpu(s)表示的是总体CPU使用情况<ul><li><strong>us</strong> user 表示用户态的CPU时间比例. 当us很高时，证明CPU时间主要消耗在用户代码，需要优化用户代码</li><li><strong>sy</strong> system 表示内核态的CPU时间比例. 说明CPU时间都消耗在内核，要么是频繁的系统调用，要么是频繁的CPU切换（进程切换&#x2F;线程切换）</li><li><strong>wa</strong> iowait 表示处于IO等待的CPU时间比例. 很高时，说明有进程在进程频繁的IO操作，有可能是磁盘IO，也有可能是网络IO</li><li>ni nice 表示运行低优先级进程的CPU时间比例</li><li>id idle 表示空闲CPU时间比例</li><li>hi hard interrupt 表示处理硬中断的CPU时间比例</li><li>si soft interrupt 表示处理软中断的CPU时间比例</li><li>st steal 表示当前系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间比例</li></ul></li><li>第4行. 内存使用情况, 单位KiB<ul><li>totol 表示总内存</li><li>free 表示没使用过的内容</li><li>used是已经使用的内存</li><li>buff表示用于读写磁盘缓存的内存</li><li>cache表示用于读写文件缓存的内存</li><li>avail表示可用的应用内存</li></ul></li><li>第5行, swap使用情况, 单位KiB, Swap原理是把一块磁盘空间或者一个本地文件当成内存来使用. 这三个值都为0表示系统关闭了swap功能，虚拟机一般都关闭swap功能<ul><li>Swap total表示能用的swap总量</li><li>swap free表示剩余</li><li>used表示已经使用的</li></ul></li><li>之后为各个进程具体的信息.各字段说明如下<ul><li>PID 进程ID</li><li>USER 进程所有者的用户名，例如root</li><li>VIRT 虚拟内存, virtual memory usage。单位KB. 表示当前进程能够访问到的最大内存大小</li><li><strong>RES 物理内存（不包括共享内存), resident memory usage，单位KB。表示当前有多少物理内存被这个进程消费。如果申请 100m 的内存，实际使用 10m，那么RES &#x3D; 10m，VIRT&#x3D;100M。 一般情况下看此值大小即可</strong></li><li><strong>SHR 进程使用的共享内存. 单位KB</strong></li><li>CPU 进程使用的CPU占比</li><li>MEM 进程使用的内存占比</li><li>TIME 进程启动后到现在所用的全部CPU时间</li><li>COMMAND 进程的启动命令（默认只显示二进制，top -c能够显示命令行和启动参数）</li></ul></li></ul><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>ls -l 的输出内容格式如下: </p><p><code>-rw-r--r-- 1 root root 25934 Jun 26 10:35 X120</code></p><p>参数:</p><ul><li>-h 友好方式显示大小</li><li>-a 所有</li><li>-l 详细格式列表</li><li>-t 用文件和目录的更改时间排序</li><li>-r 反向排序</li></ul><p>添加-l参数时详细输出参数说明:</p><ul><li>第一列<ul><li>第一个， 文件类型<ul><li>d 目录</li><li>-文件，</li><li>c 字符型文件</li><li>b 块设备</li><li>l 链接文件</li></ul></li><li>接下来三个为一组，用来表示权限信息，其中 r 读， w 写， x 执行. 具体如下:<ul><li>2,3,4：文件所有者权限</li><li>5,6,7：同用户组的权限</li><li>8,9,10：非本用户组的权限</li></ul></li></ul></li><li>第二列：有多少文件名连接到此节点</li><li>第三列：所有者账号</li><li>第四列：文件所属的用户组</li><li>第五列：文件大小，默认B</li><li><strong>第六列：最近修改日期</strong></li></ul><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅显示目录名</span></span><br><span class="line">ls -d */</span><br></pre></td></tr></table></figure><h1 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h1><blockquote><p><strong>查看文件属性，包括文件创建时间</strong></p></blockquote><ul><li>Access 访问时间，每读一次这个文件内容，就会更新。比如对这个文件使用more命令。ls、stat命令都不会修改文件的访问时间</li><li>Modify 修改时间，对文件内容进行写操作，就会更新。比如：vi后保存文件。ls -l列出的时间就是这个时间。</li><li>Change 状态改变时间，通过chmod命令更改一次文件属性，这个时间就会更新。</li></ul><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>分割大文件为多个小文件</p><p>参数:</p><ul><li>-b value  按value大小分割文件,即分割后每个文件大小为value(单位为byte)</li><li>-l value  按行数分割文件,即分割后每个文件行数为value</li><li>-d 使用数字作为文件名后缀</li></ul><h1 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h1><p>不带任何参数, 默认发送get请求</p><p>参数:</p><ul><li><p>-d 发送post请求的数据体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &#x27;login=emma＆password=123&#x27; -X POST https://google.com/login</span><br></pre></td></tr></table></figure></li><li><p>-H  设置请求头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#x27;Content-Type: application/json&#x27; https://google.com/login</span><br></pre></td></tr></table></figure></li><li><p>-o 将服务器回应保存成文件, 等同于wget</p></li><li><p>-s 不输出错误和进度信息</p></li><li><p>-X 指定请求的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST https://www.example.com</span><br></pre></td></tr></table></figure></li></ul><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><blockquote><p>语法:  xargs   [-options]    [command]</p><p>作用是将标准输入转为命令行参数</p></blockquote><p>管道符|将左侧的标准输出转化为标准输入, 供右边命令使用, 但是这需要右边命令支持标准输入作为参数, 如grep是支持的, 下面命令是可以的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p>但是很多命令不支持标准输入作为参数, 如echo, 下面这条命令没有任何输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sdsd&quot;|echo</span><br></pre></td></tr></table></figure><p>下面这条命令输出 sdsd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sdsd&quot;|xargs echo</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li>-d 指定分隔符,默认将换行符和空格作为分隔符,如制表符为”\t”</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留当前目录下所有txt格式的文件， 删除所有其他类型的文件</span></span><br><span class="line">ls|grep -v &quot;.txt&quot;|xargs rm</span><br></pre></td></tr></table></figure><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>查看某个端口占用情况.一般查看端口冲突时可使用该软件.</p><p><code> lsof -i:port</code></p><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>后台执行命令，即使退出此终端， 仍然会执行。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">nohup</span>输出的信息不输出到文件</span></span><br><span class="line">nohup ./program &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将<span class="built_in">nohup</span>命令执行的<span class="built_in">log</span>日志输出到指定文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2&gt;&amp;1表示不仅命令行正常的输出保存到backupdb.log中，产生错误信息的输出也保存到backupdb.log中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&amp;表示该进程在后台运行</span></span><br><span class="line">nohup ./backupdb.sh &gt;backupdb.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h1 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h1><blockquote><p>相比于top显示的信息更加详细</p></blockquote><p>注意几点：</p><ul><li>htop默认会把一个进程里的线程当做一个进程来显示出来，若要关闭线程，只显示进程，按F2，再选择 Display options，再选择 Hide userland threads</li></ul><h1 id="nload"><a href="#nload" class="headerlink" title="nload"></a>nload</h1><p> 查看各个网络设备的当前网络速率，也会展示流经设备的总流量 。</p><p>也可指定网卡， 如查看网卡eth0的流量 <code>nload etho</code></p><p>注意：页面上显示的速率单位MBit&#x2F;s， 是M比特每秒， 换算成正常的MB&#x2F;s（M字节每秒）需要除以8</p><h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化成 2020-01-12 23:23:34</span></span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line"></span><br><span class="line">date -d &quot;+1 day&quot; +%Y%m%d   #显示后一天的日期 </span><br><span class="line">date -d &quot;-1 day&quot; +%Y%m%d   #显示前一天的日期 </span><br><span class="line">date -d &quot;-1 month&quot; +%Y%m%d #显示上一月的日期 </span><br><span class="line">date -d &quot;+1 month&quot; +%Y%m%d #显示下一月的日期 </span><br><span class="line">date -d &quot;-1 year&quot; +%Y%m%d  #显示前一年的日期 </span><br><span class="line">date -d &quot;+1 year&quot; +%Y%m%d  #显示下一年的日期</span><br></pre></td></tr></table></figure><h1 id="查看系统发型版本"><a href="#查看系统发型版本" class="headerlink" title="查看系统发型版本"></a>查看系统发型版本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/*release*</span><br></pre></td></tr></table></figure><h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><blockquote><p>用于查看系统设备的IO负载情况， 同时也会显示出CPU处理器的使用情况。 </p><p>数据来源是 &#x2F;proc&#x2F;diskstats</p><p><a href="https://cloud.tencent.com/developer/article/1698369">https://cloud.tencent.com/developer/article/1698369</a></p></blockquote><p>语法：<code>iostat [参数] 设备名</code></p><p>常用参数：</p><ul><li>-d 显示设备利用率</li><li>-c 显示CPU使用情况</li><li>-h  使用NFS网络文件系统来输出报告</li><li>-N 显示LVM逻辑卷管理器设备信息</li><li>-p 显示块设备和分区的状态</li><li>-t 显示报告产生时的时间</li><li>-x 显示更为详细的信息， 一般情况下都需要带上这个参数，方便分析</li><li>-k 以 KB 为单位显示</li><li>-m 以 M 为单位显示</li></ul><p>输出关键参数说明：</p><p>avg-cpu行表示总体cpu的使用情况， 对于多核，这里指的是平均值：</p><ul><li>%user  CPU在用户态执行进程的时间百分比</li><li>%nice   CPU在用户态模式下，用于nice操作，所占用CPU总时间的百分比</li><li>%system   CPU处在内核态执行进程的时间百分比</li><li><strong>%iowait</strong>    CPU用于等待I&#x2F;O操作占用CPU总时间的百分比， 若该值过高，表示硬盘可能存在I&#x2F;O瓶颈 </li><li><strong>%idle</strong>    CPU空闲时间百分比， 若该值高但系统响应慢，可能是cpu等待分配内存，此时应该加大内存；若该值持续低于1，则系统的cpu处理能力相对较低，应该加大cpu</li></ul><p>Device行表示磁盘设备的情况：</p><ul><li>tps 每秒IO数， 表示 每秒向磁盘设备请求数据的次数，包括读、写请求，为rtps与wtps的和</li><li><strong>kB_read&#x2F;s</strong>  每秒从磁盘读取数据大小，单位KB&#x2F;s</li><li><strong>kB_wrtn&#x2F;s</strong> 每秒写入磁盘的数据的大小，单位KB&#x2F;s</li><li>kB_read  从磁盘读出的数据总数，单位KB</li><li>kB_wrtn  写入磁盘的的数据总数，单位KB</li><li>r&#x2F;s     每秒读操作的次数</li><li>rkB&#x2F;s   同kB_read&#x2F;s</li><li><strong>%util</strong>   代表磁盘繁忙程度。越大越繁忙。一般地，如果该参数是100%表示设备已经接近满负荷运行（如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）</li><li>await   平均每次IO请求的等待时间（包括等待时间和处理时间，单位为毫秒）， 这里可以理解为响应时间，一般的系统应该低于5ms，若超过10ms则比较大。一般情况下await与svctm差值（真正的等待时间）越大，队列的时间越长，系统可能存在问题</li><li>svctm   平均每次IO请求的处理时间(单位为毫秒)</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔2秒报告一次所有硬盘的使用情况</span></span><br><span class="line">iostat -d 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔2秒报告一次所有硬盘的详细使用情况,总共报告6次</span></span><br><span class="line">iostat -d 2 6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔2秒报告一次所有硬盘的详细使用情况</span></span><br><span class="line">iostat -x -d 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔2秒报告一次sda硬盘的详细使用情况</span></span><br><span class="line">iostat -x sda -d 2</span><br></pre></td></tr></table></figure><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><blockquote><p>查看网络情况。</p></blockquote><p>显示项Recv-Q, Send-Q表示网络接受队列,发送队列.一般情况下为0, 可接受短暂的非0状态。</p><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计各个Tcp状态的连接有多少个</span></span><br><span class="line">netstat -n | awk &#x27;/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,&quot;\t&quot;,state[key]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计与nginx建立连接的IP，并包含各个IP的连接数</span></span><br><span class="line">netstat -ntp | grep nginx | grep -v &quot;127.0.0.1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c</span><br></pre></td></tr></table></figure><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>抓包工具。</p><p>常用参数：</p><ul><li>-i    指定网卡， 如果设置为any则表示抓取所有网卡</li><li>-w  将结果保存为wireshark可识别的文件， 可直接用wireshark进行分析</li></ul><p>当有多个过滤条件时， 进行连接的操作符有：</p><ul><li>and 且</li><li>or 或</li><li>not 非</li></ul><p>过滤条件：</p><ul><li>host  主机IP， 包含出和入</li><li>port   端口号</li><li>src     ip包的源地址</li><li>dst     ip包的目标地址</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取所有网卡流量，并且过滤主机为192.168.1.23，端口为8123，将结果保存为dd.cap文件</span></span><br><span class="line">tcpdump -i any host 192.168.1.23 and port 8123 -w dd.cap</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装confluence</title>
      <link href="/posts/55856/"/>
      <url>/posts/55856/</url>
      
        <content type="html"><![CDATA[<p>自己搭建一个confluence wiki，现记录一下搭建过程和其中需要注意的点。</p><h1 id="编写docker-compose"><a href="#编写docker-compose" class="headerlink" title="编写docker-compose"></a>编写docker-compose</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">confluence-db</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15202:5432&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/confluence/pgsql-data:/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">confluence:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cptactionhank/atlassian-confluence:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">confluence</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15200:8090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15201:8091&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/confluence/logs:/opt/atlassian/confluence/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/confluence/confluence-data:/var/atlassian/confluence</span></span><br></pre></td></tr></table></figure><p>启动 <code>docker-compose up -d</code></p><p>注意此处<code>/opt/docker/confluence/confluence-data</code>是没有权限的， 按照网上的修改文件夹权限 <code>chown -R daemon.daemon confluence-data </code>也不管用， 不得已先直接777赋权， 以后再研究下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 confluence-data</span><br></pre></td></tr></table></figure><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><ol><li><p>从此处下载破解文件： <a href="https://www.jianguoyun.com/p/DalHveAQqo6RCBjo1KIE">https://www.jianguoyun.com/p/DalHveAQqo6RCBjo1KIE</a> </p></li><li><p>解压， 在命令行执行<code>java -jar confluence_keygen.jar</code></p></li><li><p>在弹出窗中输入Server ID, 点击 <code>.gen!</code>, 将产生的授权码复制下来备用</p></li><li><p>将已经启动好的confluence容器中的<code>atlassian-extras-decoder-v2-3.4.1.jar</code>文件复制出来并重命名,  并下载到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp confluence:/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3.4.1.jar ./atlassian-extras-2.4.jar</span><br></pre></td></tr></table></figure></li><li><p>在之前弹出窗口中点击<code>.patch!</code>按钮， 并选择刚刚下载的atlassian-extras-2.4.jar文件， 当显示<code>jar successfully patched</code>则表示patch成功</p></li><li><p>重新将atlassian-extras-2.4.jar文件命名为atlassian-extras-decoder-v2-3.4.1.jar， 并复制到容器内部</p></li><li><p>重启confluence容器</p></li></ol><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>docker进入Postgres容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it confluence-db bash</span><br></pre></td></tr></table></figure><p>依次执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql -U postgres</span><br><span class="line">CREATE DATABASE confluence WITH OWNER postgres;</span><br></pre></td></tr></table></figure><p>然后重启容器即可</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> confluence </tag>
            
            <tag> 折腾 </tag>
            
            <tag> selfhost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红米AC2100刷pandavan及设置无线中继</title>
      <link href="/posts/43359/"/>
      <url>/posts/43359/</url>
      
        <content type="html"><![CDATA[<h3 id="获取SSH权限"><a href="#获取SSH权限" class="headerlink" title="获取SSH权限"></a>获取SSH权限</h3><ul><li><p>打开本地浏览器输入192.168.31.1并登陆。</p></li><li><p>右上角选择固件升级， 升级到有漏洞版本2.0.7（ <strong>文件名：miwifi_rm2100_firmware_d6234_2.0.7.bin</strong>）</p></li><li><p>刷完重启后重新输入192.168.31.1登陆管理页，此时的浏览器地址栏如下（<strong>注意stock&#x3D;后面的值每个人是不一样的</strong>）：</p><p><code>http://192.168.31.1/cgi-bin/luci/;stok=ODJ893023kd2344224kdF/web/home#router</code></p></li><li><p>将<code>stok=ODJ893023kd2344224kdF</code>显示的值 复制替换到如下链接对应位置并浏览器打开：<br><code>http://192.168.31.1/cgi-bin/luci/;stok=你浏览器显示的值/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></p></li><li><p>此时就已打开了SSH，继续按照上面方法替换stok&#x3D;你浏览器显示的值如下链接并打开，自动修改ssh密码为admin。<br><code>http://192.168.31.1/cgi-bin/luci/;stok=你浏览器显示的值/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20&#39;admin%5Cnadmin&#39;%20%7C%20passwd%20root%3B</code></p></li></ul><h3 id="刷Breed"><a href="#刷Breed" class="headerlink" title="刷Breed"></a>刷Breed</h3><ul><li><p>使用ssh登录路由器：</p><ul><li>IP： 192.168.31.1</li><li>用户名： root</li><li>密码：admin</li></ul></li><li><p>下载breed固件并上传到路由器（<strong>文件名：breed-mt7621-xiaomi-r3g.bin</strong>）</p></li><li><p>执行如下命令， 并等待20s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r write breed-mt7621-xiaomi-r3g.bin Bootloader</span><br></pre></td></tr></table></figure></li></ul><h3 id="进入breed"><a href="#进入breed" class="headerlink" title="进入breed"></a>进入breed</h3><p><strong>先断电，然后先找个针戳住路由器背后Reset小孔， 同时插电，等路由器蓝灯一直闪烁后，浏览器输入192.168.1.1即可进入breed网页。</strong></p><h3 id="更改环境变量"><a href="#更改环境变量" class="headerlink" title="更改环境变量"></a>更改环境变量</h3><p>找到环境变量增加：xiaomi.r3g.bootfw 值：2 然后保存。<br><img src="https://pic.7billapp.com/63df1908c3e57.png"></p><h3 id="刷pandavan固件"><a href="#刷pandavan固件" class="headerlink" title="刷pandavan固件"></a>刷pandavan固件</h3><p>进入breed网页， 清除数据（恢复出厂设置 -&gt;选择pandavan)。</p><p>点击 固件更新 -&gt; 固件 -&gt; 选择文件， 上传trx格式的固件包 ,然后安装即可。</p><p>以下是我用过的几个版本：</p><table><thead><tr><th>文件名</th><th>路由器初始IP</th><th>用户名密码</th><th>备注</th></tr></thead><tbody><tr><td>RM2100_3.4.3.9-099-1200MHz.trx</td><td>192.168.2.1</td><td>admin&#x2F;admin</td><td>1200MHz,当前在用</td></tr><tr><td>R2100_3.4.3.9-099.trx</td><td>192.168.31.1</td><td>admin&#x2F;admin</td><td></td></tr><tr><td>redmi2100.trx</td><td>192.168.123.1</td><td>admin&#x2F;admin</td><td></td></tr></tbody></table><h3 id="设置无线中继"><a href="#设置无线中继" class="headerlink" title="设置无线中继"></a>设置无线中继</h3><p>（好像使用5G来设置中继的话效果更好， 没有做进一步测试）</p><p><img src="https://pic.7billapp.com/63df19093c711.png"></p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>设置内网与上级网络分别属于不同网络<br><img src="https://pic.7billapp.com/63df19099b0bc.png"></p><p>上述文件下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/1Hd6Q8lbYHRcWArt2YfPYaQ">https://pan.baidu.com/s/1Hd6Q8lbYHRcWArt2YfPYaQ</a><br>提取码：8u65</p><p>参考资料：</p><ul><li><a href="http://openwrt.ink:88/archives/s-breed">http://openwrt.ink:88/archives/s-breed</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> AC2100 </tag>
            
            <tag> - </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring中的设计模式</title>
      <link href="/posts/63016/"/>
      <url>/posts/63016/</url>
      
        <content type="html"><![CDATA[<p>本文结合spingboot的源码描述一下spring中运用到的几种点典型的设计模式。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight plaintext"><figcaption><span>本身也能产生bean, 例如其中一个实现类：```AbstractFactoryBean```,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getObject()方法源码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override</span><br><span class="line">public final T getObject() throws Exception &#123;</span><br><span class="line">        //单例从缓存中获取或者暴露引用（用来解决循环引用）</span><br><span class="line">if (isSingleton()) &#123;</span><br><span class="line">return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">            //创建实例</span><br><span class="line">return createInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其最终创建实例的方法是createInstance, 该方法由其子类工厂去实现， 具体的子类有如下几种：</p><p><img src="https://pic.7billapp.com/63df190fd1e0d.png"></p><p>例如mybatis的SqlSessionFactoryBean就是实现了该接口。</p><p>这里有必要说明一下<code>BeanFactory</code>和<code>FactoryBean</code>的区别：</p><ul><li>BeanFactory是Spring工厂中的顶层规范，Spring中的容器都是它的具体实现， 例如常见的<code>ApplicationContext</code></li><li>FactoryBean是一个能生产或修饰对象生成的工厂Bean， 它本身也是一个bean, 由BeanFactory管理</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>从Spring容器中获取的bean, 默认情况下是单实例的， 其具体实现在<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</code>, 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123; <span class="comment">//使用锁保证多线程同步竞争</span></span><br><span class="line">                 <span class="comment">//如果此bean正在加载，则不处理</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="comment">//记录在缓存中，earlysingletonObjects和singletonFactories互斥（用来解决循环依赖）</span></span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>策略模式用于封装系列的算法，这些算法通常被封装在一个 Context 类中，客户端程序可以自由选择其中一种算法，或让 Context 为客户端选择一个最佳的算法 —— 使用策略模式的优势是为了支持算法的自由切换。</p></blockquote><p>Spring中的<code>Resource</code>接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p><p>Resouce接口本身并没有提供任何访问底层资源的逻辑， 针对不同的资源， spring提供了不同的实现类来负责对应的资源访问逻辑。具体如下：</p><ul><li><strong>UrlResource：</strong> 访问网络资源</li><li><strong>ClassPathResource：</strong> 访问类加载路径里资源</li><li><strong>FileSystemResource：</strong> 访问文件系统里资源</li><li><strong>ServletContextResource：</strong> 访问相对于 ServletContext 路径里的资源</li><li><strong>InputStreamResource：</strong> 访问输入流资源</li><li><strong>ByteArrayResource：</strong> 访问字节数组资源</li></ul><p>具体spring该使用哪个实现类， 其中就用到了策略模式的思想。</p><p>Spring提供了如下两个接口：</p><ul><li><strong>ResourceLoader:</strong>  获取一个Resouce实例</li><li><strong>ResourceLoaderAware</strong>： 获取一个ResourceLoader的引用</li></ul><p>当 Spring 应用需要进行资源访问时，实际上并不需要直接使用 Resource 实现类，而是调用 ApplicationContext 实例的 <code>getResource ()</code> 方法来获得资源，ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来，这就体现了策略模式的优势。</p><p>下图是ApplicationContext接口， 可以看到它继承了ResourceLoader接口， 同时也就拥有了该接口的所有方法。</p><p><img src="https://pic.7billapp.com/63df191035b7a.png"></p><p>此处 Spring 框架的 ApplicationContext 不仅是 Spring 容器，而且它还是资源访问策略的 “决策者”，也就是策略模式中 Context 对象，它将为客户端代码 “智能” 地选择策略实现。</p><p>当 ApplicationContext 实例获取 Resource 实例时，系统将默认采用与 ApplicationContext 相同的资源访问策略。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot启动流程及原理剖析</title>
      <link href="/posts/41153/"/>
      <url>/posts/41153/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot应用打出的jar包， 是可以直接使用 <code>java -jar XXX.jar</code> 命令直接启动的， 那么背后的原理是怎样的？</p><h3 id="JarLauncher"><a href="#JarLauncher" class="headerlink" title="JarLauncher"></a>JarLauncher</h3><h4 id="jar包结构"><a href="#jar包结构" class="headerlink" title="jar包结构"></a>jar包结构</h4><p>首先先看一下springboot的jar包结构是什么样的。</p><p>新建一个springboot工程（可以直接使用idea自带的Spring Initializer创建）， 然后使用<code>mvn clean package</code>打包， 使用压缩软件打开jar包， 观察其内部结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties</span><br><span class="line">│   │   ├── cn</span><br><span class="line">│   │   ├── static</span><br><span class="line">│   │   └── templates</span><br><span class="line">│   └── lib</span><br><span class="line">│       ├── spring-core-5.2.2.RELEASE.jar</span><br><span class="line">│       ├── spring-webmvc-5.2.2.RELEASE.jar</span><br><span class="line">│       ├── ...// 这里略了大量jar包</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot </span><br></pre></td></tr></table></figure><p>现在分别说明如下：</p><ol><li><strong>MANIFEST.MF</strong> 该文件描述了jar包的一些关键信息， 其中<code>Main-Class</code>指定了启动类， 在springboot应用中该项是<code>org.springframework.boot.loader.JarLauncher</code>, 该类后续还要深入分析</li><li>BOOT-INF&#x2F;classes 工程的源代码编译完成后的class文件</li><li>BOOT-INF&#x2F;lib 工程依赖的第三方jar包文件</li><li>org 目录： Spring Boot loader 相关的源代码，其中的<code>JarLauncher</code>就放在此处</li></ol><h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><h5 id="Launcher-1"><a href="#Launcher-1" class="headerlink" title="Launcher"></a><strong>Launcher</strong></h5><p>各种 Launcher 的基础抽象类，用于启动应用程序，跟 Archive 配合使用。</p><p>目前有三种实现：</p><ul><li>JarLauncher</li><li>WarLauncher</li><li>PropertiesLauncher</li></ul><h5 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h5><p>归档文件的基础抽象类。</p><ul><li>JarFileArchive 就是 jar 包文件的抽象。它提供了一些方法比如 getUrl 会返回这个 Archive 对应的 URL。getManifest 方法会获得 Manifest 数据等。</li><li>ExplodedArchive 是文件目录的抽象。</li></ul><h5 id="JarFile"><a href="#JarFile" class="headerlink" title="JarFile"></a>JarFile</h5><p>对 jar 包的封装，每个 JarFileArchive 都会对应一个 JarFile。JarFile 被构造的时候会解析内部结构，去获取 jar 包里的各个文件或文件夹，这些文件或文件夹会被封装到 Entry 中，也存储在 JarFileArchive 中。如果 Entry 是个 jar，会解析成 JarFileArchive。</p><p>在执行<code>java jar XXX.jar</code>的时候， 首先触发的是 <code>org.springframework.boot.loader.jar.Handler</code>的main方法， 而不是我们自定义的XXXApplication。</p><p>这里需要注意一点， 直接在idea中搜索<code>JarLauncher</code>这个类是搜不到的， 是因为该类是在编译的时候直接导入到Jar包中的， 如果需要看源码， 需要在pom文件中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-loader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从JarLauncher的main方法开始进行分析，其主要流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExploded()) &#123;</span><br><span class="line">            JarFile.registerUrlProtocolHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> createClassLoader(getClassPathArchivesIterator());</span><br><span class="line">        <span class="type">String</span> <span class="variable">jarMode</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;jarmode&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">launchClass</span> <span class="operator">=</span> (jarMode != <span class="literal">null</span> &amp;&amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();</span><br><span class="line">        launch(args, launchClass, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个自定义类加载器 LaunchedURLClassLoader，遵循双亲委派机制，对于父类无法加载的类，则由 LaunchedURLClassLoader 进行加载，其加载的路径包括 BOOT-INF&#x2F;lib 和 BOOT-INF&#x2F;classes</li><li>调用<code>Thread.currentThread().setContextClassLoader(classLoader)</code>将其设置为线程上下文加载器</li><li>反射执行我们自定义的springboot启动类的main方法，也就是使用<code>@SpringBootApplication</code>注解的类</li></ol><p>一个普通的springboot项目一般都是使用如下方式来启动的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            SpringApplication.run(Application.class, args);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到主要是一个@SpringBootApplication注解和SpringApplication的run()方法。下面对这两个进行详细解释。</p><h3 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="SpringBootApplication注解"></a>SpringBootApplication注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure><p>该注解主要由三个注解组合而成，其他的都是常规注解， 分别是：</p><ul><li>@ComponentScan</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>该注解的主要作用是用来进行包扫描， 从而创建bean。</p><p>其中有一个<code>AutoConfigurationExcludeFilter</code>， 其作用是用来进行包扫描的时候排除自动配置的类， 简而言之不扫描自动配置类。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>该注解是SpringBoot中用来实现自动装配的关键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br></pre></td></tr></table></figure><p>这里重点关注的是<code>@Import(AutoConfigurationImportSelector.class)</code>这一行， 该注解的作用分为如下三点：</p><ul><li>导入被<code>@Configuration</code>修饰的配置类</li><li>导入实现了<code>ImportSelector</code>接口的配置类</li><li>导入实现了<code>ImportBeanDefinitionRegistar</code>接口的配置类</li></ul><p>该注解最终调用的是SpringFactoriesLoader类中的loadSpringFactories()方法， 此方法会加载在META-INF&#x2F;spring.factories中已经定义好的配置类。</p><p>从而通过此注解， 实现将所有的配置类自动装载到spring容器中去。</p><p>下面是springboot 2.1.3版本中autoconfigure模块该文件部分内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">----此处省略-----</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><p>综上， @SpringBootApplication注解的主要作用总结如下：</p><ul><li>实现自动配置</li><li>定义需要加载到spring容器中的bean</li></ul><h3 id="SpringApplication类"><a href="#SpringApplication类" class="headerlink" title="SpringApplication类"></a>SpringApplication类</h3><p><code>SpringApplication.run()</code>方法主要分为两步：</p><ol><li>构造SpringApplication对象</li><li>执行该对象的run方法</li></ol><p>下面分别就这两步进行说明。</p><h4 id="构造SpringApplication对象"><a href="#构造SpringApplication对象" class="headerlink" title="构造SpringApplication对象"></a>构造SpringApplication对象</h4><p>跟踪SpringApplication类实例初始化最终代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">        this.resourceLoader = resourceLoader;</span><br><span class="line">        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    </span><br><span class="line">         // 设置应用类型</span><br><span class="line">        this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">        //  设置初始化</span><br><span class="line">        setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">                ApplicationContextInitializer.class));</span><br><span class="line">       // 设置事件监听器</span><br><span class="line">        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">        // 找出main方法所属的类</span><br><span class="line">        this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就其中关键的几个步骤进行说明</p><h5 id="设置应用类型"><a href="#设置应用类型" class="headerlink" title="设置应用类型"></a>设置应用类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br></pre></td></tr></table></figure><p>应用类型共分为三种， 分别如下：</p><ol><li><code>NONE</code>：正常流程走，不额外的启动web容器, 比如<code>Tomcat</code>。</li><li><code>SERVLET</code>：基于<code>servlet</code>的web程序，需要启动内嵌的<code>servlet</code>web容器，比如<code>Tomcat</code>。</li><li><code>REACTIVE</code>：基于<code>reactive</code>的web程序，需要启动内嵌<code>reactive</code>web容器</li></ol><p>通过判断是否加载了对应的类，比如加载了<code>DispatcherServlet</code>等则会判断是<code>Servlet</code>的web程序, 比如引用了<strong>spring-boot-starter-web</strong>模块， 则 是web程序。</p><h5 id="设置初始化器"><a href="#设置初始化器" class="headerlink" title="设置初始化器"></a>设置初始化器</h5><blockquote><p>初始化器<code>ApplicationContextInitializer</code>， 用于Spring的IOC容器在刷新之前， 进行一些组件的初始化， 比如<code>ServletContextApplicationContextInitializer</code>。</p></blockquote><p>其最终调用是<code>SpringFactoriesLoader.loadSpringFactories()</code>方法， 该方法同@EnableAutoConfiguration注解作用类似， 会从<code>META-INF/spring.factories</code>中加载定义好的类，此处对应的key是 <code>org.springframework.context.ApplicationContextInitializer</code>。</p><p>例如在spring-boot-autoconfigure模块该值对应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br></pre></td></tr></table></figure><p>在spring-boot模块该值对应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br></pre></td></tr></table></figure><p>所以， 实际上的初始化器ApplicationContextInitializer在整个容器中会有多个， 只要实现了<strong>ApplicationContextInitializer</strong>接口并且在spring.factories文件中定义好就行。</p><h5 id="设置事件监听器"><a href="#设置事件监听器" class="headerlink" title="设置事件监听器"></a>设置事件监听器</h5><blockquote><p>监听器<code>ApplicationListener</code>主要是用来监听特定的事件ApplicationEvent, 比如IOC容器的刷新，关闭等。</p></blockquote><p>其实现原理和上面的初始化器类似， 只不过这一次从<code>spring.factories</code>文件中加载的类的key是<code>org.springframework.boot.SpringApplicationRunListener</code></p><h4 id="执行run-方法"><a href="#执行run-方法" class="headerlink" title="执行run()方法"></a>执行run()方法</h4><p>SpringApplication类构造完成之后， 就会调用该类的run()方法， 该方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="comment">//任务执行观察器, 用来记录任务的开始时间和结束时间</span></span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line">        <span class="comment">//获取运行时监听器（1）</span></span><br><span class="line">        <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">        <span class="comment">//发送应用程序启动事件（2）</span></span><br><span class="line">        listeners.starting();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(</span><br><span class="line">                    args);</span><br><span class="line">          <span class="comment">// 创建并配置Environment(此时会加载application.yml文件)</span></span><br><span class="line">            <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners,</span><br><span class="line">                    applicationArguments);</span><br><span class="line">            configureIgnoreBeanInfo(environment);</span><br><span class="line">          <span class="comment">//打印banner</span></span><br><span class="line">            <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">          <span class="comment">//创建context</span></span><br><span class="line">            context = createApplicationContext();</span><br><span class="line">            exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                    SpringBootExceptionReporter.class,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">         <span class="comment">//刷新context之前的一些准备工作   </span></span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                    printedBanner);</span><br><span class="line">           <span class="comment">//刷新context</span></span><br><span class="line">            refreshContext(context);</span><br><span class="line">          <span class="comment">//context刷新完成之后执行额外一些操作</span></span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)</span><br><span class="line">                        .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送ApplicationStartingEvent事件</span></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            callRunners(context, applicationArguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送ApplicationReadyEvent事件，标志SpringApplication已经正在运行，即已经成功启动，可以接收服务请求。（3）</span></span><br><span class="line">            listeners.running(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回context</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="运行时监听器"><a href="#运行时监听器" class="headerlink" title="运行时监听器"></a>运行时监听器</h5><blockquote><p>此处获取的是<code>SpringApplicationRunListeners</code>, 该监听器的作用主要是用来监听应用程序启动过程的, 并将相应的事件广播出去。</p></blockquote><p>首先需要获取， 对应的代码是（1）处的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br></pre></td></tr></table></figure><p>类似的， 该类的定义还是在<code>spring.factories</code>文件中， 对应的key为<code>org.springframework.boot.SpringApplicationRunListener</code>, 在spring-boot模块中该值定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure><p>总共定义了如下几个事件类型：</p><ul><li>ApplicationStartedEvent: run方法执行的时候立马执行</li><li>ApplicationEnvironmentPreparedEvent: ApplicationContext创建之前并且环境信息准备好的时候调用</li><li>ApplicationPreparedEvent: ApplicationContext创建完成之后， refresh之前</li><li>ApplicationReadyEvent： ApplicationContext成功启动</li><li>ApplicationFailedEvent： ApplicationContext启动失败</li></ul><p>这里需要需要说明一下此处的SpringApplicationRunListener和在构造SpringApplication对象时创建的ApplicationListener的联系：</p><p><img src="https://pic.7billapp.com/63df190e734fd.jpg"></p><h5 id="context的创建"><a href="#context的创建" class="headerlink" title="context的创建"></a>context的创建</h5><p>首先是创建ApplicationContext， 这个过程很简单，就是根据webApplicationType创建相应的ApplicationContxet, 决定是servlet、reactive或者非web应用。</p><p>例如对于一个普通web的springboot工程，其最终的ApplicationContext实现类是：<code>AnnotationConfigServletWebServerApplicationContext</code>,  类结构如下所示：</p><p><img src="https://pic.7billapp.com/63df190ee6a3d.png"></p><h5 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a><strong>prepareContext</strong></h5><p>该方法主要做的事如下：</p><ul><li>基本的初始化，如设置Environment</li><li>注册已经有的对象为单例bean, 比如banner</li><li>加载main方法所在的类</li></ul><p>其中加载main方法所在类的关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取BeanDefinition加载器</span></span><br><span class="line">    <span class="type">BeanDefinitionLoader</span> <span class="variable">loader</span> <span class="operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanNameGenerator != <span class="literal">null</span>) &#123;</span><br><span class="line">        loader.setBeanNameGenerator(<span class="built_in">this</span>.beanNameGenerator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">        loader.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line">        loader.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">    &#125;</span><br><span class="line">    loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会创建BeanDefinitionLoader， 然后利用该loader将主类的<code>BeanDefinition</code>加载到context中去。</p><p>其中需要说明一下<code>BeanDefinition</code>, Spring的bean的来源有各种方式， 比如xml文件或者注解的方式， 对于这些bean的定义， 每一个都会生成一个相应的<code>BeanDefinition</code>。</p><h5 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a><strong>refresh</strong></h5><p>容器刷新的核心方法。该方法的主要作用是加载其他的BeanDefinition。</p><p>以web程勋为例， 其对应的context是AnnotationConfigEmbeddedWebApplicationContext， 跟踪其方法， 最终是调用其父类AbstractApplicationContext的refresh方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//使用synchronized修饰，标识在同一时刻</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 刷新前准备，设置flag、时间，初始化properties等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ApplicationContext中组合的BeanFactory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置类加载器，添加后置处理器等准备</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 供子类实现， 例如web程序中的webApplicationContext会在此处构造ServletContext</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// todo 需要再说明 调用Bean工厂的后置处理器</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于实现了BeanFactoryPostProcessor接口的bean进行注册</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化与国际化有关的属性</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化事件广播器， 对于springboot而言， 之前已经注册过， 所以此处不需要重新注册， 只是从容器中拿出来用即可</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子类实现</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将容器内部的监听器添加到事件广播中</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化所有的(懒加载的除外)单例Bean，在进行实例化的时候， BeanPostProcessor开始生效</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发布刷新完毕事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面其中几个关键的步骤进行说明：</p><p><strong>invokeBeanFactoryPostProcessors</strong></p><p>从容器中找出BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的实现类， 然后按照特定的顺序执行。</p><p>注意其中有一个ConfigurationClassPostProcessor的接口， 是BeanDefinitionRegistryPostProcessor的实现类， 该类的作用就是解析所有被以下注解修饰的类</p><ul><li>@Configuration</li><li>@Component</li><li>@ComponentScan</li><li>@Import</li><li>@ImportResource</li></ul><p><strong>registerBeanPostProcessors</strong></p><p>从容器中找出BeanPostProcessor接口的实现类， 在后面的方法finishBeanFactoryInitialization进行bean的实例化的时候， 会执行BeanPostProcessor。</p><p><strong>onRefresh</strong></p><p>子类实现。 例如对于web程序，AnnotationConfigEmbeddedWebApplicationContext会在此处创建内置的servlet容器， 比如常见的Tomcat, Jetty。</p><h5 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners"></a>callRunners</h5><p>该方法会调用所有实现了CommandLineRunner和ApplicationRunner接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; runners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">        <span class="comment">//按照定义好的order进行排序</span></span><br><span class="line">        AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">        <span class="comment">//使用LinkedHashSet来保证runner是有序的， 这样就能按照order顺序执行</span></span><br><span class="line">        <span class="keyword">for</span> (Object runner : <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">                callRunner((ApplicationRunner) runner, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">                callRunner((CommandLineRunner) runner, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>综上， 整个启动流程的图例：</p><p><img src="https://pic.7billapp.com/63df190f70bc4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用另一主机的硬盘</title>
      <link href="/posts/56849/"/>
      <url>/posts/56849/</url>
      
        <content type="html"><![CDATA[<p><strong>实现效果：不实际接入真实硬盘， 而是使用局域网内（公网主机也行， 只是速度取决于带宽）另一主机上的硬盘（或者是目录）</strong></p><p>实现方案： 使用NFS来实现</p><p>准备： </p><ul><li>一个树莓派</li><li>一台Linux主机， 系统Ubuntu 20.04, ip是10.0.0.239</li></ul><p>操作步骤：</p><h4 id="服务端（Linux主机）"><a href="#服务端（Linux主机）" class="headerlink" title="服务端（Linux主机）"></a>服务端（Linux主机）</h4><ol><li><p>IP为10.0.0.239的主机安装nfs server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure></li><li><p>创建nfs共享目录（如果已经存在， 可以不创建）， 也就是要挂载到树莓上的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/media/download</span><br></pre></td></tr></table></figure></li><li><p>配置nfs服务， 编辑配置文件：vim &#x2F;etc&#x2F;exports, 添加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/media/download *(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure><p>各个字段说明如下：</p><ul><li>&#x2F;mnt&#x2F;media&#x2F;download: 要共享的目录</li><li>*<em>：指定可以访问共享目录的用户 ip, * 代表所有用户。192.168.3.</em>　指定网段。192.168.3.29 指定 ip。</li><li>rw：可读可写。如果想要只读的话，可以指定 ro。</li><li>sync：文件同步写入到内存与硬盘中。</li><li>async：文件会先暂存于内存中，而非直接写入硬盘。</li><li>no_root_squash：登入 nfs 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！但如果你需要在客户端对 nfs 目录进行写入操作。你就得配置 no_root_squash。方便与安全不可兼得。</li><li>root_squash：在登入 nfs 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nobody 那个系统账号的身份。</li><li>subtree_check：强制 nfs 检查父目录的权限（默认）</li><li>no_subtree_check：不检查父目录权限</li></ul></li><li><p>配置完成后， 执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -a</span><br><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure></li><li><p>此时服务端配置完成</p></li></ol><h4 id="客户端（树莓派）"><a href="#客户端（树莓派）" class="headerlink" title="客户端（树莓派）"></a>客户端（树莓派）</h4><ol><li><p>安装nfs客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install  nfs-common</span><br></pre></td></tr></table></figure></li><li><p>将树莓派的目录挂载到之前在另外一台主机上共享出来的文件夹， 例如将树莓派的&#x2F;mnt&#x2F;download目录挂载到刚刚在另外一台Linux主机上创建的&#x2F;mnt&#x2F;media&#x2F;download目录， 命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 10.0.0.239:/mnt/media/download /mnt/download/</span><br></pre></td></tr></table></figure></li><li><p>在10.0.0.239的&#x2F;mnt&#x2F;media&#x2F;download下创建一个文件， 此时可以看到树莓派的&#x2F;mnt&#x2F;download&#x2F;目录下也存在刚刚新建的文件</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红米AC2100 openWrt设置无线中继</title>
      <link href="/posts/50827/"/>
      <url>/posts/50827/</url>
      
        <content type="html"><![CDATA[<p>红米AC2100刷openWrt的教程：<a href="http://openwrt.ink:88/archives/s-breed">http://openwrt.ink:88/archives/s-breed</a></p><p>刷完之后， 设置无线中继的步骤记录一下。这里使用2.4G的频率来作为客户端接收上一级信号， 然后使用5G频率作为服务端发射无线信号。图片是已经设置好之后截的， 所以有些地方可能有些不一样。</p><ol><li>选择 网络 - 无线， 选择2.4G旁边的扫描按钮，加入网络， 选择需要中继的上一级网络， 然后填写密码， 其他默认即可。然后点击保存。</li></ol><p><img src="https://pic.7billapp.com/202403011533188.png"></p><p><img src="https://pic.7billapp.com/63df19086a299.png"></p><ol start="2"><li><p>进入网络-接口页面， 点击 LAN条目的编辑， 注意此时已经有一个刚刚加入的wwan网络。<br><img src="https://pic.7billapp.com/202403011534636.png"></p></li><li><p>除了刚才新添加的wwan网络， 其余的全部勾选上<br><img src="https://pic.7billapp.com/202403011535011.png"></p></li><li><p>以上已经完成。 若不想开启2.4G的发射信号， 去无线页面禁用或删除2.4G的即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> AC2100 </tag>
            
            <tag> - </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker-compose+prometheus+grafana搭建Linux监控</title>
      <link href="/posts/50788/"/>
      <url>/posts/50788/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于docker-compose、prometheus、grafana来搭建Linux服务器的监控。 </p></blockquote><p>用到的几个expoter说明：</p><ul><li>node-exporter: 监控整个主机所有资源</li><li>cadvisor： 监控容器资源</li></ul><h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><p>在主机上创建一些目录， 用来持久化监控数据和配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/docker/monitor/config</span><br><span class="line">mkdir -p /opt/docker/monitor/data</span><br><span class="line">chmod 777 /opt/docker/monitor/data</span><br></pre></td></tr></table></figure><h1 id="创建docker-compose-yml"><a href="#创建docker-compose-yml" class="headerlink" title="创建docker-compose.yml"></a>创建docker-compose.yml</h1><p>切换到&#x2F;opt&#x2F;docker&#x2F;monitor目录， 新建docker-compose.yml， 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">monitor:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">monitor-grafana</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/monitor/data:/var/lib/grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;11000:3000&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">monitor-prometheus</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/monitor/config/prometheus.yml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;11001:9090&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">node-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/prometheus/node-exporter</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">monitor-node-exporter</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;11002:9100&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">cadvisor:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">google/cadvisor</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">monitor-cadvisor</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run:/var/run:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/disk/:/dev/disk:ro</span></span><br><span class="line">    <span class="attr">devices:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/kmsg:/dev/kmsg</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;11003:8080&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line"></span><br><span class="line">      <span class="number">10619</span></span><br></pre></td></tr></table></figure><h1 id="创建prometheus-yml"><a href="#创建prometheus-yml" class="headerlink" title="创建prometheus.yml"></a>创建prometheus.yml</h1><p>切换到&#x2F;opt&#x2F;docker&#x2F;monitor&#x2F;config目录， 新建prometheus.yml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;10.0.0.239:11001&#x27;</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;node-exporter&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;10.0.0.239:11002&#x27;</span>]</span><br><span class="line">      </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;cadvisor&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;10.0.0.239:11003&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h1><ol><li>启动容器 <code>docker-compose up -d</code></li><li>待容器成功启动之后，进入dashboard页面, 页面地址：<code>http://10.0.0.239:11000</code>， 第一次进入时的默认用户名和密码是：admin&#x2F;admin， 然后需要设置新密码</li><li>配置datasource, 选择prometheus, URL填写： <code>http://10.0.0.239:11001</code></li><li>从模板网站找到自己喜欢的模板， 比如模板ID为1860， 直接输入ID， 然后点击load导入即可。</li></ol><p>说明一下几个exporter用到的比较好用的模板ID</p><ul><li>node-exporter:  1860</li><li>process-exporter： 249</li><li>cadvisor： 11600</li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> linux </tag>
            
            <tag> 监控 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis相关</title>
      <link href="/posts/45791/"/>
      <url>/posts/45791/</url>
      
        <content type="html"><![CDATA[<p>在springboot中打印sql语句， 在配置文件中添加：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse索引原理介绍</title>
      <link href="/posts/20353/"/>
      <url>/posts/20353/</url>
      
        <content type="html"><![CDATA[<p>clickhouse本身支持很多表引擎，这里只介绍其中最常用的MergeTree引擎。</p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name (</span><br><span class="line">    name1 [type1] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr1] [TTL expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr2] [TTL expr2],</span><br><span class="line">    ...</span><br><span class="line">    INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1, # 创建普通索引（跳数索引）</span><br><span class="line">    INDEX index_name2 expr2 TYPE type2(...) GRANULARITY value2</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> expr</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr] # 创建分区键索引</span><br><span class="line">[<span class="keyword">PRIMARY</span> KEY expr] # 创建主键索引</span><br><span class="line">[SAMPLE <span class="keyword">BY</span> expr]</span><br><span class="line">[TTL expr [<span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">TO</span> DISK <span class="string">&#x27;xxx&#x27;</span><span class="operator">|</span><span class="keyword">TO</span> VOLUME <span class="string">&#x27;xxx&#x27;</span>], ...]</span><br><span class="line">[SETTINGS name<span class="operator">=</span><span class="keyword">value</span>, ...]</span><br></pre></td></tr></table></figure><p>介绍其中几个关键选项的含义：</p><ul><li>PARTITION BY ：分区键。 指定表数据以何种标准进行分区。分区键既可以是单个列字段，也可以通过元组的形式使用多个列字段，同时它也支持使用列表达式。</li><li>ORDER BY ：排序键，用于指定在一个数据片段内，数据以何种标准排序。默认情况下主键（PRIMARY KEY）与排序键相同。</li><li>PRIMARY KEY：  主键。声明后会依照主键字段生成一级索引。默认情况下，主键与排序键(ORDER BY)相同，所以通常直接使用ORDER BY代为指定主键。</li><li>SETTINGS:：<strong>index_granularity</strong>选项表示索引的粒度，默认值为8192。MergeTree索引在默认情况下，每间隔8192行数据才生成一条索引。</li></ul><h3 id="数据存储文件"><a href="#数据存储文件" class="headerlink" title="数据存储文件"></a>数据存储文件</h3><p>下面是clickhouse在存储数据时所产生的文件， 现分别对其用途做简要说明：</p><ul><li>checksums.txt   校验文件，用于记录其他的各类文件（如idx, mrk等）的size和其哈希值， 用于快速校验文件的完整性和正确性。</li><li>columnx.txt   列信息文件， 明文存储，记录该表的所有列信息。</li><li>count.txt       计数文件，明文存储，记录当前分区下数据的总行数。</li><li>primary.idx    主键索引文件</li><li>列名.bin      列数据文件，使用压缩格式存储。每一列都对应一个该文件，如列age为age.bin</li><li>列名.mrk     列标记文件，使用二进制存储。</li><li>partition.dat   保存当前分区下分区表达式最终生成的值</li><li>minmax_.idx     记录当前分区下分区字段对应原始数据的最小和最大值。</li><li>skp_idx_列名.idx    跳数索引数据文件 。</li><li>skp_idx_列名.mrk   跳数索引标记文件。</li></ul><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>首先说明两个重要概念</p><ul><li>granule 索引粒度， 由<strong>index_granularity</strong>指定，默认8192</li><li>block 列存储文件的压缩单元。每个列存文件的Block包含若干个Granule，具体多少个Granule是由参数min_compress_block_size控制，每次列的Block中写完一个Granule的数据时，它会检查当前Block Size有没有达到设定值，如果达到则会把当前Block进行压缩然后写磁盘。</li></ul><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>对应文件：primary.idx </p><p>与传统数据库不同， 主键索引是可以相同的。主键索引存储的是主键值和block， 且数据是按照主键进行排序的。 若查询条件中含有主键值， 则会先根据主键索引得到可能的granule范围，再根据mk标记文件中的偏移量确定数据。</p><h4 id="分区键索引"><a href="#分区键索引" class="headerlink" title="分区键索引"></a>分区键索引</h4><p>数据文件：minmax_分区键名.idx</p><p>记录当前分区下分区字段对应原始数据的最小和最大值。用于查询时迅速排除不需要的分区。</p><h4 id="跳数索引"><a href="#跳数索引" class="headerlink" title="跳数索引"></a>跳数索引</h4><p>数据文件： skp_idx_列名.idx </p><p>语法：<code>INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1</code></p><p>索引的可用类型包括minmax, set, bloom_filter。</p><p>和主键索引类似， 也是一种稀疏索引。因为数据是按主键排序的，主键索引统计的其实就是每个Granule粒度的主键序列最大和最小值，而Skipping索引提供的聚合函数种类更加丰富，是主键索引的一种补充能力。</p><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>MergeTree在写入一批数据时，数据总会以数据片段的形式写入磁盘，且数据片段不可修改。为了避免片段过多，ClickHouse会通过后台线程，定期合并这些数据片段，属于相同分区的数据片段会被合成一个新的片段。</p><p>MergeTree表的写入链路是一个极端的batch load过程，Data Part不支持单条的append insert。每次batch insert都会生成一个新的MergeTree Data Part。如果用户单次insert一条记录，那就会为那一条记录生成一个独立的Data Part，这必然是无法接受的。一般我们使用MergeTree表引擎的时候，需要在客户端做聚合进行batch写入或者在MergeTree表的基础上创建Distributed表来代理MergeTree表的写入和查询，Distributed表默认会缓存用户的写入数据，超过一定时间或者数据量再异步转发给MergeTree表。MergeTree存储引擎对数据实时可见要求非常高的场景是不太友好的。</p><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>例如有如下数据，主键为x和y。</p><table><thead><tr><th align="left">x</th><th align="left">y</th><th align="left">z</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">a</td><td align="left">2</td></tr><tr><td align="left">A</td><td align="left">c</td><td align="left">1</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">1</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">1</td></tr></tbody></table><p>假设index_granularity为2，先将数据分为多个block</p><table><thead><tr><th align="left">x</th><th align="left">y</th><th align="left">block-id</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">B</td><td align="left">b</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">4</td></tr></tbody></table><p>primary.idx内容展示的是主键和block的关系</p><table><thead><tr><th align="left">主键</th><th align="left">block</th></tr></thead><tbody><tr><td align="left">(A,a)</td><td align="left">1</td></tr><tr><td align="left">(A,c)</td><td align="left">2</td></tr><tr><td align="left">(B,b)</td><td align="left">3</td></tr><tr><td align="left">(C,a)</td><td align="left">4</td></tr></tbody></table><p>x.bin 和 y.bin存储对应的各个列的数据，x.mrk存储如下</p><table><thead><tr><th align="left">block-id</th><th align="left">offset</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1-3</td></tr><tr><td align="left">2</td><td align="left">4-9</td></tr><tr><td align="left">3</td><td align="left">10-30</td></tr></tbody></table><p>查询过程如下：</p><p>1、查询条件<br>2、通过查询条件的主键，可以根据primary.idx得出数据落在哪些block<br>3、根据block id 到各自的 mrk上寻找对应的offset<br>4、根据offset去bin中获取对应的数据，加载到内存中向量化操作，过滤</p><p>从以上可以看出：</p><ul><li>查询条件含有主键会减少很多不必要的磁盘IO</li><li>查询返回的值中列越少， 读取的列标记文件和列数据文件就越少，磁盘IO也会降低很多</li></ul><p>参考文章</p><ol><li><a href="https://segmentfault.com/a/1190000023089140">https://segmentfault.com/a/1190000023089140</a></li><li><a href="https://developer.aliyun.com/article/761931">https://developer.aliyun.com/article/761931</a></li><li><a href="https://clickhouse.tech/docs/zh/engines/table-engines/mergetree-family/mergetree/">https://clickhouse.tech/docs/zh/engines/table-engines/mergetree-family/mergetree/</a></li><li><a href="https://www.dazhuanlan.com/2019/11/21/5dd5815e95f7e/">https://www.dazhuanlan.com/2019/11/21/5dd5815e95f7e/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> clickhouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clickhouse </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux压测和硬件测试命令</title>
      <link href="/posts/11469/"/>
      <url>/posts/11469/</url>
      
        <content type="html"><![CDATA[<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>使用fio命令来进行硬盘测试。</p><p>安装：<code>sudo apt install fio</code></p><p>基本参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">filename=/dev/emcpowerb　支持文件系统或者裸设备，-filename=/dev/sda2或-filename=/dev/sdb</span><br><span class="line">direct=1                 测试过程绕过机器自带的buffer，使测试结果更真实</span><br><span class="line">rw=randwread             测试随机读的I/O</span><br><span class="line">rw=randwrite             测试随机写的I/O</span><br><span class="line">rw=randrw                测试随机混合写和读的I/O</span><br><span class="line">rw=read                  测试顺序读的I/O</span><br><span class="line">rw=write                 测试顺序写的I/O</span><br><span class="line">rw=rw                    测试顺序混合写和读的I/O</span><br><span class="line">bs=4k                    单次io的块文件大小为4k</span><br><span class="line">bsrange=512-2048         同上，提定数据块的大小范围</span><br><span class="line">size=5g                  本次的测试文件大小为5g，以每次4k的io进行测试</span><br><span class="line">numjobs=30               本次的测试线程为30</span><br><span class="line">runtime=1000             测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止</span><br><span class="line">time_based: 如果在runtime指定的时间还没到时文件就被读写完成，将继续重复直到runtime时间结束。</span><br><span class="line">ioengine=psync           io引擎使用pync方式，如果要使用libaio引擎，需要yum install libaio-devel包</span><br><span class="line">rwmixwrite=30            在混合读写的模式下，写占30%</span><br><span class="line">group_reporting          关于显示结果的，汇总每个进程的信息</span><br><span class="line">此外</span><br><span class="line">lockmem=1g               只使用1g内存进行测试</span><br><span class="line">zero_buffers             用0初始化系统buffer</span><br><span class="line">nrfiles=8                每个进程生成文件的数量</span><br></pre></td></tr></table></figure><h4 id="随机读"><a href="#随机读" class="headerlink" title="随机读"></a>随机读</h4><p>向磁盘写一个2G文件，10线程，随机读1分钟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/tmp/test_randread -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><h4 id="随机写"><a href="#随机写" class="headerlink" title="随机写"></a>随机写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/sdb1 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><h4 id="顺序读"><a href="#顺序读" class="headerlink" title="顺序读"></a>顺序读</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/sdb1 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><h4 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/sdb1 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>测试局域网内设备之间的网速， 使用iperf3 进行测试。</p><p>安装：</p><ul><li>ubuntu:  <code>apt install iperf3 </code></li><li>windows: 去官网下载文件直接解压， 然后使用cmd运行即可</li></ul><ol><li><p>在局域网内某台服务器上（假设该台机器IP为10.0.0.239）启动iperf3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li><p>在局域网内的另一台机器上运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c 10.0.0.239</span><br></pre></td></tr></table></figure><p>即可得到网速输出结果</p></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>使用stress来进行。</p><p>安装： <code>apt install stress</code></p><p>主要参数：</p><ul><li><strong>-c, –cpu N</strong>       产生 N 个进程，每个进程都反复不停的计算随机数的平方根</li><li><strong>-i, –io N</strong>         产生 N 个进程，每个进程反复调用 sync() 将内存上的内容写到硬盘上</li><li><strong>-m, –vm N</strong>       产生 N 个进程，每个进程不断分配和释放内存</li><li><strong>–vm-bytes B</strong>   指定分配内存的大小</li><li><strong>–vm-stride B</strong>   不断的给部分内存赋值，让 COW(Copy On Write)发生</li><li><strong>–vm-hang N</strong>   指示每个消耗内存的进程在分配到内存后转入睡眠状态 N 秒，然后释放内存，一直重复执行这个过程</li><li><strong>–vm-keep</strong>     一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)</li><li><strong>-d, –hadd N</strong>      产生 N 个不断执行 write 和 unlink 函数的进程(创建文件，写入内容，删除文件)</li><li><strong>–hadd-bytes B</strong> 指定文件大小</li><li><strong>-t, –timeout N</strong>    在 N 秒后结束程序</li><li><strong>–backoff N</strong>      等待N微妙后开始运行 </li><li><strong>-q, –quiet</strong>       程序在运行的过程中不输出信息</li><li><strong>-n, –dry-run</strong>     输出程序会做什么而并不实际执行相关的操作</li><li><strong>–version</strong>        显示版本号</li><li><strong>-v, –verbose</strong>     显示详细的信息</li></ul><p>压满CPU命令，其中4是CPU核心数。通过调用 sqrt 函数计算由 rand 函数产生的随机数的平方根实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress -c 4</span><br></pre></td></tr></table></figure><p>在压测过程中每隔1s实时显示主频：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n1 &quot;cat /proc/cpuinfo | grep \&quot;^[c]pu MHz\&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
