<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录服务异常重启导致clickhouse启动失败</title>
    <link href="/%E7%BC%96%E7%A8%8B/clickhouse/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E9%87%8D%E5%90%AF%E5%AF%BC%E8%87%B4clickhouse%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.html"/>
    <url>/%E7%BC%96%E7%A8%8B/clickhouse/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E9%87%8D%E5%90%AF%E5%AF%BC%E8%87%B4clickhouse%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.html</url>
    
    <content type="html"><![CDATA[<p>测试环境中某个clickhouse实例由于意外断电而终止，重新启动报错，报错的关键信息 DB::ParsingException: Cannot parse input: expected ‘columns format version: 1\n’ at end of stream</p><p>其中报错的日志如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">&#123;&#125; &lt;<span class="hljs-keyword">Error</span>&gt; auto <span class="hljs-keyword">DB</span>::MergeTreeData::loadDataParts(bool)::(anonymous <span class="hljs-keyword">class</span>)::operator()() <span class="hljs-keyword">const</span>: Code: 27. <span class="hljs-keyword">DB</span>::ParsingException: Cannot <span class="hljs-keyword">parse</span> <span class="hljs-keyword">input</span>: expected &#x27;columns <span class="hljs-keyword">format</span> <span class="hljs-keyword">version</span>: 1\<span class="hljs-keyword">n</span>&#x27; at end of stream. (CANNOT_PARSE_INPUT_ASSERTION_FAILED), <span class="hljs-keyword">Stack</span> trace (when copying this message, always <span class="hljs-keyword">include</span> the lines below):<br></code></pre></td></tr></table></figure><p>可以搜一下github上面的issue，也有几个类似的问题， 例如：<a href="https://github.com/ClickHouse/ClickHouse/issues/37397%E3%80%82">https://github.com/ClickHouse/ClickHouse/issues/37397。</a></p><p>这个报错是因为clickhouse在启动服务的时候会检查损坏的数据文件块数量，如果超过一个特定值（默认是10，对应于max_suspicious_broken_parts配置），就会发生这个异常，导致无法启动。</p><p>而出现这么多损坏的文件块数据，是因为在系统异常断电的时候，有些数据还存在于内存中，并没有完全写入磁盘，导致出现数据不一致的情况。</p><p>解决方案有两个：</p><p><strong>（1）调整max_suspicious_broken_parts值</strong></p><p>让其在启动时能允许更多的损坏，但是这个值不好把控，主要取决于在断电的那一瞬间，不一致的数据量有多大，本人自测当调整到10000的时候，才能正常启动。</p><p>修改配置文件中如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">yandex</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">merge_tree</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">max_suspicious_broken_parts</span>&gt;</span>50<span class="hljs-tag">&lt;/<span class="hljs-name">max_suspicious_broken_parts</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">merge_tree</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">yandex</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>(2) 强制启动</strong></p><p>在clicckhouse数据根目录下的flags文件夹下创建一个force_restore_data文件，然后再重启服务即可。假设现在clickhouse的数据根目录是&#x2F;var&#x2F;lib&#x2F;clickhouse， 则执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /var/lib/clickhouse/flags/force_restore_data<br></code></pre></td></tr></table></figure><p>注意，无论上面哪种方式，都有可能会导致数据丢失。</p><p>参考文档：</p><ol><li><a href="https://github.com/ClickHouse/ClickHouse/issues/37397">https://github.com/ClickHouse/ClickHouse/issues/37397</a></li><li><a href="https://kb.altinity.com/altinity-kb-setup-and-maintenance/suspiciously-many-broken-parts/">https://kb.altinity.com/altinity-kb-setup-and-maintenance/suspiciously-many-broken-parts/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql中undo、redo、binlog日志区别和说明</title>
    <link href="/%E7%BC%96%E7%A8%8B/mysql/mysql%E4%B8%ADundo%E3%80%81redo%E3%80%81binlog%E6%97%A5%E5%BF%97%E5%8C%BA%E5%88%AB%E5%92%8C%E8%AF%B4%E6%98%8E.html"/>
    <url>/%E7%BC%96%E7%A8%8B/mysql/mysql%E4%B8%ADundo%E3%80%81redo%E3%80%81binlog%E6%97%A5%E5%BF%97%E5%8C%BA%E5%88%AB%E5%92%8C%E8%AF%B4%E6%98%8E.html</url>
    
    <content type="html"><![CDATA[<p>本文针对的都是MySQL的Innodb引擎。</p><h1 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1. binlog"></a>1. binlog</h1><p>二进制日志。记录数据库的所有写操作。注意此处记录的是逻辑日志。</p><p>可用于主从复制、增量备份、监听binglog实现缓存一致性。</p><h2 id="1-1-常用命令"><a href="#1-1-常用命令" class="headerlink" title="1.1 常用命令"></a>1.1 常用命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看binlog配置信息</span><br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><br><span class="hljs-comment">-- 查看所有的binlog文件</span><br><span class="hljs-keyword">show</span> <span class="hljs-type">binary</span> logs;<br><br><span class="hljs-comment">-- 查看当前正在使用的binlog文件</span><br><span class="hljs-keyword">show</span> master status;<br></code></pre></td></tr></table></figure><h2 id="1-2-写入策略"><a href="#1-2-写入策略" class="headerlink" title="1.2 写入策略"></a>1.2 写入策略</h2><p>通过<code>show binary logs</code>命令可以看到当前数据库使用的哪些binlog文件， 如下图所示：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/202210042118460.png"></p><p>mysql会按照一定的规则，生成对应的日志文件，并按照编号从小到大依次生成。</p><p>binlog日志在写入时， 按照其日志记录类型不同， 分为如下三种情况：</p><ul><li><p><strong>statement</strong>：  记录的是sql原文， 每一条对数据的写操作都会记录在binlog中</p><ul><li>优点： 不需要记录每一行的变化， 能够减少binlog日志量，提升性能。</li><li>缺点：由于记录的是sql原文，所以还需要记录一些额外的相关信息，用来确保在master和slave上执行都是相同的效果。另外有一些函数是无法被复制的， 例如 UUID()</li></ul></li><li><p><strong>row</strong>：记录的是每一行的变化</p><ul><li>优点：可以清楚的表示每一行的数据变化，所以不需要记录额外信息，同时也无需担心函数执行在不同的节点上会有不同的效果</li><li>缺点：会产生大量的日志，特别是那些涉及到整个表的操作，比如增加一个字段，会对该表的所有记录都会产生一条binlog</li></ul></li><li><p><strong>mixed</strong> 混合模式。普通操作使用statement，当无法使用statement时，则使用row</p></li></ul><h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2. redo log"></a>2. redo log</h1><blockquote><p>重做日志。redo log 是物理日志格式, <strong>存储的是对于每个页的修改</strong>的物理情况。</p><p>用来保证事务的<strong>原子性和持久性</strong>。</p></blockquote><h2 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h2><p>mysql为了提高效率，对于数据的修改首先都是在内存中进行的，也就是下图中的Buffer Pool，然后按照一定的策略刷新到磁盘中去。</p><p>此时就会存在一个问题， 当数据被写入到内存， 但是还没有刷新到磁盘，此时若数据库宕机，那么该数据页上的数据就会丢失。</p><p>为了解决这个问题，mysql引入了redo log， 每次对数据页的修改，都会存储到一个redo log日志文件中去，当出现异常宕机后，数据库实例重新启动时，就会去检查这个redo log文件，并对事务进行重放，从而恢复数据。</p><h2 id="2-2-写入策略"><a href="#2-2-写入策略" class="headerlink" title="2.2 写入策略"></a>2.2 写入策略</h2><p>redo log 也并不是直接写入磁盘的，而是先写入到redo log buffer， 然后按照一定的条件顺序的写入到磁盘中去。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/202210042118210.png"></p><p>这个地方有个疑惑， 如果是这样的话，那么也会存在和上面一样的问题， redo log buffer还未来得及写入磁盘数据库就宕机， 也会出现不一致的问题。个人理解是redo log的默认刷盘策略是事务提交时就会刷盘，如果事务没提交，那么就不会刷盘，此时就算丢失数据，也是未提交的数据，丢失了也无所谓。</p><p><strong>redo log文件路径</strong>： 在数据根目录下会有两个文件<code>ib_logfile0</code>和<code>ib_logfile1</code>两个文件， 都是用来存储redo log的， 并且写入的时候是轮流写入的。</p><p>redo log 分为两部分:</p><ul><li>redo log buffer 内存中的重做日志缓存, 易丢失</li><li>redo log file 磁盘中的重做日志文件, 持久化</li></ul><p>参数<code>innodb_flush_log_at_trx_commi</code> 控制重做日志redo log buffer刷新到磁盘的策略, 默认值为1, 其取值含义如下:</p><ul><li>取值1：  <strong>事务提交时必须调用一次fsync操作， 默认值</strong>。</li><li>取值0：事务提交时不进行fsync操作。那么什么时候将其刷新到磁盘呢? 在master thread中, 每隔1秒就会进行一次fsync操作</li><li>取值2： 事务提交时, 仅将重做日志刷新到文件系统系统缓存, 不进行fsync操作，由文件系统来负责进行刷盘操作</li></ul><p>注意，在8.0之后， mysql将AUTO_INCREMENT计数器的变化也写入到重做日志中， 当 MySQL 服务被重启或者处于崩溃恢复时，它可以从持久化的检查点和重做日志中恢复出最新的 <code>AUTO_INCREMENT</code> 计数器，避免出现不单调的主键。</p><h2 id="2-3-redo与bin区别"><a href="#2-3-redo与bin区别" class="headerlink" title="2.3 redo与bin区别"></a>2.3 redo与bin区别</h2><ul><li><strong>写入时机不同</strong>。 binlog只有在事务提交时才会写，所以一个事务中，只会存在一次写。而redo log在事务进行中会不断的写入到重做日志文件中</li><li><strong>记录内容不同</strong>。 无论binlog按照哪种方式进行存储，其存储的都是对数据的一个物理更改。而redo log记录的则是对于数据页的物理修改</li></ul><h1 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3. undo log"></a>3. undo log</h1><blockquote><p> 回滚日志。<strong>存储的是逻辑方面的日志</strong>。</p><p>可以用来实现事务的<strong>原子性</strong>。</p></blockquote><p>undo log日志存放在数据库内部一个特殊的段中，这个段就是undo段。undo段存储在共享表空间中。</p><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><p>undo log主要有两个作用：</p><ul><li><strong>回滚</strong>: 在事务的正常进行过程中，会不断的往undo log日志写入，来记录本次修改之前的历史值。这样，当发生故障或者用户手动回滚的时候，就可以通过回放undo log将未提交的修改去除。</li><li><strong>MVVC</strong>: 多版本并发控制。为了解决读事务和写事务之间的冲突，提高数据库的读操作，mysql会为每一次的写入都记录一个历史版本，也就是undo log，这样，在读取数据时，就不用锁定数据直接读就行。由于在同一个事务中可能会存在多个版本，所以在不同的事务隔离级别下，读的历史版本也不一样。比如mysql的默认隔离级别-可重复读， 读取的历史版本就是事务刚开始的版本， 而在提交读隔离级别下，读取的历史版本是最新版本的数据。</li></ul><h2 id="3-2-写入策略"><a href="#3-2-写入策略" class="headerlink" title="3.2 写入策略"></a>3.2 写入策略</h2><p>undo log 为了保证更好的并发以及多版本控制，所以其存储不应该因为物理存储变化而变化，所以undo log采用了逻辑存储的方式，来保存这些数据的历史版本。所以在数据库中， 是可能存在一行数据的多个历史版本的， 这些数据在InnoDb看来，和其他的数据没有什么区别，所以，同样的，也会写自己的redo log，通过redo log来保证自己的原子性。</p><p>对于undo log, 分为两种：</p><ul><li>Insert Undo: 对于插入操作，由于其并没有历史版本，所以此处并不需要MVCC，记录undo的目的仅仅是为了回滚</li><li>Update Undo: 对于更新操作，MVCC需要存储多个历史版本，所以需要存储的信息就比insert类型的多。</li></ul><h2 id="3-3-undo与redo区别"><a href="#3-3-undo与redo区别" class="headerlink" title="3.3 undo与redo区别"></a>3.3 undo与redo区别</h2><ul><li>在对数据库进行修改时, 不仅会产生redo log, 还会产生一定的undo log</li><li>redo log是存储在文件里的, 但是undo log是存储在共享表空间一个特殊的段segment内的(undo segment)</li></ul><p>参考资料：</p><ol><li>《MySQL技术内幕》</li><li><a href="http://mysql.taobao.org/monthly/2015/04/01/">http://mysql.taobao.org/monthly/2015/04/01/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客工具搭建</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<p>记录一下本人的VPS搭建的几个专门为个人博客使用的一些工具软件，为了方便， 都是使用docker进行部署，并且为了保证可修改性，都是编写docker-compose.yml文件启动，这样后面如果要修改的话，就会很容易。</p><p>因为vps的规格较低，所以在挑选工具时，会尽量偏向于内存占用小的。</p><p>同时为了尽量减小资源，专门部署了一个mysql实例（docker方式），各个需要数据库的服务都会建立一个自己的库，然后都连接到这个实例上。</p><p>mysql实例的docker-compose.yml文件如下， 在这之前，需要创建一个docker网络，然后将所有需要连接到该数据库的docker服务都连接到该网络上即可，具体连接方法可参考下面的umami或waline中的配置。</p><p>此处创建的docker网络名为<code>db-net</code>，需要先行创建，创建命令：<code>docker network create db-net</code></p><p>mysql的docker-compose.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">db-net:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-attr">mariadb:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mariadb:10.5.9</span><br>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">mariadb</span><br>        <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>        <span class="hljs-attr">environment:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=******</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_USER=root</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_PASSWORD=******</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-attr">db-net:</span><br>                <span class="hljs-attr">aliases:</span><br>                    <span class="hljs-bullet">-</span> <span class="hljs-string">mariadb</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;PWD&#125;/data:/var/lib/mysql</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/timezone:/etc/timezone:ro</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span><br><br></code></pre></td></tr></table></figure><p>介绍一些基本背景：目前博客部署在github上， 博客使用的基本框架是hexo，主题是fluid</p><h1 id="数据统计umami"><a href="#数据统计umami" class="headerlink" title="数据统计umami"></a>数据统计umami</h1><p>一个个人站点数据统计工具， 界面看上去比较清新简洁。</p><p>需要先连接到mysql上先创建一个数据库 umami，登录到数据库， 然后执行如下命令：</p><p><code>create database umami default character set utf8mb4 collate utf8mb4_unicode_ci;</code></p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">db-net:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">umami:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ghcr.io/mikecao/umami:mysql-latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">umami</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;12000:3000&quot;</span><br>    <span class="hljs-attr">networks:</span><br>        <span class="hljs-attr">db-net:</span><br>            <span class="hljs-attr">aliases:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">umami</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">DATABASE_URL:</span> <span class="hljs-string">mysql://root:*****@mariadb:3306/umami</span><br>      <span class="hljs-attr">DATABASE_TYPE:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">HASH_SALT:</span> <span class="hljs-string">******</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>在hexo博客根目录下的scripts目录，找到一个index.js文件（如果没有就自己创建一个)，在里面加上如下一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;head_end&#x27;</span>,<span class="hljs-string">&#x27;&lt;script async defer data-website-id=&quot;****&quot; src=&quot;*******&quot;&gt;&lt;/script&gt;&#x27;</span>,<span class="hljs-string">&#x27;default&#x27;</span>);<br></code></pre></td></tr></table></figure><p>其中 script 内容是从umami上获取的跟踪代码</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/202210041712577.png"></p><h1 id="评论-waline"><a href="#评论-waline" class="headerlink" title="评论 waline"></a>评论 waline</h1><p>一个博客的评论系统。可以自己部署。</p><p>需要先连接到mysql上先创建一个数据库 umami，登录到数据库， 然后执行如下命令：</p><p><code>create database waline default character set utf8mb4 collate utf8mb4_unicode_ci;</code></p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">db-net:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">waline:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">waline</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">lizheming/waline:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8360</span><span class="hljs-string">:8360</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;PWD&#125;/data:/app/data</span><br>    <span class="hljs-attr">networks:</span><br>            <span class="hljs-attr">db-net:</span><br>                <span class="hljs-attr">aliases:</span><br>                    <span class="hljs-bullet">-</span> <span class="hljs-string">waline</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br>      <span class="hljs-attr">MYSQL_HOST:</span> <span class="hljs-string">mariadb</span><br>      <span class="hljs-attr">MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">MYSQL_DB:</span> <span class="hljs-string">waline</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">******</span><br>      <span class="hljs-attr">JWT_TOKEN:</span> <span class="hljs-string">&#x27;******&#x27;</span><br>      <span class="hljs-attr">SITE_NAME:</span> <span class="hljs-string">&#x27;******&#x27;</span><br>      <span class="hljs-attr">SITE_URL:</span> <span class="hljs-string">&#x27;*******&#x27;</span><br>      <span class="hljs-attr">SECURE_DOMAINS:</span> <span class="hljs-string">&#x27;*********&#x27;</span><br>      <span class="hljs-attr">AUTHOR_EMAIL:</span> <span class="hljs-string">&#x27;**********&#x27;</span><br>      <span class="hljs-attr">IPQPS:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#基于 IP 的评论发布频率限制,单位s</span><br><br></code></pre></td></tr></table></figure><p>这上面的一些配置可以自己查看文档， 传送门 <a href="https://waline.js.org/">https://waline.js.org/</a></p><p>上面的关键配置是SECURE_DOMAINS， 需要加上自己博客的域名，其他的设置直接参考fluid的文档即可， 写的比较详细，传送门 <a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>博客</tag>
      
      <tag>umami</tag>
      
      <tag>waline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人笔记软件的选择</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9.html</url>
    
    <content type="html"><![CDATA[<p>写这篇文章的目的， 主要是为了记录一下自己使用的笔记软件的过程以及最终选择（当然也只是目前的选择， 后续会不会变就不清楚了）， 给其他同样有此问题的人一个参考。</p><p>先说一下本人选择笔记软件的一些原则：</p><ul><li>数据要掌握在自己手上，放在云上的我感觉都不安全， 因为开发该软件的公司哪天收费了或倒闭了， 你自己的数据就没了或者不好弄出来</li><li>要多端都能使用</li><li>方便同步</li><li>最好能自己部署</li></ul><h1 id="为知笔记"><a href="#为知笔记" class="headerlink" title="为知笔记"></a>为知笔记</h1><p>推荐星级：★</p><p>这是我个人早起用的时间比较长的一个笔记软件， 是一个传统的笔记软件， 使用过程中陆陆续续出现过一些晓问题， 后来为知强制收费， 加上对其富文本格式的担心，花了一天的时间把数据都迁移出来了。</p><p>为知笔记有一个官方的docker镜像， 可以自己部署使用， 但是有些功能还是需要连接到官方使用， 所以感觉不是很友好。</p><h1 id="typora-坚果云"><a href="#typora-坚果云" class="headerlink" title="typora + 坚果云"></a>typora + 坚果云</h1><p>推荐星级：★★★</p><p>在不使用为知笔记之后， 我一直在寻找替代品， 包括印象笔记，有道笔记等， 但都不符合预期， 且不符合数据掌握在自己手中的原则。在这个过程中，我了解到了markdown这一文本格式， 就迅速的爱上他了。</p><p>再结合数据同步与备份， 便使用了 <code>typora + 坚果云</code>这一组合。这个组合其实还蛮好用的， 但是其有一个三个致命缺点：</p><ul><li>不能全文搜索， 特别是笔记一多，有时想找个之前记录的东西又不记的文件名， 很费事</li><li>目录树的组织不够清晰明了</li><li>坚果云的免费额度较低， 不过只作为笔记同步的话一般够用了</li></ul><p>当然，这个组合我目前还在轻微使用， 但是很少用来记录笔记了。</p><h1 id="confluence"><a href="#confluence" class="headerlink" title="confluence"></a>confluence</h1><p>推荐星级：★★★</p><p>这是在公司使用的一个wiki系统， 感觉挺好用的， 然后网上找了一下， 发现有它的docker镜像， 然后就在自己的VPS上部署用了一下， 确实还可以。</p><p>这个是完全基于web的应用， 所以在各个端上都能完美的适配。</p><p>有几个不好的地方说明一下：</p><ul><li>资源占用较大。 咱的VPS是一个小水管， 属实有点耗不起</li><li>对markdown的支持不是很全面。 有些操作还是需要手动点击相应的按钮才能实现。</li></ul><p>总体来说， 这个还是比较好用的。本人也有一篇使用docker介绍其安装的博客。</p><h1 id="notion"><a href="#notion" class="headerlink" title="notion"></a>notion</h1><p>推荐星级：★★★</p><p>说实话， 这个软件我是非常喜欢的， 不管是文字输入还是排版等方面， 都很舒适， 特别是其<code>database</code>功能，真的很强大。但是其有一个致命缺点， 其服务器在国外， 虽然现在国内在不挂梯子的情况下也能访问， 但是网速还是比较慢， 而且谁也不知道哪天就被ban了。</p><p>同时也不支持自建服务， 所以我最终还是放弃了。 但是这个软件给我带来的结果就是， 我后面寻找的软件很多都是以它为标准的， 或者说就是寻找它的替代品。 </p><p>github上有个非常火的项目<a href="https://github.com/AppFlowy-IO/AppFlowy">AppFlowy</a> 就是它的一个替代品， 但是现在还很不完善， 所以暂时放弃。</p><p>如果你对上面这个缺点不是很在乎， 那么notion将是一个比较好的选择。</p><h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p>推荐星级：★</p><p>支持自建服务。但是其登录选项不好弄， 个人弄了半天才成功， 而且使用之后， 感觉也不是很惊艳， 所以试用了一下就放弃了。</p><h1 id="trilium"><a href="#trilium" class="headerlink" title="trilium"></a>trilium</h1><p>推荐星级：★</p><p>支持自建服务。 说实话， 它的颜值确实不敢恭维，所以在试用了一下也放弃了。</p><p><img src="https://raw.githubusercontent.com/wiki/zadam/trilium/images/screenshot.png"></p><h1 id="思源笔记"><a href="#思源笔记" class="headerlink" title="思源笔记"></a>思源笔记</h1><p>推荐星级：★★★★★</p><p>这是我目前在用的主力软件。和notion比较像，功能还是很强大的。对mardown的支持也非常好， 基本上我平时用的markdown语法都支持。搜索功能也很强大， 总之，比较完美的符合了我现在的一切要求。</p><p>支持docker伺服，所以我直接部署在VPS上了， 只需要做好VPS的数据备份即可。</p><p>下面这张是我用的集市里面的notion主题， 颜值一下子就上去了。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/202207031614671.png"></p><p>贴一个docker-compose.yml文件， 直接启动即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">siyuan:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">b3log/siyuan</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">siyuan</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;PWD&#125;/data:/home/siyuan/Documents/SiYuan</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">--resident=true</span>,<span class="hljs-string">--ssl=true</span>,<span class="hljs-string">--servePath=&#x27;你的域名&#x27;</span>]<br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6806</span><span class="hljs-string">:6806</span><br></code></pre></td></tr></table></figure><p>配置nginx转发的时候， 需要注意一下， &#x2F;ws的也需要配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> 你的域名<br>    charset utf-<span class="hljs-number">8</span>;<br>    <span class="hljs-attribute">ssl_certificate</span>   /etc/nginx/cert/域名pem文件;<br>    <span class="hljs-attribute">ssl_certificate_key</span>   /etc/nginx/cert/域名key文件;<br>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span> ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;<br>    <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://localhost:6806;<br>    &#125;<br>    <span class="hljs-section">location</span> /ws &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://localhost:6806;<br>        <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">60s</span>;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&#x27;Upgrade&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap的实现机制是一直在变化的， 其中8的变化较大， 下面分别说明一下在Java7和Java8中他们的实现机制。</p><h2 id="Java-7-实现原理"><a href="#Java-7-实现原理" class="headerlink" title="Java 7 实现原理"></a>Java 7 实现原理</h2><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/202206202150128.png"></p><p>如上图所示，其主要是基于<strong>分离锁</strong>来实现的。这样做的目的是， 在进行并发操作的时候， 只需要锁住相应的Segment, 而不需要去锁住整个数据， 提高并发性能。</p><p>存储数据的是一个个的Segment，Segment是继承自ReentrantLock，所以它本质上就是一个锁。 </p><p>每个Segment内部都有一个HashEntry的数组， 这个HashEntry数组存储方式和HashMap内部的table数组类似， 哈希相同的元素也是以链表形式存储。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>在并发的时候，get操作只要能保证可见性即可， 所以没有同步操作。</p><ol><li>定位元素所属的segment</li><li>利用jdk提供的Unsafe方法保证以可见性的方式获取元素，<code>UNSAFE.getObjectVolatile()</code></li></ol><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol><li>利用<code>UNSAFE.getObject()</code> 方法获取元素所属的segment</li><li>利用所属的segment获取可重入锁，从而将该segment锁住， 防止其他的线程进行并发写</li><li>会有一个无线循环， 在该循环内部， 会确定该元素的key是否在HashEntry数组中， 从而决定是进行插入还是更新。</li></ol><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>由于需要考虑并发， 计算总容量的时候， 如果锁住整个数据，会导致性能很差。所以ConcurrentHashMap在此处使用了重试机制。</p><p>在进行size操作的时候， 通过重试机制（默认2次）获取值，如果重试的时候没有发生变化， 则直接返回旧值， 如果发生了变化，则还是要通过获取锁来进行计算。</p><h2 id="Java-8-实现原理"><a href="#Java-8-实现原理" class="headerlink" title="Java 8 实现原理"></a>Java 8 实现原理</h2><p>和HashMap类似，其内部存储数据的结构是也是一个大的桶数组<code>Node[]</code>， 数组节点是链表或者是红黑树。其数组定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure><p>总结几点：</p><ol><li>内部虽仍然有Segment的定义, 但是只是为了保证序列化的兼容性， 并没有任何用处</li><li>Node中的value和next都是用volatile来修饰， 保证变量的可见性</li><li>大量使用CAS操作， 可以有效减少锁的使用</li></ol><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210324152443015.png" alt="image-20210324152443015"></p><p>对上面源码几处关键处进行一下说明：</p><ol><li>当数组为空的时候进行初始化， 说明初始化的调用时机是第一次put的时候， 和HashMap类似</li><li>定位当前数组下标处是否存在节点， 若不存在，则利用CAS尝试写入， 如果失败则自旋保证成功，<strong>此处利用CAS来进行写入</strong>， 所以是不需要加锁的。<br>定位索引的方法： <code>i = (n - 1) &amp; hash</code></li><li>如果检测到当前正在扩容， 则帮助其进行扩容</li><li>当以上条件都不满足时， 说明此处已经存在节点， <strong>则对该节点上锁， 此处直接使用synchronized进行加锁， 且加锁的对象只是该节点而不是整个数据</strong></li><li>获取该节点的锁之后， 判断该节点类型， 若是链表，则遍历链表插入</li><li>若是红黑树，则遍历红黑树插入</li><li>判断是否要将链表转换为红黑树，临界值和HashMap一样也是8</li></ol><p>其整体流程与HashMap较为相似， 就其中几个关键不同之处进行说明：</p><ol><li>当 插入一个新节点的时候， HashMap是直接插入，而ConcurrentHashMap使用CAS进行无锁插入</li><li>ConcurrentHashMap多了一个状态判断， 当发现Map正在扩容，则调用<code>helpTransfer()</code>帮助其进行扩容， 以加快扩容速度。</li><li>当索引处已经存在节点， 此时往该索引处添加元素时， ConcurrentHashMap 首先对该节点加锁， 在获取到该节点的锁之后再进行后续操作， 这样既能保证插入操作的线程安全性，同时因为只对该节点加锁，没有对整个数据加锁， 从而减少锁竞争， 提高效率。</li></ol><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>get方法没有加锁， 而是利用CAS来进行处理， 可以提高查询效率。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210324155113056.png" alt="image-20210324155113056"></p><p>下面是源码对应的关键几步进行分析：</p><ol><li>利用CAS获取数组列表下标处的节点</li><li>如果当前节点（链表头结点）刚好是要找的节点， 则直接返回当前节点值</li><li>如果eh&lt;0, 表示当前正在扩容或者该位置是红黑树， 调用find查找</li><li>以上条件都不满足， 表明该位置是链表， 遍历链表进行查找</li></ol><h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><p>其调用的是<code>sumCount()</code>方法，采用<code>分而冶之</code>进行计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>        CounterCell[] as = counterCells; CounterCell a;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>        <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                    sum += a.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="CAS简单介绍"><a href="#CAS简单介绍" class="headerlink" title="CAS简单介绍"></a>CAS简单介绍</h2><p>上面章节中多次提到cas，下面简单介绍一下。</p><p>Compare and Swap， 比较并交换， 包含了两个动作。在现代CPU中，提供了一个<code>CAH</code>指令，保证这两个动作的原子性。</p><p>CAS的核心有三个参数：</p><ul><li>V 内存位置</li><li>A 旧的预期值</li><li>B 要修改的值，也就是新值</li></ul><p>首先要明白， 每个线程都会有一个自己的内存空间，在进行操作时， 首先会将主内存的值copy一份到自己的线程内存空间， 然后再刷新到主内存。</p><p>举一个简单例子， 比如<code>a+1</code> 这个操作，此时a的值时0， 当有thread1、thread2两个线程都执行的时候， 其情况是怎么样的？</p><ol><li>thread1、thread2将主内存中的a的值copy到自己的线程内存空间，此时对于这两个线程而言，他们的 预期值 A 都是0， 要修改的值 B 都是1</li><li>然后就会执行 比较并交换的动作， thread1将a的旧预期值与主内存中a的值进行比较， 此时发现两者相等，就会直接将要修改的值a&#x3D;1刷新到主内存， 此时主内存中a的值就变成了1</li><li>此时thread2在提交的时候，发现a的预期值0与主内存中a的值1不相等， 就会放弃本次提交。提交失败之后，会继续重复执行步骤1的操作， 直到成功。</li></ol><p>使用<code>UnSafe</code>操作cas是不推荐的， 在Java9之后， 提供了<code>VarHandle</code>来进行CAS操作， 一般流程都是首先获取变量句柄，然后调用其cas方法。</p><p>CAS中常见的一个<code>A-B-A</code>问题，由于CAS是在更新时比较新值与旧值，如果刚好新值从A变为B再改为A， 此时这个比较实际上就无效了， Java提供了一个<code>AtomicStampedReference</code>类， 为引用建立版本号， 每次变更值的时候， 版本号都会发生变化， 从而确定该值是否真的改变。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>HashMap是由数组<code>Node&lt;K,V&gt;[] table</code> 和链表（或者树）组成的一个复合结构。</p><p>数组被分成一个个的桶（buket），通过下面的这个算法决定元素在桶中的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// n为数组长度，hash为key的哈希值</span><br>p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]<br></code></pre></td></tr></table></figure><p>若p相同，则以链表形式存储。当链表长度超过阈值（TREEIFY_THRESHOLD&#x3D;8）时，则将链表转换为红黑树。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/20200911104213.jpg" alt="img"></p><p>此处为什么需要这么做?</p><p>主要是基于查询的效率考虑。链表查询元素的时间复杂度为O(n)，随着链表长度的增大，查询时间也会递增。而红黑树的时间复杂度为O(logn)，此处是一个<code>以空间换时间</code>的典型案例。</p><p>HashMap中几个特殊值说明：</p><ul><li><strong>initialCapacity</strong>：HashMap初始容量，默认为16</li><li><strong>loadFactor</strong>：负载因子，默认0.75</li><li><strong>threshold</strong>：键值对数量的最大值（不是table数组的长度），超过这个值，则需要扩容，会变为原先值的两倍</li><li><strong>TREEIFY_THRESHOLD</strong>：链表转换红黑树阈值，默认为8， 当超过该值时， 链表就会转换为红黑树</li></ul><h2 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h2><p>key本身的哈希值不是通过hashCode得到的， 而是HashMap自己实现的一个算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object kye)</span> &#123;<br><span class="hljs-type">int</span> h;<br><span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此处将高位数据移位到低位进行异或运算，是因为有些数据计算出来的哈希值差异主要就在高位，而其哈希寻址是忽略容量以上的高位的，所以通过这样处理， 就能有效避免上述情况的哈希碰撞。现实中，构造哈希冲突并不是很难，恶意代码就有可能会通过该手段造成大量的哈希碰撞，造成服务器CPU大量占用。</p><h2 id="插入流程"><a href="#插入流程" class="headerlink" title="插入流程"></a>插入流程</h2><p>首先计算key的哈希值， 然后调用putVal()函数。</p><p>下图是putval()函数的源码， 就其中的关键几步进行说明</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210323152030654.png" alt="image-20210323152030654"></p><ol><li><p>当数组为空，则调用<code>resize()</code>函数进行数组的初始化操作。该处代码表明HashMap中数组的初始化并不是在new的时候，而是在第一次put的时候。</p></li><li><p>使用<code>(n - 1) &amp; hash</code>计算数组下标，若当前项不存在，则调用<code>newNode()</code>函数在数组下标处新建一个节点。</p></li><li><p>当以上条件都不满足， <strong>说明该处索引已经存在节点，此时就该进行链表或树操作了</strong>。3、4、5是对应不同类型的。其中3是直接判断当前节点， 4则是树节点， 5是链表。 此处需要判断该节点处的key和待存入数据的key是否相等。判断相等的条件如下（之间是且的关系）：</p><ul><li>将要存入数据key的哈希值和数组下标处节点的哈希值相等</li><li>将要存入数据的key和数组下标处节点的key相等（此处相等是内存地址相等或者equals比较相等都可以）</li></ul></li><li><p>该代码表明该处数组下标处的节点是树节点， 所以此时调用<code>putTreeVal()</code>函数插入树节点。</p></li><li><p>当3和4都不满足时，则表明该处是一个链表，则进行链表的遍历。</p></li><li><p>若一直能遍历到链表尾部，则在链表尾部新建一个节点储存当前待存入数据。<strong>然后判断是否要将链表（TREEIFY_THRESHOLD）转化为红黑树</strong>， 若是则调用<code>treeifyBin()</code>函数进行链表的树化。</p></li><li><p>若链表中某个节点的key与待存入数据的key相等（与第3步的判断条件一样），则退出遍历。</p></li><li><p>判断之前是否已经存在key值相同的节点，若是此时根据onlyIfAbsent参数来决定是否将之前节点的值更新为本次要插入的值（实际上map默认的put操作该值为true,表明是覆盖插入）</p></li><li><p>判断是否要进行扩容操作， 若是则调用<code>resize()</code>函数进行扩容。注意此处的++resize操作可能导致线程不安全。</p></li></ol><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>resize()函数。该函数有两个用途：</p><ul><li>创建初始的存储数组</li><li>容量不足的时候， 进行扩容</li></ul><p>下面是resize函数关键几步分析：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210324180901686.png" alt="image-20210324180901686"></p><p>基本流程：</p><ol><li>当扩容之前的数组长度大于最大值时，直接返回未扩容之前数组（也就是不进行扩容），<strong>此处表明当HashMap容量达到最大值时（Integer.MAX_VALUE)，继续插入新值虽然不会报错， 但实际上并没有生效， 返回的仍是原数组。</strong></li><li>当元素个数大于阈值（默认初始容量16 * 负载因子0.75 &#x3D; 12）时进行扩容，将新数组长度和阈值都扩大为原先2倍</li><li>能进入该分支表明是第一次初始化，设置数组容量大小（指定值或者默认值）和阈值大小</li><li>重新初始化一个新的数组，数组长度是原先的2倍</li><li><strong>开始进行重哈希</strong>，<strong>将原数组项的数据重新放入新的数组项里面，这是扩容时最主要消耗时间的地方</strong>。此处需要遍历原数组， 具体情况如下：<ol><li>6处表明当前下标处没有值，则直接将元素插入到新数组项中</li><li>7处表明当前数组项是一个红黑树，进行红黑树的重新赋值</li><li>8处，当以上两种情况都不符合，肯定是链表节点，则进行链表的重哈希，需要遍历链表</li></ol></li></ol><p><strong>链表节点的重哈希</strong> 有必要说明一下，此处设计的比较巧妙,具体描述可见文章：<a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p><p>JDK中解释resize函数的说明大意如下：</p><blockquote><p>当进行扩容时，因为我们每次扩容容量都是之前的2倍，任意元素在新数组中要么是原先的位置，要么是原位置移动2次幂的位置。</p></blockquote><p>其具体原理是利用0与0或者1进行&amp;运算结果都是0，这样在进行重hash的时候，<strong>不需要重新计算Hash值</strong>，只需要判断原先的Hash值新增的那一位是0还是1，若为0，则原先位置，若为1，则索引变为“oldCap+原索引”。</p><p>这地方有几点需要注意：</p><ol><li>判断索引是否改变用的是 <strong>hash &amp; oldCap</strong>，此处与计算索引值**(n - 1) &amp; hash**需要区分开来</li></ol><h2 id="链表转化红黑树"><a href="#链表转化红黑树" class="headerlink" title="链表转化红黑树"></a>链表转化红黑树</h2><p>treeifyBin()函数。在链表长度超过8的时候，使用该函数将链表转化为红黑树。</p><p>其主要思路如下：</p><ol><li>当整个数组桶的长度小于64时，此时并不会进行树化操作，只是进行扩容。注意，在进行扩容的时候，链表的长度有可能会变短</li><li>将链表中的节点转化为树节点TreeNode，形成一个新的链表</li><li>将新链表节点赋值给给定的数组项</li><li>调用TreeNode的treefify()方法将该处的链表转化为红黑树，该函数大致步骤如下：<ol><li>插入树节点元素，具体可以参考二叉搜索树的插入操作。在进行插入的时候，比较key的hash值来决定插入的方向。</li><li>插入完成之后开始调整红黑树，使其符合红黑树的特性</li></ol></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>getNode()函数。提供常数时间复杂度的查找效率。</p><ol><li><p>根据<code>(n - 1) &amp; hash</code>计算得到该key所在的桶bucket，若桶不存在或者数组table为空，则直接返回null，根据这一点我们可以知道HashMap取元素的方法get和判断元素是否存在的<code>contanins</code>方法的时间复杂度都是O(1)</p></li><li><p>当桶存在时，首先判断该桶上第一个节点是否就是要找的节点（大部分情况下都是），若是直接返回该节点值</p></li><li><p>若不是，判断节点类型，若是红黑树，则遍历红黑树查找，若是链表，则遍历链表查找</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java大图片压缩与裁剪时防止oom</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/java%E5%A4%A7%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A3%81%E5%89%AA%E6%97%B6%E9%98%B2%E6%AD%A2oom.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/java%E5%A4%A7%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A3%81%E5%89%AA%E6%97%B6%E9%98%B2%E6%AD%A2oom.html</url>
    
    <content type="html"><![CDATA[<p>常规使用java进行图片裁剪或压缩的时候， 比如使用<code>ImageIO.read()</code>读取图片信息的时候， 或者使用<code>Thumb nails</code>框架进行压缩时， 都会调用<code>DataBufferByte</code>类的下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DataBuffe<br><span class="hljs-title function_">rByte</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> numBanks)</span> &#123;<br>        <span class="hljs-built_in">super</span>(STABLE, TYPE_BYTE, size, numBanks);<br>        bankdata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[numBanks][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; numBanks; i++) &#123;<br>            <span class="hljs-comment">// 构造数组</span><br>            bankdata[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>        &#125;<br>        data = bankdata[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>当图片像素很大时， size的值会很大， 此时构造这个数据就有可能会出现oom，比如当一张6.4M的图片， 宽高是5472*7296， size的值是114M。</p><p>基于此， 可以基于采样的方式进行， 不需要引用任何第三方库， 具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] resize(<span class="hljs-type">byte</span>[] srcFileData, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height) &#123;<br>    <span class="hljs-type">ImageInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ImageReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        input = ImageIO.createImageInputStream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(srcFileData));<br>        Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(input);<br>        reader = readers.next();<br>        reader.setInput(input);<br>        <span class="hljs-comment">//原始图像的长和宽</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">srcWidth</span> <span class="hljs-operator">=</span> reader.getWidth(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">srcHeight</span> <span class="hljs-operator">=</span> reader.getHeight(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">ImageReadParam</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> reader.getDefaultReadParam();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sampling</span> <span class="hljs-operator">=</span> Math.min(srcWidth/width, srcHeight/height);<br>        <span class="hljs-comment">//采样压缩, 其中sampling的值表示每隔多少个像素点取一个像素</span><br>        param.setSourceSubsampling(sampling, sampling, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 裁剪</span><br>        param.setSourceRegion(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, srcWidth, srcHeight));<br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bufferedImage</span> <span class="hljs-operator">=</span> reader.read(<span class="hljs-number">0</span>, param);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        ImageIO.write(bufferedImage, <span class="hljs-string">&quot;jpg&quot;</span>, outputStream);<br>        <span class="hljs-keyword">return</span> outputStream.toByteArray();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            input.close();<br>            <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>)&#123;<br>                reader.dispose();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;&#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arthas中如何获取Bean</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/arthas%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Spring%E4%B8%AD%E7%9A%84Bean.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/arthas%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Spring%E4%B8%AD%E7%9A%84Bean.html</url>
    
    <content type="html"><![CDATA[<p>现在大部分应用都是通过Spring来管理对象， 在使用arthas分析线上问题时， 如何获取Spring中已经注入到容器中的Bean， 主要是使用tt命令。</p><p>首先执行如下命令，等待输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3<br></code></pre></td></tr></table></figure><p>假设要搜索的类名为<code>com.example.DemoService</code>， 注意此处需要使用类的全限定名。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tt -i <span class="hljs-number">1000</span> -w &#x27;target.get<span class="hljs-constructor">ApplicationContext()</span>.get<span class="hljs-constructor">Bean(<span class="hljs-string">&quot;com.example.DemoService&quot;</span>)</span>.get<span class="hljs-constructor">TargetSource()</span>.target&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>arthas</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中文件权限说明</title>
    <link href="/%E7%BC%96%E7%A8%8B/linux/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E.html"/>
    <url>/%E7%BC%96%E7%A8%8B/linux/Linux%E4%B8%AD%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E.html</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Linux下的文件权限包括读， 写， 执行， 英文简写分别是 <code>r</code>, <code>w</code>, <code>x</code></li><li>文件权限包含三个方面： 拥有者， 用户组， 其他组。每个文件可分别对这三个方面设置不同的rwx权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li></ul><h1 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h1><p><code>ls -l</code></p><p>输出格式如下：</p><p><code>-rw-r--r-- 1 root root 25934 Jun 26 10:35 X120</code></p><p>其中第一列除了第一个表示文件类型外， 剩下9个则表示该文件在上面三个粒度下的权限，具体信息</p><ul><li>2,3,4列表示文件所有者权限</li><li>5,6,7列表示该文件所属用户组的权限</li><li>7,8,9列表示其他组的权限</li></ul><h1 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h1><p><code>chmod</code>命令， 其参数如下：</p><ul><li>-R  以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更</li></ul><p>下面只介绍一下使用数字来表示的权限使用方法。</p><p>基本规定如下：</p><ul><li>4 读r</li><li>2 写w</li><li>1 执行x</li></ul><p>其他的权限组合用这几个进行相加就行， 示例如下：</p><ul><li>7  可读+可写+可执行 rwx  （4+2+1&#x3D;7）</li><li>6 可读+可写 rw-（4+2&#x3D;6）</li><li>5 可读+可执行 r-x（4+1&#x3D;5)</li></ul><p>在使用数字进行设置权限的时候， 其语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [可选项] &lt;abc&gt; file<br></code></pre></td></tr></table></figure><p>其三位数字分别表示拥有者，群组， 其他组的权限详情，也就是a代表拥有者权限，b代表群组权限， c代表其他权限。</p><p>例如： <code>chmod 777 file</code>则表示所有用户都有读写和执行的权限（当然这是比较危险的）</p><p>下面列举一下常见的权限表现形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw------- (600)    只有拥有者有读写权限。<br>-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。<br>-rwx------ (700)    只有拥有者有读、写、执行权限。<br>-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。<br>-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。<br>-rw-rw-rw- (666)    所有用户都有文件读、写权限。<br>-rwxrwxrwx (777)    所有用户都有读、写、执行权限。<br></code></pre></td></tr></table></figure><h1 id="更改文件所有者"><a href="#更改文件所有者" class="headerlink" title="更改文件所有者"></a>更改文件所有者</h1><p>语法</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">chown [-hvR] user[:group] file...<br></code></pre></td></tr></table></figure><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li><li>-h :修复符号链接</li><li><strong>-R : 处理指定目录以及其子目录下的所有文件</strong></li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件的所有者设置为root</span><br>chown root file<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件拥有者设为rob, 组设置为robGroup</span><br>chown rob:robGroup file<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅改变文件的组设置为512（组ID）， 不改变所有者</span><br>chown :512 file<br></code></pre></td></tr></table></figure><p>顺便说一下查看用户组ID的命令：</p><p><code>id</code></p><p><code>cat /etc/password</code></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装confluence</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/docker%E5%AE%89%E8%A3%85confluence.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/docker%E5%AE%89%E8%A3%85confluence.html</url>
    
    <content type="html"><![CDATA[<p>自己搭建一个confluence wiki，现记录一下搭建过程和其中需要注意的点。</p><h1 id="编写docker-compose"><a href="#编写docker-compose" class="headerlink" title="编写docker-compose"></a>编写docker-compose</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">confluence-db</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;15202:5432&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=123456</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/confluence/pgsql-data:/var/lib/postgresql/data</span><br><br>  <span class="hljs-attr">confluence:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">cptactionhank/atlassian-confluence:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">confluence</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;15200:8090&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;15201:8091&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/confluence/logs:/opt/atlassian/confluence/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/confluence/confluence-data:/var/atlassian/confluence</span><br></code></pre></td></tr></table></figure><p>启动 <code>docker-compose up -d</code></p><p>注意此处<code>/opt/docker/confluence/confluence-data</code>是没有权限的， 按照网上的修改文件夹权限 <code>chown -R daemon.daemon confluence-data </code>也不管用， 不得已先直接777赋权， 以后再研究下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 777 confluence-data<br></code></pre></td></tr></table></figure><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><ol><li><p>从此处下载破解文件： <a href="https://www.jianguoyun.com/p/DalHveAQqo6RCBjo1KIE">https://www.jianguoyun.com/p/DalHveAQqo6RCBjo1KIE</a> </p></li><li><p>解压， 在命令行执行<code>java -jar confluence_keygen.jar</code></p></li><li><p>在弹出窗中输入Server ID, 点击 <code>.gen!</code>, 将产生的授权码复制下来备用</p></li><li><p>将已经启动好的confluence容器中的<code>atlassian-extras-decoder-v2-3.4.1.jar</code>文件复制出来并重命名,  并下载到本地</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp confluence:<span class="hljs-regexp">/opt/</span>atlassian<span class="hljs-regexp">/confluence/</span>confluence<span class="hljs-regexp">/WEB-INF/</span>lib<span class="hljs-regexp">/atlassian-extras-decoder-v2-3.4.1.jar ./</span>atlassian-extras-<span class="hljs-number">2.4</span>.jar<br></code></pre></td></tr></table></figure></li><li><p>在之前弹出窗口中点击<code>.patch!</code>按钮， 并选择刚刚下载的atlassian-extras-2.4.jar文件， 当显示<code>jar successfully patched</code>则表示patch成功</p></li><li><p>重新将atlassian-extras-2.4.jar文件命名为atlassian-extras-decoder-v2-3.4.1.jar， 并复制到容器内部</p></li><li><p>重启confluence容器</p></li></ol><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>docker进入Postgres容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> confluence-db bash<br></code></pre></td></tr></table></figure><p>依次执行以下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">psql -U postgres<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> confluence <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">OWNER</span> postgres;<br></code></pre></td></tr></table></figure><p>然后重启容器即可</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>confluence</tag>
      
      <tag>折腾</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 20.04 kvm安装windows</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/ubuntu%2020.04%20kvm%E5%AE%89%E8%A3%85windows.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/ubuntu%2020.04%20kvm%E5%AE%89%E8%A3%85windows.html</url>
    
    <content type="html"><![CDATA[<p>记录一下kvm安装windows过程中的步骤以及注意点。</p><p>先说明一下环境：</p><ul><li>host： ubuntu server 20.04</li><li>vm:  windows server 2019</li></ul><h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><ol><li>winddows server 2019 的镜像： 可以去msdn I tell you上下载</li><li>virtio驱动：注意windows server 2019对应的是0.1.171， 下载其中的<code>virtio-win-0.1.171_amd64.vfd</code>文件  ： <a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.171-1/">下载地址</a></li></ol><h1 id="安装kvm"><a href="#安装kvm" class="headerlink" title="安装kvm"></a>安装kvm</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager<br></code></pre></td></tr></table></figure><h1 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h1><p>这里使用桥接模式， 这样就可以保证虚拟出来的windows server与主机是平级的， 其他设备和该虚拟机能够互通。</p><p>编辑文件 <code>/etc/netplan/00-installer-config.yaml</code>(每个人在&#x2F;etc&#x2F;netpaln下的文件名可能不一样)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>      <br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eno1:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">enp2s0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.239</span><span class="hljs-string">/24</span>]<br>      <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>]<br>  <span class="hljs-attr">bridges:</span><br>    <span class="hljs-attr">br2:</span><br>      <span class="hljs-attr">interfaces:</span> [<span class="hljs-string">enp2s0</span>]<br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.240</span><span class="hljs-string">/24</span>]<br>      <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>] <br></code></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>eno1是另外一个网卡， 没用， 可以不用配置</li><li><strong>此处使用的是网卡是enp2s0</strong></li><li>设置桥接的关键是bridges配置， 此处指定了虚拟机的IP： 10.0.0.240， 后续都会用这个IP来访问虚拟机</li></ul><p>编辑保存完之后， 执行<code>sudo netplan apply</code></p><h1 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h1><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><ol><li>新建文件夹 <code>mkdir -p /opt/kvm/ws2019</code></li><li>将之前准备好的windows server镜像文件和virtio驱动文件上传到该文件夹下， 例如：<ol><li>cn_windows_server_2019_updated_march_2019_x64_dvd_c1ffb46c.iso</li><li>virtio-win-0.1.171_amd64.vfd</li></ol></li></ol><h2 id="创建虚拟硬盘文件"><a href="#创建虚拟硬盘文件" class="headerlink" title="创建虚拟硬盘文件"></a>创建虚拟硬盘文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-img create -f qcow2 /opt/kvm/ws2019/win_server_2019.qcow2 50G<br></code></pre></td></tr></table></figure><p>此处创建的虚拟硬盘大小为50G。</p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">virt-install \<br>--name win_server_2019 \<br>--memory 4096 \<br>--vcpus sockets=2,cores=2,threads=1 \<br>--cdrom=/opt/kvm/ws2019/cn_windows_server_2019_updated_march_2019_x64_dvd_c1ffb46c.iso \<br>--os-type=windows \<br>--os-variant=auto \<br>--disk /opt/kvm/ws2019/win_server_2019.qcow2,bus=virtio,size=50 \<br>--disk /opt/kvm/ws2019/virtio-win-0.1.171_amd64.vfd,device=floppy \<br>--network bridge=br2,model=virtio \<br>--graphics vnc,password=12358,listen=::,port=5910 \<br>--hvm \<br>--virt-type kvm<br></code></pre></td></tr></table></figure><p>对其中几项进行说明：</p><ul><li>分配给虚拟机的vCPU个数由sockets、cores、threads三个参数的乘积来控制，sockets指代CPU插槽数目，cores指代每个插槽芯片的核心数，threads指代那个核心的超线程，如上所示创建的虚拟机共有4个逻辑cpu。</li><li>network中填的网络名就是配置桥接网络时指定的名称。</li><li>listen 指代的是虚拟机的VNC监听接口，默认是localhost，<code>0:0:0:0</code>指带所有的IPv4接口，<code>::</code>指代所有接口，包括IPv4和IPv6。<strong>password是vnc连接的密码</strong>， port是vnc连接的端口</li><li>顺便说一下， 如果要安装linux虚拟机， 需要将os-type设置为<code>linux</code></li></ul><h2 id="windows-server-安装"><a href="#windows-server-安装" class="headerlink" title="windows server 安装"></a>windows server 安装</h2><ol><li>使用vnc软件连接虚拟机，例如MobaXterm,  地址： 10.0.0.240， 密码：12358,  端口：5910</li><li>进入windows server安装界面，使用自定义， 安装过程会出现看不见磁盘的情况，是因为没有加载virtio驱动的原因。<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20220216090809661.png" alt="image-20220216090809661"></li><li>选择“加载驱动”，“浏览”，找到“软盘驱动器”，选择 amd64 -&gt; Win10,  然后点击确定， 会发现有两个驱动，一个是Ethernet网卡，一个SCSI磁盘，操作两次驱动加载完成后，磁盘就出现了，继续安装即可。<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20220216090828118.png" alt="image-20220216090828118"></li></ol><p><strong>注意</strong>：在安装的过程中， 可能会出现无法连接的问题， 不要慌， 按如下步骤执行</p><ol><li><code>virsh undefine [name] </code>    name是虚拟机名称</li><li>然后继续执行之前的virt-install命令</li></ol><h1 id="虚拟机管理常用命令"><a href="#虚拟机管理常用命令" class="headerlink" title="虚拟机管理常用命令"></a>虚拟机管理常用命令</h1><p>可通过lib-virt的<code>virsh</code>来完成虚拟机生命周期管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看虚拟机运行状态</span><br>virsh list [-all]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>virsh start [name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关机</span><br>virsh shutdown [name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">暂停（挂起）</span><br>virsh suspend [name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除</span><br>virsh destroy [name]<br></code></pre></td></tr></table></figure><p>要彻底删除某个虚拟机， 需要如下几个步骤：</p><ul><li>virsh destroy [name]</li><li>删除&#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;下的同名xml文件</li><li>重启libvirt服务 service libvirtd restart</li><li>删除创建的虚拟硬盘文件</li></ul><h1 id="修改已有虚拟机配置"><a href="#修改已有虚拟机配置" class="headerlink" title="修改已有虚拟机配置"></a>修改已有虚拟机配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭虚拟机</span><br>virsh shutdown [name]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑， 首次需要选择编辑器</span><br>virsh edit [name]<br></code></pre></td></tr></table></figure><p>参考资料：</p><ol><li><a href="https://ylong.net.cn/KVM_install_windows.html">https://ylong.net.cn/KVM_install_windows.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>kvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红米AC2100刷pandavan及设置无线中继</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E7%BA%A2%E7%B1%B3AC2100%E5%88%B7pandavan%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E7%BA%A2%E7%B1%B3AC2100%E5%88%B7pandavan%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7.html</url>
    
    <content type="html"><![CDATA[<h3 id="获取SSH权限"><a href="#获取SSH权限" class="headerlink" title="获取SSH权限"></a>获取SSH权限</h3><ul><li><p>打开本地浏览器输入192.168.31.1并登陆。</p></li><li><p>右上角选择固件升级， 升级到有漏洞版本2.0.7（ miwifi_rm2100_firmware_d6234_2.0.7.bin）</p></li><li><p>刷完重启后重新输入192.168.31.1登陆管理页，此时的浏览器地址栏如下（<strong>注意stock&#x3D;后面的值每个人是不一样的</strong>）：</p><p><code>http://192.168.31.1/cgi-bin/luci/;stok=ODJ893023kd2344224kdF/web/home#router</code></p></li><li><p>将<code>stok=ODJ893023kd2344224kdF</code>显示的值 复制替换到如下链接对应位置并浏览器打开：<br><code>http://192.168.31.1/cgi-bin/luci/;stok=你浏览器显示的值/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></p></li><li><p>此时就已打开了SSH，继续按照上面方法替换stok&#x3D;你浏览器显示的值如下链接并打开，自动修改ssh密码为admin。<br><code>http://192.168.31.1/cgi-bin/luci/;stok=你浏览器显示的值/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20&#39;admin%5Cnadmin&#39;%20%7C%20passwd%20root%3B</code></p></li></ul><h3 id="刷Breed"><a href="#刷Breed" class="headerlink" title="刷Breed"></a>刷Breed</h3><ul><li><p>使用ssh登录路由器：</p><ul><li>IP： 192.168.31.1</li><li>用户名： root</li><li>密码：admin</li></ul></li><li><p>下载breed固件并上传到路由器（breed-mt7621-xiaomi-r3g.bin）</p></li><li><p>执行如下命令， 并等待20s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mtd -r write breed-mt7621-xiaomi-r3g.bin Bootloader<br></code></pre></td></tr></table></figure></li></ul><h3 id="进入breed"><a href="#进入breed" class="headerlink" title="进入breed"></a>进入breed</h3><p><strong>先断电，然后找个针戳住路由器背后Reset小孔并插电，等路由器蓝灯一直闪烁后，浏览器输入192.168.1.1即可进入breed网页。</strong></p><h3 id="更改环境变量"><a href="#更改环境变量" class="headerlink" title="更改环境变量"></a>更改环境变量</h3><p>找到环境变量增加：xiaomi.r3g.bootfw 值：2 然后保存。<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20211021232125527.png" alt="image-20211021232125527"></p><h3 id="刷固件"><a href="#刷固件" class="headerlink" title="刷固件"></a>刷固件</h3><ul><li>进入breed网页， 清除数据（恢复出厂设置，也可不做， 一般要做， 防止未知问题)</li><li>点击固件更新 -&gt; 选择固件， 上传固件包（R2100_3.4.3.9-099.trx），  然后安装即可。</li><li>刷完之后的路由器IP：192.168.31.1 ， 用户名密码： admin&#x2F;admin</li></ul><h3 id="设置无线中继"><a href="#设置无线中继" class="headerlink" title="设置无线中继"></a>设置无线中继</h3><p>（好像使用5G来设置中继的话效果更好， 没有做进一步测试）</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20211021233148027.png" alt="image-20211021233148027"></p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>设置内网与上级网络分别属于不同网络<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20211021233537031.png" alt="image-20211021233537031"></p><p>上述文件下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/1Hd6Q8lbYHRcWArt2YfPYaQ">https://pan.baidu.com/s/1Hd6Q8lbYHRcWArt2YfPYaQ</a><br>提取码：8u65</p><p>参考资料：</p><ul><li><a href="http://openwrt.ink:88/archives/s-breed">http://openwrt.ink:88/archives/s-breed</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring中的设计模式</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<p>本文结合spingboot的源码描述一下spring中运用到的几种点典型的设计模式。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight plaintext"><figcaption><span>本身也能产生bean, 例如其中一个实现类：```AbstractFactoryBean```,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs FactoryBean```是一个接口，它不仅本身是一个Bean,"><br>getObject()方法源码如下：<br><br>```java<br>@Override<br>public final T getObject() throws Exception &#123;<br>        //单例从缓存中获取或者暴露引用（用来解决循环引用）<br>if (isSingleton()) &#123;<br>return (this.initialized ? this.singletonInstance : getEarlySingletonInstance());<br>&#125;<br>else &#123;<br>            //创建实例<br>return createInstance();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其最终创建实例的方法是createInstance, 该方法由其子类工厂去实现， 具体的子类有如下几种：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20211005202023477.png" alt="image-20211005202023477"></p><p>例如mybatis的SqlSessionFactoryBean就是实现了该接口。</p><p>这里有必要说明一下<code>BeanFactory</code>和<code>FactoryBean</code>的区别：</p><ul><li>BeanFactory是Spring工厂中的顶层规范，Spring中的容器都是它的具体实现， 例如常见的<code>ApplicationContext</code></li><li>FactoryBean是一个能生产或修饰对象生成的工厂Bean， 它本身也是一个bean, 由BeanFactory管理</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>从Spring容器中获取的bean, 默认情况下是单实例的， 其具体实现在<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</code>, 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123; <span class="hljs-comment">//使用锁保证多线程同步竞争</span><br>                 <span class="hljs-comment">//如果此bean正在加载，则不处理</span><br>singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>singletonObject = singletonFactory.getObject();<br>                        <span class="hljs-comment">//记录在缓存中，earlysingletonObjects和singletonFactories互斥（用来解决循环依赖）</span><br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>策略模式用于封装系列的算法，这些算法通常被封装在一个 Context 类中，客户端程序可以自由选择其中一种算法，或让 Context 为客户端选择一个最佳的算法 —— 使用策略模式的优势是为了支持算法的自由切换。</p></blockquote><p>Spring中的<code>Resource</code>接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p><p>Resouce接口本身并没有提供任何访问底层资源的逻辑， 针对不同的资源， spring提供了不同的实现类来负责对应的资源访问逻辑。具体如下：</p><ul><li><strong>UrlResource：</strong> 访问网络资源</li><li><strong>ClassPathResource：</strong> 访问类加载路径里资源</li><li><strong>FileSystemResource：</strong> 访问文件系统里资源</li><li><strong>ServletContextResource：</strong> 访问相对于 ServletContext 路径里的资源</li><li><strong>InputStreamResource：</strong> 访问输入流资源</li><li><strong>ByteArrayResource：</strong> 访问字节数组资源</li></ul><p>具体spring该使用哪个实现类， 其中就用到了策略模式的思想。</p><p>Spring提供了如下两个接口：</p><ul><li><strong>ResourceLoader:</strong>  获取一个Resouce实例</li><li><strong>ResourceLoaderAware</strong>： 获取一个ResourceLoader的引用</li></ul><p>当 Spring 应用需要进行资源访问时，实际上并不需要直接使用 Resource 实现类，而是调用 ApplicationContext 实例的 <code>getResource ()</code> 方法来获得资源，ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来，这就体现了策略模式的优势。</p><p>下图是ApplicationContext接口， 可以看到它继承了ResourceLoader接口， 同时也就拥有了该接口的所有方法。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/ApplicationContext.png" alt="ApplicationContext"></p><p>此处 Spring 框架的 ApplicationContext 不仅是 Spring 容器，而且它还是资源访问策略的 “决策者”，也就是策略模式中 Context 对象，它将为客户端代码 “智能” 地选择策略实现。</p><p>当 ApplicationContext 实例获取 Resource 实例时，系统将默认采用与 ApplicationContext 相同的资源访问策略。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot启动流程及原理剖析</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<p>SpringBoot应用打出的jar包， 是可以直接使用 <code>java -jar XXX.jar</code> 命令直接启动的， 那么背后的原理是怎样的？</p><h3 id="JarLauncher"><a href="#JarLauncher" class="headerlink" title="JarLauncher"></a>JarLauncher</h3><h4 id="jar包结构"><a href="#jar包结构" class="headerlink" title="jar包结构"></a>jar包结构</h4><p>首先先看一下springboot的jar包结构是什么样的。</p><p>新建一个springboot工程（可以直接使用idea自带的Spring Initializer创建）， 然后使用<code>mvn clean package</code>打包， 使用压缩软件打开jar包， 观察其内部结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── BOOT-INF<br>│   ├── classes<br>│   │   ├── application<span class="hljs-selector-class">.properties</span><br>│   │   ├── cn<br>│   │   ├── static<br>│   │   └── templates<br>│   └── lib<br>│       ├── spring-core-<span class="hljs-number">5.2</span>.<span class="hljs-number">2</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>│       ├── spring-webmvc-<span class="hljs-number">5.2</span>.<span class="hljs-number">2</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>│       ├── ...<span class="hljs-comment">// 这里略了大量jar包</span><br>├── META-INF<br>│   └── MANIFEST<span class="hljs-selector-class">.MF</span><br>└── org<br>    └── springframework<br>        └── boot <br></code></pre></td></tr></table></figure><p>现在分别说明如下：</p><ol><li><strong>MANIFEST.MF</strong> 该文件描述了jar包的一些关键信息， 其中<code>Main-Class</code>指定了启动类， 在springboot应用中该项是<code>org.springframework.boot.loader.JarLauncher</code>, 该类后续还要深入分析</li><li>BOOT-INF&#x2F;classes 工程的源代码编译完成后的class文件</li><li>BOOT-INF&#x2F;lib 工程依赖的第三方jar包文件</li><li>org 目录： Spring Boot loader 相关的源代码，其中的<code>JarLauncher</code>就放在此处</li></ol><h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><h5 id="Launcher-1"><a href="#Launcher-1" class="headerlink" title="Launcher"></a><strong>Launcher</strong></h5><p>各种 Launcher 的基础抽象类，用于启动应用程序，跟 Archive 配合使用。</p><p>目前有三种实现：</p><ul><li>JarLauncher</li><li>WarLauncher</li><li>PropertiesLauncher</li></ul><h5 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h5><p>归档文件的基础抽象类。</p><ul><li>JarFileArchive 就是 jar 包文件的抽象。它提供了一些方法比如 getUrl 会返回这个 Archive 对应的 URL。getManifest 方法会获得 Manifest 数据等。</li><li>ExplodedArchive 是文件目录的抽象。</li></ul><h5 id="JarFile"><a href="#JarFile" class="headerlink" title="JarFile"></a>JarFile</h5><p>对 jar 包的封装，每个 JarFileArchive 都会对应一个 JarFile。JarFile 被构造的时候会解析内部结构，去获取 jar 包里的各个文件或文件夹，这些文件或文件夹会被封装到 Entry 中，也存储在 JarFileArchive 中。如果 Entry 是个 jar，会解析成 JarFileArchive。</p><p>在执行<code>java jar XXX.jar</code>的时候， 首先触发的是 <code>org.springframework.boot.loader.jar.Handler</code>的main方法， 而不是我们自定义的XXXApplication。</p><p>这里需要注意一点， 直接在idea中搜索<code>JarLauncher</code>这个类是搜不到的， 是因为该类是在编译的时候直接导入到Jar包中的， 如果需要看源码， 需要在pom文件中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-loader<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从JarLauncher的main方法开始进行分析，其主要流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">launch</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (!isExploded()) &#123;<br>            JarFile.registerUrlProtocolHandler();<br>        &#125;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> createClassLoader(getClassPathArchivesIterator());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jarMode</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;jarmode&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">launchClass</span> <span class="hljs-operator">=</span> (jarMode != <span class="hljs-literal">null</span> &amp;&amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();<br>        launch(args, launchClass, classLoader);<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>创建一个自定义类加载器 LaunchedURLClassLoader，遵循双亲委派机制，对于父类无法加载的类，则由 LaunchedURLClassLoader 进行加载，其加载的路径包括 BOOT-INF&#x2F;lib 和 BOOT-INF&#x2F;classes</li><li>调用<code>Thread.currentThread().setContextClassLoader(classLoader)</code>将其设置为线程上下文加载器</li><li>反射执行我们自定义的springboot启动类的main方法，也就是使用<code>@SpringBootApplication</code>注解的类</li></ol><p>一个普通的springboot项目一般都是使用如下方式来启动的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看到主要是一个@SpringBootApplication注解和SpringApplication的run()方法。下面对这两个进行详细解释。</p><h3 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="SpringBootApplication注解"></a>SpringBootApplication注解</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Inherited</span><br><span class="hljs-variable">@SpringBootConfiguration</span><br><span class="hljs-variable">@EnableAutoConfiguration</span><br><span class="hljs-variable">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-variable">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),<br>        <span class="hljs-variable">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)<br></code></pre></td></tr></table></figure><p>该注解主要由三个注解组合而成，其他的都是常规注解， 分别是：</p><ul><li>@ComponentScan</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>该注解的主要作用是用来进行包扫描， 从而创建bean。</p><p>其中有一个<code>AutoConfigurationExcludeFilter</code>， 其作用是用来进行包扫描的时候排除自动配置的类， 简而言之不扫描自动配置类。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>该注解是SpringBoot中用来实现自动装配的关键。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Inherited</span><br><span class="hljs-variable">@AutoConfigurationPackage</span><br><span class="hljs-variable">@Import</span>(AutoConfigurationImportSelector.class)<br></code></pre></td></tr></table></figure><p>这里重点关注的是<code>@Import(AutoConfigurationImportSelector.class)</code>这一行， 该注解的作用分为如下三点：</p><ul><li>导入被<code>@Configuration</code>修饰的配置类</li><li>导入实现了<code>ImportSelector</code>接口的配置类</li><li>导入实现了<code>ImportBeanDefinitionRegistar</code>接口的配置类</li></ul><p>该注解最终调用的是SpringFactoriesLoader类中的loadSpringFactories()方法， 此方法会加载在META-INF&#x2F;spring.factories中已经定义好的配置类。</p><p>从而通过此注解， 实现将所有的配置类自动装载到spring容器中去。</p><p>下面是springboot 2.1.3版本中autoconfigure模块该文件部分内容：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># Initializers</span><br><span class="hljs-keyword">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># Application Listeners</span><br><span class="hljs-keyword">org.springframework.context.ApplicationListener=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># Auto Configuration Import Listeners</span><br><span class="hljs-keyword">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># Auto Configuration Import Filters</span><br><span class="hljs-keyword">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># Auto Configure</span><br><span class="hljs-keyword">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="hljs-keyword"></span>----此处省略-----<br><br><span class="hljs-comment"># Failure analyzers</span><br><span class="hljs-keyword">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># Template availability providers</span><br><span class="hljs-keyword">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></code></pre></td></tr></table></figure><p>综上， @SpringBootApplication注解的主要作用总结如下：</p><ul><li>实现自动配置</li><li>定义需要加载到spring容器中的bean</li></ul><h3 id="SpringApplication类"><a href="#SpringApplication类" class="headerlink" title="SpringApplication类"></a>SpringApplication类</h3><p><code>SpringApplication.run()</code>方法主要分为两步：</p><ol><li>构造SpringApplication对象</li><li>执行该对象的run方法</li></ol><p>下面分别就这两步进行说明。</p><h4 id="构造SpringApplication对象"><a href="#构造SpringApplication对象" class="headerlink" title="构造SpringApplication对象"></a>构造SpringApplication对象</h4><p>跟踪SpringApplication类实例初始化最终代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;<br>        <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>        Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<br>    <br>         <span class="hljs-comment">// 设置应用类型</span><br>        <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>        <span class="hljs-comment">//  设置初始化</span><br>        setInitializers((Collection) getSpringFactoriesInstances(<br>                ApplicationContextInitializer.<span class="hljs-keyword">class</span>));<br>       <span class="hljs-comment">// 设置事件监听器</span><br>        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.<span class="hljs-keyword">class</span>));<br>        <span class="hljs-comment">// 找出main方法所属的类</span><br>        <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>    &#125;<br></code></pre></td></tr></table></figure><p>就其中关键的几个步骤进行说明</p><h5 id="设置应用类型"><a href="#设置应用类型" class="headerlink" title="设置应用类型"></a>设置应用类型</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">this.webApplicationType</span> = WebApplicationType.deduceFromClasspath()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>应用类型共分为三种， 分别如下：</p><ol><li><code>NONE</code>：正常流程走，不额外的启动web容器, 比如<code>Tomcat</code>。</li><li><code>SERVLET</code>：基于<code>servlet</code>的web程序，需要启动内嵌的<code>servlet</code>web容器，比如<code>Tomcat</code>。</li><li><code>REACTIVE</code>：基于<code>reactive</code>的web程序，需要启动内嵌<code>reactive</code>web容器</li></ol><p>通过判断是否加载了对应的类，比如加载了<code>DispatcherServlet</code>等则会判断是<code>Servlet</code>的web程序, 比如引用了<strong>spring-boot-starter-web</strong>模块， 则 是web程序。</p><h5 id="设置初始化器"><a href="#设置初始化器" class="headerlink" title="设置初始化器"></a>设置初始化器</h5><blockquote><p>初始化器<code>ApplicationContextInitializer</code>， 用于Spring的IOC容器在刷新之前， 进行一些组件的初始化， 比如<code>ServletContextApplicationContextInitializer</code>。</p></blockquote><p>其最终调用是<code>SpringFactoriesLoader.loadSpringFactories()</code>方法， 该方法同@EnableAutoConfiguration注解作用类似， 会从<code>META-INF/spring.factories</code>中加载定义好的类，此处对应的key是 <code>org.springframework.context.ApplicationContextInitializer</code>。</p><p>例如在spring-boot-autoconfigure模块该值对应如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># Initializers</span><br>org.springframework.context.ApplicationContextInitializer=<span class="hljs-string">\</span><br>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,<span class="hljs-string">\</span><br>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener<br></code></pre></td></tr></table></figure><p>在spring-boot模块该值对应如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># PropertySource Loaders</span><br>org.springframework.boot.<span class="hljs-keyword">env</span>.PropertySourceLoader=\<br>org.springframework.boot.<span class="hljs-keyword">env</span>.PropertiesPropertySourceLoader,\<br>org.springframework.boot.<span class="hljs-keyword">env</span>.YamlPropertySourceLoader<br></code></pre></td></tr></table></figure><p>所以， 实际上的初始化器ApplicationContextInitializer在整个容器中会有多个， 只要实现了<strong>ApplicationContextInitializer</strong>接口并且在spring.factories文件中定义好就行。</p><h5 id="设置事件监听器"><a href="#设置事件监听器" class="headerlink" title="设置事件监听器"></a>设置事件监听器</h5><blockquote><p>监听器<code>ApplicationListener</code>主要是用来监听特定的事件ApplicationEvent, 比如IOC容器的刷新，关闭等。</p></blockquote><p>其实现原理和上面的初始化器类似， 只不过这一次从<code>spring.factories</code>文件中加载的类的key是<code>org.springframework.boot.SpringApplicationRunListener</code></p><h4 id="执行run-方法"><a href="#执行run-方法" class="headerlink" title="执行run()方法"></a>执行run()方法</h4><p>SpringApplication类构造完成之后， 就会调用该类的run()方法， 该方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-comment">//任务执行观察器, 用来记录任务的开始时间和结束时间</span><br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        stopWatch.start();<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        configureHeadlessProperty();<br>        <span class="hljs-comment">//获取运行时监听器（1）</span><br>        <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>        <span class="hljs-comment">//发送应用程序启动事件（2）</span><br>        listeners.starting();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(<br>                    args);<br>          <span class="hljs-comment">// 创建并配置Environment(此时会加载application.yml文件)</span><br>            <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners,<br>                    applicationArguments);<br>            configureIgnoreBeanInfo(environment);<br>          <span class="hljs-comment">//打印banner</span><br>            <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>          <span class="hljs-comment">//创建context</span><br>            context = createApplicationContext();<br>            exceptionReporters = getSpringFactoriesInstances(<br>                    SpringBootExceptionReporter.class,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);<br>         <span class="hljs-comment">//刷新context之前的一些准备工作   </span><br>            prepareContext(context, environment, listeners, applicationArguments,<br>                    printedBanner);<br>           <span class="hljs-comment">//刷新context</span><br>            refreshContext(context);<br>          <span class="hljs-comment">//context刷新完成之后执行额外一些操作</span><br>            afterRefresh(context, applicationArguments);<br>            stopWatch.stop();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)<br>                        .logStarted(getApplicationLog(), stopWatch);<br>            &#125;<br>            <span class="hljs-comment">//发送ApplicationStartingEvent事件</span><br>            listeners.started(context);<br>            callRunners(context, applicationArguments);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            handleRunFailure(context, ex, exceptionReporters, listeners);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//发送ApplicationReadyEvent事件，标志SpringApplication已经正在运行，即已经成功启动，可以接收服务请求。（3）</span><br>            listeners.running(context);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            handleRunFailure(context, ex, exceptionReporters, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>        &#125;<br>        <span class="hljs-comment">//返回context</span><br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="运行时监听器"><a href="#运行时监听器" class="headerlink" title="运行时监听器"></a>运行时监听器</h5><blockquote><p>此处获取的是<code>SpringApplicationRunListeners</code>, 该监听器的作用主要是用来监听应用程序启动过程的, 并将相应的事件广播出去。</p></blockquote><p>首先需要获取， 对应的代码是（1）处的代码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SpringApplicationRunListeners listeners <span class="hljs-operator">=</span> getRunListeners(args)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>类似的， 该类的定义还是在<code>spring.factories</code>文件中， 对应的key为<code>org.springframework.boot.SpringApplicationRunListener</code>, 在spring-boot模块中该值定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span>.SpringApplicationRunListener=\<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.EventPublishingRunListener<br></code></pre></td></tr></table></figure><p>总共定义了如下几个事件类型：</p><ul><li>ApplicationStartedEvent: run方法执行的时候立马执行</li><li>ApplicationEnvironmentPreparedEvent: ApplicationContext创建之前并且环境信息准备好的时候调用</li><li>ApplicationPreparedEvent: ApplicationContext创建完成之后， refresh之前</li><li>ApplicationReadyEvent： ApplicationContext成功启动</li><li>ApplicationFailedEvent： ApplicationContext启动失败</li></ul><p>这里需要需要说明一下此处的SpringApplicationRunListener和在构造SpringApplication对象时创建的ApplicationListener的联系：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/SpringApplicationRunListener%E5%92%8CApplicationListener%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.jpg" alt="SpringApplicationRunListener和ApplicationListener之间关系"></p><h5 id="context的创建"><a href="#context的创建" class="headerlink" title="context的创建"></a>context的创建</h5><p>首先是创建ApplicationContext， 这个过程很简单，就是根据webApplicationType创建相应的ApplicationContxet, 决定是servlet、reactive或者非web应用。</p><p>例如对于一个普通web的springboot工程，其最终的ApplicationContext实现类是：<code>AnnotationConfigServletWebServerApplicationContext</code>,  类结构如下所示：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/AnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p><h5 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a><strong>prepareContext</strong></h5><p>该方法主要做的事如下：</p><ul><li>基本的初始化，如设置Environment</li><li>注册已经有的对象为单例bean, 比如banner</li><li>加载main方法所在的类</li></ul><p>其中加载main方法所在类的关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(ApplicationContext context, Object[] sources)</span> &#123;<br>    <span class="hljs-comment">// 获取BeanDefinition加载器</span><br>    <span class="hljs-type">BeanDefinitionLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanNameGenerator != <span class="hljs-literal">null</span>) &#123;<br>        loader.setBeanNameGenerator(<span class="hljs-built_in">this</span>.beanNameGenerator);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.resourceLoader != <span class="hljs-literal">null</span>) &#123;<br>        loader.setResourceLoader(<span class="hljs-built_in">this</span>.resourceLoader);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.environment != <span class="hljs-literal">null</span>) &#123;<br>        loader.setEnvironment(<span class="hljs-built_in">this</span>.environment);<br>    &#125;<br>    loader.load();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会创建BeanDefinitionLoader， 然后利用该loader将主类的<code>BeanDefinition</code>加载到context中去。</p><p>其中需要说明一下<code>BeanDefinition</code>, Spring的bean的来源有各种方式， 比如xml文件或者注解的方式， 对于这些bean的定义， 每一个都会生成一个相应的<code>BeanDefinition</code>。</p><h5 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a><strong>refresh</strong></h5><p>容器刷新的核心方法。该方法的主要作用是加载其他的BeanDefinition。</p><p>以web程勋为例， 其对应的context是AnnotationConfigEmbeddedWebApplicationContext， 跟踪其方法， 最终是调用其父类AbstractApplicationContext的refresh方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>       <br>      <span class="hljs-comment">//使用synchronized修饰，标识在同一时刻</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// 刷新前准备，设置flag、时间，初始化properties等</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// 获取ApplicationContext中组合的BeanFactory</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 设置类加载器，添加后置处理器等准备</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 供子类实现， 例如web程序中的webApplicationContext会在此处构造ServletContext</span><br>            postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// todo 需要再说明 调用Bean工厂的后置处理器</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 对于实现了BeanFactoryPostProcessor接口的bean进行注册</span><br>            registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 初始化与国际化有关的属性</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// 初始化事件广播器， 对于springboot而言， 之前已经注册过， 所以此处不需要重新注册， 只是从容器中拿出来用即可</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 子类实现</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// 将容器内部的监听器添加到事件广播中</span><br>            registerListeners();<br><br>            <span class="hljs-comment">// 实例化所有的(懒加载的除外)单例Bean，在进行实例化的时候， BeanPostProcessor开始生效</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 发布刷新完毕事件</span><br>            finishRefresh();<br>        &#125;<br><br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;        <br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对上面其中几个关键的步骤进行说明：</p><p><strong>invokeBeanFactoryPostProcessors</strong></p><p>从容器中找出BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的实现类， 然后按照特定的顺序执行。</p><p>注意其中有一个ConfigurationClassPostProcessor的接口， 是BeanDefinitionRegistryPostProcessor的实现类， 该类的作用就是解析所有被以下注解修饰的类</p><ul><li>@Configuration</li><li>@Component</li><li>@ComponentScan</li><li>@Import</li><li>@ImportResource</li></ul><p><strong>registerBeanPostProcessors</strong></p><p>从容器中找出BeanPostProcessor接口的实现类， 在后面的方法finishBeanFactoryInitialization进行bean的实例化的时候， 会执行BeanPostProcessor。</p><p><strong>onRefresh</strong></p><p>子类实现。 例如对于web程序，AnnotationConfigEmbeddedWebApplicationContext会在此处创建内置的servlet容器， 比如常见的Tomcat, Jetty。</p><h5 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners"></a>callRunners</h5><p>该方法会调用所有实现了CommandLineRunner和ApplicationRunner接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> &#123;<br>        List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());<br>        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());<br>        <span class="hljs-comment">//按照定义好的order进行排序</span><br>        AnnotationAwareOrderComparator.sort(runners);<br>        <span class="hljs-comment">//使用LinkedHashSet来保证runner是有序的， 这样就能按照order顺序执行</span><br>        <span class="hljs-keyword">for</span> (Object runner : <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;<br>            <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> ApplicationRunner) &#123;<br>                callRunner((ApplicationRunner) runner, args);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> CommandLineRunner) &#123;<br>                callRunner((CommandLineRunner) runner, args);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>综上， 整个启动流程的图例：</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="springboot启动流程"></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派使用另一主机的硬盘</title>
    <link href="/%E6%8A%98%E8%85%BE/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%A1%AC%E7%9B%98.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%A1%AC%E7%9B%98.html</url>
    
    <content type="html"><![CDATA[<p><strong>实现效果：不实际接入真实硬盘， 而是使用局域网内（公网主机也行， 只是速度取决于带宽）另一主机上的硬盘（或者是目录）</strong></p><p>实现方案： 使用NFS来实现</p><p>准备： </p><ul><li>一个树莓派</li><li>一台Linux主机， 系统Ubuntu 20.04, ip是10.0.0.239</li></ul><p>操作步骤：</p><h4 id="服务端（Linux主机）"><a href="#服务端（Linux主机）" class="headerlink" title="服务端（Linux主机）"></a>服务端（Linux主机）</h4><ol><li><p>IP为10.0.0.239的主机安装nfs server</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sudo apt install nfs-kernel-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li><li><p>创建nfs共享目录（如果已经存在， 可以不创建）， 也就是要挂载到树莓上的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /mnt/media/download<br></code></pre></td></tr></table></figure></li><li><p>配置nfs服务， 编辑配置文件：vim &#x2F;etc&#x2F;exports, 添加一行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/mnt/m</span>edia/download *(rw,sync,no_root_squash,no_subtree_check)<br></code></pre></td></tr></table></figure><p>各个字段说明如下：</p><ul><li>&#x2F;mnt&#x2F;media&#x2F;download: 要共享的目录</li><li>*<em>：指定可以访问共享目录的用户 ip, * 代表所有用户。192.168.3.</em>　指定网段。192.168.3.29 指定 ip。</li><li>rw：可读可写。如果想要只读的话，可以指定 ro。</li><li>sync：文件同步写入到内存与硬盘中。</li><li>async：文件会先暂存于内存中，而非直接写入硬盘。</li><li>no_root_squash：登入 nfs 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！但如果你需要在客户端对 nfs 目录进行写入操作。你就得配置 no_root_squash。方便与安全不可兼得。</li><li>root_squash：在登入 nfs 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nobody 那个系统账号的身份。</li><li>subtree_check：强制 nfs 检查父目录的权限（默认）</li><li>no_subtree_check：不检查父目录权限</li></ul></li><li><p>配置完成后， 执行如下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo exportfs -a<br>sudo service nfs-kernel-<span class="hljs-keyword">server</span> <span class="hljs-keyword">restart</span><br></code></pre></td></tr></table></figure></li><li><p>此时服务端配置完成</p></li></ol><h4 id="客户端（树莓派）"><a href="#客户端（树莓派）" class="headerlink" title="客户端（树莓派）"></a>客户端（树莓派）</h4><ol><li><p>安装nfs客户端</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">apt</span> install  nfs-<span class="hljs-meta">common</span><br></code></pre></td></tr></table></figure></li><li><p>将树莓派的目录挂载到之前在另外一台主机上共享出来的文件夹， 例如将树莓派的&#x2F;mnt&#x2F;download目录挂载到刚刚在另外一台Linux主机上创建的&#x2F;mnt&#x2F;media&#x2F;download目录， 命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mount <span class="hljs-number">10.0</span>.<span class="hljs-number">0.239</span>:<span class="hljs-regexp">/mnt/m</span>edia<span class="hljs-regexp">/download /m</span>nt<span class="hljs-regexp">/download/</span><br></code></pre></td></tr></table></figure></li><li><p>在10.0.0.239的&#x2F;mnt&#x2F;media&#x2F;download下创建一个文件， 此时可以看到树莓派的&#x2F;mnt&#x2F;download&#x2F;目录下也存在刚刚新建的文件</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红米AC2100 openWrt设置无线中继</title>
    <link href="/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E7%BA%A2%E7%B1%B3AC2100%20openwrt%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E5%85%B6%E4%BB%96/%E7%BA%A2%E7%B1%B3AC2100%20openwrt%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7.html</url>
    
    <content type="html"><![CDATA[<p>红米AC2100刷openWrt的教程：<a href="http://openwrt.ink:88/archives/s-breed">http://openwrt.ink:88/archives/s-breed</a></p><p>刷完之后， 设置无线中继的步骤记录一下。这里使用2.4G的频率来作为客户端接收上一级信号， 然后使用5G频率作为服务端发射无线信号。图片是已经设置好之后截的， 所以有些地方可能有些不一样。</p><ol><li><p>选择 网络 - 无线， 选择2.4G旁边的扫描按钮，加入网络， 选择需要中继的上一级网络， 然后填写密码， 其他默认即可。然后点击保存。</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210802211832720.png" alt="image-20210802211832720"></p></li></ol><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210802211929070.png" alt="image-20210802211929070"></p><ol start="2"><li><p>进入网络-接口页面， 点击 LAN条目的编辑， 注意此时已经有一个刚刚加入的wwan网络。<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210802212134006.png" alt="image-20210802212134006"></p></li><li><p>除了刚才新添加的wwan网络， 其余的全部勾选上<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210802212232613.png" alt="image-20210802212232613"></p></li><li><p>以上已经完成。 若不想开启2.4G的发射信号， 去无线页面禁用或删除2.4G的即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于docker-compose+prometheus+grafana搭建Linux监控</title>
    <link href="/%E6%8A%98%E8%85%BE/%E7%9B%91%E6%8E%A7/%E5%9F%BA%E4%BA%8Edocker-compose+prometheus+grafana%E6%90%AD%E5%BB%BALinux%E7%9B%91%E6%8E%A7.html"/>
    <url>/%E6%8A%98%E8%85%BE/%E7%9B%91%E6%8E%A7/%E5%9F%BA%E4%BA%8Edocker-compose+prometheus+grafana%E6%90%AD%E5%BB%BALinux%E7%9B%91%E6%8E%A7.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于docker-compose、prometheus、grafana来搭建Linux服务器的监控。 </p></blockquote><p>用到的几个expoter说明：</p><ul><li>node-exporter: 监控整个主机所有资源</li><li>cadvisor： 监控容器资源</li></ul><h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><p>在主机上创建一些目录， 用来持久化监控数据和配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /opt/docker/monitor/config<br>mkdir -p /opt/docker/monitor/data<br>chmod 777 /opt/docker/monitor/data<br></code></pre></td></tr></table></figure><h1 id="创建docker-compose-yml"><a href="#创建docker-compose-yml" class="headerlink" title="创建docker-compose.yml"></a>创建docker-compose.yml</h1><p>切换到&#x2F;opt&#x2F;docker&#x2F;monitor目录， 新建docker-compose.yml， 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">monitor:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">services:</span><br>   <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">monitor-grafana</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">grafana</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/monitor/data:/var/lib/grafana</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;11000:3000&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitor</span><br>      <br>  <span class="hljs-attr">prometheus:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">monitor-prometheus</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/monitor/config/prometheus.yml:/etc/prometheus/prometheus.yml</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;11001:9090&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitor</span><br>      <br>  <span class="hljs-attr">node-exporter:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/prometheus/node-exporter</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">monitor-node-exporter</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">node-exporter</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;11002:9100&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitor</span><br>  <br>  <span class="hljs-attr">cadvisor:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">google/cadvisor</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">monitor-cadvisor</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cadvisor</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/:/rootfs:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run:/var/run:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/sys:/sys:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/docker/:/var/lib/docker:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/disk/:/dev/disk:ro</span><br>    <span class="hljs-attr">devices:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/kmsg:/dev/kmsg</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;11003:8080&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitor</span><br></code></pre></td></tr></table></figure><h1 id="创建prometheus-yml"><a href="#创建prometheus-yml" class="headerlink" title="创建prometheus.yml"></a>创建prometheus.yml</h1><p>切换到&#x2F;opt&#x2F;docker&#x2F;monitor&#x2F;config目录， 新建prometheus.yml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;prometheus&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.0.239:11001&#x27;</span>]<br>  <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;node-exporter&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.0.239:11002&#x27;</span>]<br>      <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;cadvisor&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;10.0.0.239:11004&#x27;</span>]<br><br></code></pre></td></tr></table></figure><h1 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h1><ol><li><p>启动容器 <code>docker-compose up -d</code></p></li><li><p>待容器成功启动之后，进入dashboard页面, 页面地址：<code>http://10.0.0.239:11000</code>， 第一次进入时的默认用户名和密码是：admin&#x2F;admin， 然后需要设置新密码</p></li><li><p>配置datasource, 选择prometheus, 其中2处的URL填写： <code>http://10.0.0.239:11001</code><br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210729230433702.png" alt="image-20210729230433702"></p></li><li><p>从模板网站找到自己喜欢的模板， 比如模板ID为1860， 直接输入ID， 然后点击2处的load导入即可<br><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/image-20210729230802673.png" alt="image-20210729230802673"></p><p>说明一下几个exporter用到的模板ID</p><ul><li>node-exporter:  1860</li><li>process-exporter： 249</li><li>cadvisor： 11277</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
      <category>监控</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
      <tag>监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis相关</title>
    <link href="/%E7%BC%96%E7%A8%8B/java/mybatis%E7%9B%B8%E5%85%B3.html"/>
    <url>/%E7%BC%96%E7%A8%8B/java/mybatis%E7%9B%B8%E5%85%B3.html</url>
    
    <content type="html"><![CDATA[<p>在springboot中打印sql语句， 在配置文件中添加：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse索引原理介绍</title>
    <link href="/%E7%BC%96%E7%A8%8B/clickhouse/clickhouse%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html"/>
    <url>/%E7%BC%96%E7%A8%8B/clickhouse/clickhouse%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html</url>
    
    <content type="html"><![CDATA[<p>clickhouse本身支持很多表引擎，这里只介绍其中最常用的MergeTree引擎。</p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db.]table_name (<br>    name1 [type1] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr1] [TTL expr1],<br>    name2 [type2] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr2] [TTL expr2],<br>    ...<br>    INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1, # 创建普通索引（跳数索引）<br>    INDEX index_name2 expr2 TYPE type2(...) GRANULARITY value2<br>) ENGINE <span class="hljs-operator">=</span> MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expr<br>[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expr] # 创建分区键索引<br>[<span class="hljs-keyword">PRIMARY</span> KEY expr] # 创建主键索引<br>[SAMPLE <span class="hljs-keyword">BY</span> expr]<br>[TTL expr [<span class="hljs-keyword">DELETE</span><span class="hljs-operator">|</span><span class="hljs-keyword">TO</span> DISK <span class="hljs-string">&#x27;xxx&#x27;</span><span class="hljs-operator">|</span><span class="hljs-keyword">TO</span> VOLUME <span class="hljs-string">&#x27;xxx&#x27;</span>], ...]<br>[SETTINGS name<span class="hljs-operator">=</span><span class="hljs-keyword">value</span>, ...]<br></code></pre></td></tr></table></figure><p>介绍其中几个关键选项的含义：</p><ul><li>PARTITION BY ：分区键。 指定表数据以何种标准进行分区。分区键既可以是单个列字段，也可以通过元组的形式使用多个列字段，同时它也支持使用列表达式。</li><li>ORDER BY ：排序键，用于指定在一个数据片段内，数据以何种标准排序。默认情况下主键（PRIMARY KEY）与排序键相同。</li><li>PRIMARY KEY：  主键。声明后会依照主键字段生成一级索引。默认情况下，主键与排序键(ORDER BY)相同，所以通常直接使用ORDER BY代为指定主键。</li><li>SETTINGS:：<strong>index_granularity</strong>选项表示索引的粒度，默认值为8192。MergeTree索引在默认情况下，每间隔8192行数据才生成一条索引。</li></ul><h3 id="数据存储文件"><a href="#数据存储文件" class="headerlink" title="数据存储文件"></a>数据存储文件</h3><p>下面是clickhouse在存储数据时所产生的文件， 现分别对其用途做简要说明：</p><ul><li>checksums.txt   校验文件，用于记录其他的各类文件（如idx, mrk等）的size和其哈希值， 用于快速校验文件的完整性和正确性。</li><li>columnx.txt   列信息文件， 明文存储，记录该表的所有列信息。</li><li>count.txt       计数文件，明文存储，记录当前分区下数据的总行数。</li><li>primary.idx    主键索引文件</li><li>列名.bin      列数据文件，使用压缩格式存储。每一列都对应一个该文件，如列age为age.bin</li><li>列名.mrk     列标记文件，使用二进制存储。</li><li>partition.dat   保存当前分区下分区表达式最终生成的值</li><li>minmax_.idx     记录当前分区下分区字段对应原始数据的最小和最大值。</li><li>skp_idx_列名.idx    跳数索引数据文件 。</li><li>skp_idx_列名.mrk   跳数索引标记文件。</li></ul><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>首先说明两个重要概念</p><ul><li>granule 索引粒度， 由<strong>index_granularity</strong>指定，默认8192</li><li>block 列存储文件的压缩单元。每个列存文件的Block包含若干个Granule，具体多少个Granule是由参数min_compress_block_size控制，每次列的Block中写完一个Granule的数据时，它会检查当前Block Size有没有达到设定值，如果达到则会把当前Block进行压缩然后写磁盘。</li></ul><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>对应文件：primary.idx </p><p>与传统数据库不同， 主键索引是可以相同的。主键索引存储的是主键值和block， 且数据是按照主键进行排序的。 若查询条件中含有主键值， 则会先根据主键索引得到可能的granule范围，再根据mk标记文件中的偏移量确定数据。</p><h4 id="分区键索引"><a href="#分区键索引" class="headerlink" title="分区键索引"></a>分区键索引</h4><p>数据文件：minmax_分区键名.idx</p><p>记录当前分区下分区字段对应原始数据的最小和最大值。用于查询时迅速排除不需要的分区。</p><h4 id="跳数索引"><a href="#跳数索引" class="headerlink" title="跳数索引"></a>跳数索引</h4><p>数据文件： skp_idx_列名.idx </p><p>语法：<code>INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1</code></p><p>索引的可用类型包括minmax, set, bloom_filter。</p><p>和主键索引类似， 也是一种稀疏索引。因为数据是按主键排序的，主键索引统计的其实就是每个Granule粒度的主键序列最大和最小值，而Skipping索引提供的聚合函数种类更加丰富，是主键索引的一种补充能力。</p><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>MergeTree在写入一批数据时，数据总会以数据片段的形式写入磁盘，且数据片段不可修改。为了避免片段过多，ClickHouse会通过后台线程，定期合并这些数据片段，属于相同分区的数据片段会被合成一个新的片段。</p><p>MergeTree表的写入链路是一个极端的batch load过程，Data Part不支持单条的append insert。每次batch insert都会生成一个新的MergeTree Data Part。如果用户单次insert一条记录，那就会为那一条记录生成一个独立的Data Part，这必然是无法接受的。一般我们使用MergeTree表引擎的时候，需要在客户端做聚合进行batch写入或者在MergeTree表的基础上创建Distributed表来代理MergeTree表的写入和查询，Distributed表默认会缓存用户的写入数据，超过一定时间或者数据量再异步转发给MergeTree表。MergeTree存储引擎对数据实时可见要求非常高的场景是不太友好的。</p><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>例如有如下数据，主键为x和y。</p><table><thead><tr><th align="left">x</th><th align="left">y</th><th align="left">z</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">a</td><td align="left">2</td></tr><tr><td align="left">A</td><td align="left">c</td><td align="left">1</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">1</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">1</td></tr></tbody></table><p>假设index_granularity为2，先将数据分为多个block</p><table><thead><tr><th align="left">x</th><th align="left">y</th><th align="left">block-id</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">A</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">B</td><td align="left">c</td><td align="left">2</td></tr><tr><td align="left">B</td><td align="left">b</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">3</td></tr><tr><td align="left">C</td><td align="left">a</td><td align="left">4</td></tr></tbody></table><p>primary.idx内容展示的是主键和block的关系</p><table><thead><tr><th align="left">主键</th><th align="left">block</th></tr></thead><tbody><tr><td align="left">(A,a)</td><td align="left">1</td></tr><tr><td align="left">(A,c)</td><td align="left">2</td></tr><tr><td align="left">(B,b)</td><td align="left">3</td></tr><tr><td align="left">(C,a)</td><td align="left">4</td></tr></tbody></table><p>x.bin 和 y.bin存储对应的各个列的数据，x.mrk存储如下</p><table><thead><tr><th align="left">block-id</th><th align="left">offset</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1-3</td></tr><tr><td align="left">2</td><td align="left">4-9</td></tr><tr><td align="left">3</td><td align="left">10-30</td></tr></tbody></table><p>查询过程如下：</p><p>1、查询条件<br>2、通过查询条件的主键，可以根据primary.idx得出数据落在哪些block<br>3、根据block id 到各自的 mrk上寻找对应的offset<br>4、根据offset去bin中获取对应的数据，加载到内存中向量化操作，过滤</p><p>从以上可以看出：</p><ul><li>查询条件含有主键会减少很多不必要的磁盘IO</li><li>查询返回的值中列越少， 读取的列标记文件和列数据文件就越少，磁盘IO也会降低很多</li></ul><p>参考文章</p><ol><li><a href="https://segmentfault.com/a/1190000023089140">https://segmentfault.com/a/1190000023089140</a></li><li><a href="https://developer.aliyun.com/article/761931">https://developer.aliyun.com/article/761931</a></li><li><a href="https://clickhouse.tech/docs/zh/engines/table-engines/mergetree-family/mergetree/">https://clickhouse.tech/docs/zh/engines/table-engines/mergetree-family/mergetree/</a></li><li><a href="https://www.dazhuanlan.com/2019/11/21/5dd5815e95f7e/">https://www.dazhuanlan.com/2019/11/21/5dd5815e95f7e/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux压测和硬件测试命令</title>
    <link href="/%E7%BC%96%E7%A8%8B/linux/Linux%E5%B8%B8%E7%94%A8%E5%8E%8B%E6%B5%8B%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4.html"/>
    <url>/%E7%BC%96%E7%A8%8B/linux/Linux%E5%B8%B8%E7%94%A8%E5%8E%8B%E6%B5%8B%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4.html</url>
    
    <content type="html"><![CDATA[<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>使用fio命令来进行硬盘测试。</p><p>安装：<code>sudo apt install fio</code></p><p>基本参数如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">filename</span>=/dev/emcpowerb　支持文件系统或者裸设备，<span class="hljs-attribute">-filename</span>=/dev/sda2或-filename=/dev/sdb<br><span class="hljs-attribute">direct</span>=1                 测试过程绕过机器自带的buffer，使测试结果更真实<br><span class="hljs-attribute">rw</span>=randwread             测试随机读的I/O<br><span class="hljs-attribute">rw</span>=randwrite             测试随机写的I/O<br><span class="hljs-attribute">rw</span>=randrw                测试随机混合写和读的I/O<br><span class="hljs-attribute">rw</span>=read                  测试顺序读的I/O<br><span class="hljs-attribute">rw</span>=write                 测试顺序写的I/O<br><span class="hljs-attribute">rw</span>=rw                    测试顺序混合写和读的I/O<br><span class="hljs-attribute">bs</span>=4k                    单次io的块文件大小为4k<br><span class="hljs-attribute">bsrange</span>=512-2048         同上，提定数据块的大小范围<br><span class="hljs-attribute">size</span>=5g                  本次的测试文件大小为5g，以每次4k的io进行测试<br><span class="hljs-attribute">numjobs</span>=30               本次的测试线程为30<br><span class="hljs-attribute">runtime</span>=1000             测试时间为1000秒，如果不写则一直将5g文件分4k每次写完为止<br>time_based: 如果在runtime指定的时间还没到时文件就被读写完成，将继续重复直到runtime时间结束。<br><span class="hljs-attribute">ioengine</span>=psync           io引擎使用pync方式，如果要使用libaio引擎，需要yum install libaio-devel包<br><span class="hljs-attribute">rwmixwrite</span>=30            在混合读写的模式下，写占30%<br>group_reporting          关于显示结果的，汇总每个进程的信息<br>此外<br><span class="hljs-attribute">lockmem</span>=1g               只使用1g内存进行测试<br>zero_buffers             用0初始化系统buffer<br><span class="hljs-attribute">nrfiles</span>=8                每个进程生成文件的数量<br></code></pre></td></tr></table></figure><h4 id="随机读"><a href="#随机读" class="headerlink" title="随机读"></a>随机读</h4><p>向磁盘写一个2G文件，10线程，随机读1分钟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fio -filename=/tmp/test_randread -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest<br></code></pre></td></tr></table></figure><h4 id="随机写"><a href="#随机写" class="headerlink" title="随机写"></a>随机写</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">fio <span class="hljs-attribute">-filename</span>=/dev/sdb1 <span class="hljs-attribute">-direct</span>=1 -iodepth 1 -thread <span class="hljs-attribute">-rw</span>=randwrite <span class="hljs-attribute">-ioengine</span>=psync <span class="hljs-attribute">-bs</span>=16k <span class="hljs-attribute">-size</span>=2G <span class="hljs-attribute">-numjobs</span>=10 <span class="hljs-attribute">-runtime</span>=60 -group_reporting <span class="hljs-attribute">-name</span>=mytest<br></code></pre></td></tr></table></figure><h4 id="顺序读"><a href="#顺序读" class="headerlink" title="顺序读"></a>顺序读</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fio -filename=/dev/sdb1 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest<br></code></pre></td></tr></table></figure><h4 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fio -filename=/dev/sdb1 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=mytest<br></code></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>测试局域网内设备之间的网速， 使用iperf3 进行测试。</p><p>安装：</p><ul><li>ubuntu:  <code>apt install iperf3 </code></li><li>windows: 去官网下载文件直接解压， 然后使用cmd运行即可</li></ul><ol><li><p>在局域网内某台服务器上（假设该台机器IP为10.0.0.239）启动iperf3</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">iperf3</span> -s<br></code></pre></td></tr></table></figure></li><li><p>在局域网内的另一台机器上运行命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">iperf3</span> -c <span class="hljs-number">10.0.0.239</span><br></code></pre></td></tr></table></figure><p>即可得到网速输出结果</p></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>使用stress来进行。</p><p>安装： <code>apt install stress</code></p><p>主要参数：</p><ul><li><strong>-c, –cpu N</strong>       产生 N 个进程，每个进程都反复不停的计算随机数的平方根</li><li><strong>-i, –io N</strong>         产生 N 个进程，每个进程反复调用 sync() 将内存上的内容写到硬盘上</li><li><strong>-m, –vm N</strong>       产生 N 个进程，每个进程不断分配和释放内存</li><li><strong>–vm-bytes B</strong>   指定分配内存的大小</li><li><strong>–vm-stride B</strong>   不断的给部分内存赋值，让 COW(Copy On Write)发生</li><li><strong>–vm-hang N</strong>   指示每个消耗内存的进程在分配到内存后转入睡眠状态 N 秒，然后释放内存，一直重复执行这个过程</li><li><strong>–vm-keep</strong>     一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)</li><li><strong>-d, –hadd N</strong>      产生 N 个不断执行 write 和 unlink 函数的进程(创建文件，写入内容，删除文件)</li><li><strong>–hadd-bytes B</strong> 指定文件大小</li><li><strong>-t, –timeout N</strong>    在 N 秒后结束程序</li><li><strong>–backoff N</strong>      等待N微妙后开始运行 </li><li><strong>-q, –quiet</strong>       程序在运行的过程中不输出信息</li><li><strong>-n, –dry-run</strong>     输出程序会做什么而并不实际执行相关的操作</li><li><strong>–version</strong>        显示版本号</li><li><strong>-v, –verbose</strong>     显示详细的信息</li></ul><p>压满CPU命令，其中4是CPU核心数。通过调用 sqrt 函数计算由 rand 函数产生的随机数的平方根实现。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stress</span> -c <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>在压测过程中每隔1s实时显示主频：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">watch -n<span class="hljs-number">1</span> <span class="hljs-string">&quot;cat /proc/cpuinfo | grep \&quot;</span>^[<span class="hljs-keyword">c</span>]pu MHz\<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令与Shell语法总结</title>
    <link href="/%E7%BC%96%E7%A8%8B/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8EShell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
    <url>/%E7%BC%96%E7%A8%8B/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8EShell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    
    <content type="html"><![CDATA[<p><strong>当做个人字典使用， 会进行不定期更新！</strong></p><h1 id="几点注意事项"><a href="#几点注意事项" class="headerlink" title="几点注意事项"></a>几点注意事项</h1><ul><li><p>一次执行多条命令,可以有如下三种方法, 其区别如下:</p><ul><li>分号： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行</li><li>&amp;&amp;  ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的</li><li>||   ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的</li></ul></li><li><p>设置shell脚本遇到错误时自动退出, 不执行后续命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash -e 或者 <span class="hljs-built_in">set</span> -e</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/version<br></code></pre></td></tr></table></figure><h1 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h1><ul><li>&#x2F;dev&#x2F;null  重定向到此文件的数据都会被系统丢掉</li><li>&#x2F;dev&#x2F;tty 自动重定向到一个终端</li></ul><h1 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h1><blockquote><p>注意： 函数的定义要放在使用之前</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">函数定义</span><br>function funname() &#123;<br>    echo &quot;第n个参数为$&#123;n&#125;&quot;;<br>    action;<br>    retun;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">函数使用</span><br>funname param1 param2<br></code></pre></td></tr></table></figure><h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt; 覆写原先的内容<br><span class="hljs-meta prompt_">&gt;&gt;</span> 在原先的内容后追加<br><span class="hljs-variable">$?</span> 前一个命令或者函数的返回码, <span class="hljs-number">0</span>表示执行成功<br><span class="hljs-variable">$1</span> 表示第一个参数,<span class="hljs-variable">$2</span> 表示第二个<br><span class="hljs-variable">$#</span> 命令行参数的个数<br><span class="hljs-variable">$0</span> 当前程序的名称<br><span class="hljs-variable">$*</span> 以<span class="hljs-string">&quot;参数1 参数2 ...&quot;</span>的形式保存所有参数<br><span class="hljs-variable">$ </span>本程序进程<span class="hljs-variable constant_">PID</span><br><span class="hljs-variable">$!</span> 上一个命令的<span class="hljs-variable constant_">PID</span><br>脚本内取得输入命令时的参数:  <span class="hljs-variable">$n</span> n代表第几个参数<br><br></code></pre></td></tr></table></figure><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><blockquote><p>一般用于在if条件中，用[]包裹，注意前后空格。 </p><p>同时注意为了防止空情况下导致的语法错误， 变量都加上双引号</p></blockquote><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><ul><li>-ne 不等于则为真</li><li>-eq 等于则为真(用来判断数字）</li><li>-gt 大于则为真</li><li>-ge 大于等于为真</li><li>-lt 小于为真 </li><li>-le 小于等于为真</li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><ul><li>var1 &#x3D; var2 判断两个字符串是否相等</li><li>var1 !&#x3D; var2 判断两个字符串是否不相等   </li><li>-n “$var” 当字符串的长度大于零时为真(要用双引号包括—）</li><li>-z “$var” 当字符串的长度等于零时为真(要用双引号包括—）</li></ul><h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><ul><li>-d  file   检查file是否存在并且是一个目录</li><li>-f   file   检查file是否存在并且是一个文件</li><li>-e  file   检查file是否存在</li></ul><h2 id="逻辑操作运算"><a href="#逻辑操作运算" class="headerlink" title="逻辑操作运算"></a>逻辑操作运算</h2><ul><li>[ condition1 ]  &amp;&amp; [ condition2 ]  与</li><li>[ condition1 ]   || [ condition2 ]   或</li></ul><h1 id="控制语句语法"><a href="#控制语句语法" class="headerlink" title="控制语句语法"></a>控制语句语法</h1><blockquote><p>控制条件condition用[]包起来,或者使用test语句.注意空格</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">if</span>语句:</span><br>if [ condition ];then<br>command<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">if-else:</span><br>if [ condition ];then<br>command<br>elif [ condition2 ];then<br>command<br>else<br>command<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span>语句:</span><br>while [ condition ];do<br>command<br>done<br></code></pre></td></tr></table></figure><h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><p><strong>推荐使用 $[] 这种格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.使用 $[]，推荐使用(注意在引用变量的时候需要加$)</span><br>n1=4<br>n2=3<br>n3=$[$n1 * $n2] #输出12<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.<span class="hljs-built_in">let</span>用法,提供常用运算符,</span><br>注意: 变量前不需要加$运算符且let之后的表达式不要有空格<br>no1=4;<br>no2=5;<br>let result=no1+no2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.<span class="hljs-built_in">expr</span>用法，只识别部分比较简单的运算符</span><br>result=`expr 3 + 4`<br>result=`$no1 + 4`<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.注意,已上只能用于整数计算,下面这个也可用于浮点计算(使用bc命令)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出2.24</span><br>echo &quot;4 * 0.56&quot; |bc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出81.0</span><br>no=54<br>result=`echo &quot;Sno * 1.5&quot; |bc`<br>echo $result<br></code></pre></td></tr></table></figure><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><blockquote><p>以每一行为单位依次读取文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read line; do<br>echo $line<br>done &lt; /home/db2inst1/temp1.txt<br></code></pre></td></tr></table></figure><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义数组(数组下标从0开始)</span><br>my_array=(A B &quot;C&quot; D)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义一个空数组</span><br>my_array=()<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取数组</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;my_array[index]&#125;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给数组某一项赋值(注意此处不需要使用$)</span><br>my_array[0]=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取数组的长度</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#my_array[@]&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">遍历数组(每一项为具体值)</span><br>for item in $&#123;arr[@]&#125;<br>do<br>echo $item<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">遍历数组(每一项为数组下标)</span><br>for  i $&#123;!arr[@]&#125;<br>do<br>echo $i<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将某条命令执行的结果全赋值给数组</span><br>my_arr=(`awk &#x27;&#123;print $2&#125;&#x27; file.txt`)<br><br></code></pre></td></tr></table></figure><h1 id="for循环写法"><a href="#for循环写法" class="headerlink" title="for循环写法"></a>for循环写法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">循环10次</span><br>for i in $(seq 1 10)<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式可用于sed, awk,grep等命令.</p><p>注意, sed只能使用基本正则表达式,不能使用扩展的正则表达式,sed在使用时需要使用&#x2F;&#x2F;来包裹</p><h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 基础用法, 匹配含有word的行</span><br>grep &#x27;word&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. ^word 匹配word在行首的行</span><br>grep &#x27;^word&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. word$ 匹配word在行尾的行</span><br>grep &#x27;word$&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. .  匹配除换行符之外的任意一个字符(空格也是一个字符),该处必须有字符存在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配行中含有at的字符,且at前面有一个字符,如下面第一行,第三行可以匹配,第二行不能匹配,因为at在行首,前面无任何字符</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">This is at dog</span>  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">at a dog</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">th hs <span class="hljs-built_in">cat</span> fd</span><br>sed -n &#x27;/.at/p&#x27; file_name <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. * 匹配0个或任意多个前一个正则表达式字符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下全部匹配</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">i ha kg</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">kkkkg</span><br>grep &#x27;k*g&#x27; file_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">6. [] 搜索集合字符, []括号内的^表示除[]内的字符之外的所有字符</span><br>grep &#x27;[0-9]&#x27; file_name # 匹配出现数字的行<br>grep &#x27;[abc]&#x27; file_name # 匹配出现a或者b或者c的行<br>grep &#x27;[a-z]&#x27; file_name # 匹配出现小写字母的行<br>grep &#x27;[A-Z]&#x27; file_name # 匹配出现大写字母的行<br>grep &#x27;[a-zA-Z0-9]&#x27; file_name # 匹配出现字母或数字的行<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7. x\&#123;\&#125; 匹配字符连续出现的次数,注意若是单词需要分别写</span><br>grep &#x27;m\&#123;2\&#125;&#x27; file_name #匹配字母m连续出现2次的行, 如 hsjmmjs<br>grep &#x27;m\&#123;2,4\&#125;&#x27; file_name #匹配字母m出现次数在2到4次的文本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其他示例</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配一个IP地址</span><br>grep &#x27;[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配形如 <span class="hljs-string">&quot;13445676789&quot;</span> 的字符串,开始和结束是双引号,中间是个11位数字</span><br>grep &#x27;&quot;[0-9]\&#123;11\&#125;&quot;&#x27; file_name<br></code></pre></td></tr></table></figure><h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>grep使用时要加-E参数(好像不加也行?)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. ? 与星号类似,但前面的字符只能出现0次或1次</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">bet   匹配</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">bt    匹配</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">beet  不匹配</span><br>grep -E &#x27;be?t&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. + 与星号类似,但前面的字符至少出现1次(注意点号是指当前位置必须有一个字符)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bt  不匹配</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bet 匹配</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">beeet 匹配</span><br>grep -E &#x27;be+t&#x27; file_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.管道符 |, 逻辑或的意思</span><br></code></pre></td></tr></table></figure><h1 id="getops"><a href="#getops" class="headerlink" title="getops"></a>getops</h1><p>解析命令行参数</p><p>以下表示获取命令行参数 -d -t的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">while getopts &#x27;d:t:&#x27; OPT; do<br>  case $OPT in<br>    d)<br>      echo &quot;d $OPTARG&quot;<br>      exit 0;;<br>    t)<br>      echo &quot;t $OPTARG&quot;;;<br>    ?)<br>      echo &quot;no match&quot;<br>  esac<br>done<br></code></pre></td></tr></table></figure><p>其中getopt和getopt的区别以及getopt的详细用法示例见：<a href="https://blog.sigoden.com/how-to-use-getopt-to-build-cli/">https://blog.sigoden.com/how-to-use-getopt-to-build-cli/</a></p><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>工作流程: 读入有\n换行符分割的一条记录,然后将该记录按指定的域分隔符划分域(默认的域分隔符是空格符)</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>awk  参数  ‘BEGIN{ commands } pattern  { commands} END{commands}’</p></blockquote><p>参数: -F  指定字段定界符,默认是空格,可以是正则表达式， 注意分隔符直接跟在后面， 不需要任何符号</p><p>pattern: 模式,可以是正则表达式,用来匹配每一行,使用&#x2F;&#x2F;包裹, 如 &#x2F;^tcp&#x2F;表示匹配每一行开头以tcp开始</p><p>BEGIN内指定参数: </p><ul><li>FS 同-F; FS&#x3D;”” 表示以空行切分记录</li></ul><p>特殊参数:</p><ul><li>$0 所有域, $1 第一个域, $2 第二个域,以此类推</li><li>$NF 表示一行中的最后一个字段</li></ul><p>流程控制语法:</p><p><code>if(condition)&#123;&#125; else if(condition)&#123;&#125; else&#123;&#125;</code></p><p>循环语法:</p><p><code>for (i=0; i&lt;3;i++)&#123;&#125;</code></p><h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>有三种方法，下面分别是指定分隔符为逗号时的写法：</p><ol><li>使用 -F 指定，注意其后不需要任何符号， 语法：<code>awk -F, file</code></li><li>使用FS指定，加上-v参数， 语法： <code>awk -v FS=&quot;,&quot; file</code></li><li>在BEGIN内部指定， 语法： <code>awk &#39;BEGIN &#123;FS=&quot;,&quot;&#125;&#39; file</code></li></ol><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><p>length(string)  获取字符串长度(字符数)</p></li><li><p>拼接字符串时不需要使用任何修饰符,直接即可</p></li><li><p>printf() 格式化输出,默认不输出换行符.<br>%s 字符; %d 整数,小数取整直接去除尾数; %.2f 小数,2表示小数点保留两位,最后一位四舍五入<br>printf(“%.2f\n”, 1.3374)  输出1.34</p></li><li><p>split(string,array [,r])  字符串拆分,返回拆分后数组大小string:待拆分的字符串,array:拆分后结果保存的数组,r:分隔符,可选,默认FS值;拆分后的数组下标从1开始,<br><code>for(k in arr)&#123;print arr[k]&#125;</code></p></li><li><p>substr(s,i [,n]) 字符串截取<br>s:待截取字符串;i:索引位置,从1开始;n:要截取的长度.默认截取到字符尾。</p></li><li><p>字符串查找:index(s,t), match(s,r [,a])<br>返回第一次匹配成功的索引位置,从1开始,失败返回0<br>s: 待查找的字符串;t:目标子串<br>r: 查询的正则表达式, a 结果二维数组</p></li><li><p>字符串替换</p><ul><li>sub(r,s[,t]) 替换首次匹配到的子串,返回成功替换子串的数目,r 用于匹配的正则表达式,s 要替换的字符串值,t 目标字符串n,默认$0</li><li>gsub(r,s[,t]) 用法同sub,替换所有匹配到的子串</li><li>gensub(r,s,h[,t])  h: “g”表示全局替换,或是用数字指定子串出现的位置</li></ul></li></ul><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><ul><li>systime() 返回精确到秒的当前时间戳</li><li>mktime(date) 获取指定时间的时间戳,date格式: “YYYY MM DD HH MM SS”</li><li>strftime() 转化时间字符串</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>当字符串中含有单引号，转义写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此为打印单引号，比较字符串的单引号同理</span><br>awk &#x27;&#123;print &quot;&#x27;\&#x27;&#x27;&quot;&#125;&#x27; <br></code></pre></td></tr></table></figure></li><li><p>awk中比较在一个范围之内不能用连写方式，如 2&lt;x&lt;7是错误的,应写成 x&gt;2 &amp;&amp; x&lt;7</p></li><li><p>awk 使用外部变量，需要在Action之后定义变量，如下所示使用外部test变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">test=hhhhfudfhdhf<br>awk &#x27;&#123;print test&#125;&#x27; test=&quot;$test&quot; filename<br></code></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">假设一个目录下的文件按照时间进行命名， 如202204011628.tar.gz,现在要取出每个文件名的前8位（也就是年月日）， 操作如下</span><br>ls|awk &#x27;BEGIN &#123;FS=&quot;.&quot;&#125; &#123;a=substr($1,1,8);print a&#125;&#x27;<br></code></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>在命令之前加上<strong>LANG&#x3D;C</strong>之后可大幅提高检索速度, 如 LANG&#x3D;C grep -ia -B 1 Exception filename</p><p><strong>参数说明:</strong></p><ul><li>-i 忽略大小写</li><li>-a 显示文本(当使用通配符搜索文件内容时，有时只显示匹配的文件名而不显示匹配的内容，用此参数即可）</li><li>-e 指定多个匹配样式</li><li>-c 计算找到的符合行的次数</li><li>-n 输出匹配行的行号</li><li><strong>-v 反转查找</strong></li><li>-w 只显示全字符合的列</li><li>-A n 打印匹配行和匹配行之后的n行</li><li>-B n 打印匹配行和匹配行之前的n行</li><li>-C n 打印匹配行和匹配行之前,之后的n行,共2n+1</li><li>-h 在显示匹配行的那一列之前,不显示该列的文件名称</li><li>-o 只输出文件中匹配到的部分</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">过滤时间段内的数据, 例如[15:10:00,15:20:00)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">需要注意，正则表达式中的数字范围只能是一位整数</span><br>grep &quot;15:1[0-9]&quot; file<br></code></pre></td></tr></table></figure><h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><p>可以搜索gz压缩文件内的内容。用法同grep</p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><code> sed  options script file</code></p><p>默认不对原文件进行修改,处理的是原文件的拷贝</p><p><strong>options参数:</strong> </p><ul><li>-n 取消默认的输出,仅显示处理后的结果</li><li>-e 以选项中指定的script处理</li><li><strong>-i  直接修改原文件,慎用</strong></li></ul><p><strong>script 参数:</strong></p><ul><li>d 删除</li><li>p 打印</li><li>s 替换</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>若在sed命令中使用外部的变量，此时匹配规则必须使用双引号</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印第三行</span><br>sed -n &#x27;3p&#x27; file <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印第200行到300行</span><br>sed -n &#x27;200,300p&#x27; file <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件中的所有空白行</span><br>sed -n &#x27;/^$/d&#x27; file <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在每个有Statement行的下一行添加一个空行</span><br>sed &#x27;/Statemt/G&#x27; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件中含有<span class="hljs-built_in">test</span>字符串的行打印出来</span><br>sed -n &#x27;/test/p&#x27; test.txt <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件中my字符替换为Bob</span><br>sed &#x27;s/my/Bob/g&#x27; test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件中第三行替换为huang</span><br>sed -i &#x27;3s/.*/huang/&#x27; file<br></code></pre></td></tr></table></figure><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p>-n 省略结尾的换行符,直接在文本后面输入</p><h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><p>read value 读取用户输入</p><h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><p>显示磁盘信息</p><ul><li>-a 所有</li><li>-h 可读性较好显示</li></ul><h1 id="tail-amp-head"><a href="#tail-amp-head" class="headerlink" title="tail &amp; head"></a>tail &amp; head</h1><p>从前面和后面查看文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 显示文件最后n行</span><br>tail -n file <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">实时查看文件内容, 一般查看实时查看日志文件用此命令</span><br>tail -f file<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示文件的前n行</span><br>head -n file <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示文件的m到n行</span><br>head -n file | tail -m<br></code></pre></td></tr></table></figure><h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>压缩文件</p><ul><li>-q 不显示指令执行过程</li><li>-r 递归处理</li></ul><p><strong>示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将 /home/db2/ddl目录下所有文件和文件夹压缩至当前目录的test.zip文件</span><br>zip -q -r test.zip  /home/db2/ddl <br></code></pre></td></tr></table></figure><h1 id="typeset"><a href="#typeset" class="headerlink" title="typeset"></a>typeset</h1><p>设置变量</p><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>查看网络情况。</p><p>显示项Recv-Q, Send-Q表示网络接受队列,发送队列.一般情况下为0,可接受短暂的非0状态。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">统计各个Tcp状态的连接有多少个</span><br>netstat -n | awk &#x27;/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,&quot;\t&quot;,state[key]&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">统计与nginx建立连接的IP，并包含各个IP的连接数</span><br>netstat -ntp | grep nginx | grep -v &quot;127.0.0.1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c<br></code></pre></td></tr></table></figure><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><blockquote><p>显示系统进程信息(linux中线程是伪线程，用轻量级进程来实现的，所以查看线程信息也是用此命令）</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>-ef 显示系统运行的所有进程信息</li></ul><h2 id="返回信息"><a href="#返回信息" class="headerlink" title="返回信息"></a>返回信息</h2><ul><li>PID ：该进程的进程ID号</li><li>%CPU：该进程使用掉的 CPU 资源百分比</li><li>%MEM：该进程所占用的物理内存百分比</li><li>VSZ ：该进程使用掉的虚拟内存量 (单位KB)</li><li><strong>RSS ：该进程占用的固定的内存量</strong> (单位KB)</li><li>TTY ：该进程表示在哪个终端机上面运作，其取值可能有如下几种<ul><li>?   与终端机无关</li><li>tty1-tty6  本机上面的登入者程序</li><li>pts&#x2F;0  由网络连接进主机的程序</li></ul></li><li>STAT：该程序目前的状态，主要的状态有<ul><li>R ：该程序目前正在运作，或者是可被运作</li><li>S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒</li><li>T ：该程序目前正在侦测或者是停止了</li><li>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</li></ul></li><li>START：该进程被触发启动的时间</li><li>TIME ：该进程实际使用 CPU 运作的时间</li></ul><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p> 定时任务.</p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li>-l  查看现有cron表中的内容</li><li>-e 编辑</li></ul><p>cron文件的语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">f1 f2 f3 f4 f5 program<br></code></pre></td></tr></table></figure><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">每一分钟执行一次</span><br>* * * * * program<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每天7:50执行一次</span><br>50 7 * * * program<br></code></pre></td></tr></table></figure><h2 id="创建定时任务步骤"><a href="#创建定时任务步骤" class="headerlink" title="创建定时任务步骤"></a>创建定时任务步骤</h2><p>crontab -e </p><p>其他常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">当有service命令</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动</span><br>service crond start<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>service crond stop<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span><br>service crond restart<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当没有service命令</span><br>/etc/init.d/cron stop<br>/etc/init.d/cron start<br>/etc/init.d/cron restart<br></code></pre></td></tr></table></figure><h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>运行结果同时输出到终端和文件</p><p><code>ls |tee log.log</code></p><h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><blockquote><p>显示文件或目录大小</p></blockquote><ul><li>-c 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</li><li>-h 按友好模式显示</li><li>-s 只显示目录总大小</li><li>-l 重复计算硬件连接的文件</li><li>–max-depth 超过指定层数的目录后，予以忽略</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前目录总大小</span><br>du -sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前目录下一级子文件和子目录占用的磁盘容量</span><br>du -lh --max-depth=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">统计当前文件夹(目录)大小，并按文件大小排序</span><br>du -sh * | sort -n<br></code></pre></td></tr></table></figure><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>Linux服务器之间传输文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">传输aa.txt文件到206服务器的home目录下</span><br>scp aa.txt usroot@22.5.229.206:/home/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">206服务器下载aa.txt文件到本服务器当前路径：</span> <br>scp usroot@22.5.229.206:/home/aa.txt .<br></code></pre></td></tr></table></figure><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>排序. 排序时以行为单位</p><ul><li>-r 下降排序,默认升序</li><li>-n 按照数值大小排序</li><li>-k 指定排序所依据的列数,从1开始</li><li>-t 指定排序时的列分隔符</li><li>-u 输出行中去除重复行</li></ul><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><blockquote><p>忽略文件中的重复行，常与sort一起使用</p></blockquote><ul><li>-c 在每列旁边显示该行重复出现的次数</li><li>-d 仅显示重复出现的行</li><li>-u 仅显示唯一出现的行</li></ul><p>注意： <strong>uniq的去重是将当前行与上一行进行对比， 所以为了得到整体去重， 需要先进行排序，在执行去重</strong></p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>实时显示系统进程情况.</p><p><img src="https://hw-picture.oss-cn-beijing.aliyuncs.com/20210104190258.png" alt="20210104190258"></p><p>以下命令为进入该命令之后执行：</p><ul><li>M 根据内存大小进行排序</li><li>P 根据CPU使用百分比进行排序</li><li>T 根据时间&#x2F;累计时间排序</li></ul><p>输出参数说明:</p><ul><li>第一行相当于uptime命令输出<ul><li>第一列时间表示当前系统时间</li><li>第二列 up 6 days 58min, 表示系统已经运行时间</li><li>第三列 2 users, 表示表示当前有2个用户在登陆</li><li>第四列 load average三个值分别表示系统1分钟,5分钟,15分钟平均负载</li></ul></li><li>第二行 tasks信息表示系统运行的整体进程数量和状态信息<ul><li>zombie  僵尸进程数.</li></ul></li><li>第三行 %Cpu(s)表示的是总体CPU使用情况<ul><li><strong>us</strong> user 表示用户态的CPU时间比例. 当us很高时，证明CPU时间主要消耗在用户代码，需要优化用户代码</li><li><strong>sy</strong> system 表示内核态的CPU时间比例. 说明CPU时间都消耗在内核，要么是频繁的系统调用，要么是频繁的CPU切换（进程切换&#x2F;线程切换）</li><li><strong>wa</strong> iowait 表示处于IO等待的CPU时间比例. 很高时，说明有进程在进程频繁的IO操作，有可能是磁盘IO，也有可能是网络IO</li><li>ni nice 表示运行低优先级进程的CPU时间比例</li><li>id idle 表示空闲CPU时间比例</li><li>hi hard interrupt 表示处理硬中断的CPU时间比例</li><li>si soft interrupt 表示处理软中断的CPU时间比例</li><li>st steal 表示当前系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间比例</li></ul></li><li>第4行. 内存使用情况, 单位KiB<ul><li>totol 表示总内存</li><li>free 表示没使用过的内容</li><li>used是已经使用的内存</li><li>buff表示用于读写磁盘缓存的内存</li><li>cache表示用于读写文件缓存的内存</li><li>avail表示可用的应用内存</li></ul></li><li>第5行, swap使用情况, 单位KiB, Swap原理是把一块磁盘空间或者一个本地文件当成内存来使用. 这三个值都为0表示系统关闭了swap功能，虚拟机一般都关闭swap功能<ul><li>Swap total表示能用的swap总量</li><li>swap free表示剩余</li><li>used表示已经使用的</li></ul></li><li>之后为各个进程具体的信息.各字段说明如下<ul><li>PID 进程ID</li><li>USER 进程所有者的用户名，例如root</li><li>VIRT 虚拟内存, virtual memory usage。单位KB. 表示当前进程能够访问到的最大内存大小</li><li><strong>RES 物理内存（不包括共享内存), resident memory usage，单位KB。表示当前有多少物理内存被这个进程消费。如果申请 100m 的内存，实际使用 10m，那么RES &#x3D; 10m，VIRT&#x3D;100M。 一般情况下看此值大小即可</strong></li><li><strong>SHR 进程使用的共享内存. 单位KB</strong></li><li>CPU 进程使用的CPU占比</li><li>MEM 进程使用的内存占比</li><li>TIME 进程启动后到现在所用的全部CPU时间</li><li>COMMAND 进程的启动命令（默认只显示二进制，top -c能够显示命令行和启动参数）</li></ul></li></ul><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>ls -l 的输出内容格式如下: </p><p><code>-rw-r--r-- 1 root root 25934 Jun 26 10:35 X120</code></p><p>参数:</p><ul><li>-h 友好方式显示大小</li><li>-a 所有</li><li>-l 详细格式列表</li><li>-t 用文件和目录的更改时间排序</li><li>-r 反向排序</li></ul><p>添加-l参数时详细输出参数说明:</p><ul><li>第一列<ul><li>第一个， 文件类型<ul><li>d 目录</li><li>-文件，</li><li>c 字符型文件</li><li>b 块设备</li><li>l 链接文件</li></ul></li><li>接下来三个为一组，用来表示权限信息，其中 r 读， w 写， x 执行. 具体如下:<ul><li>2,3,4：文件所有者权限</li><li>5,6,7：同用户组的权限</li><li>8,9,10：非本用户组的权限</li></ul></li></ul></li><li>第二列：有多少文件名连接到此节点</li><li>第三列：所有者账号</li><li>第四列：文件所属的用户组</li><li>第五列：文件大小，默认B</li><li>第六列：最近修改日期</li></ul><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">仅显示目录名</span><br>ls -d */<br></code></pre></td></tr></table></figure><h1 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h1><blockquote><p><strong>查看文件属性，包括文件创建时间</strong></p></blockquote><ul><li>Access 访问时间，每读一次这个文件内容，就会更新。比如对这个文件使用more命令。ls、stat命令都不会修改文件的访问时间</li><li>Modify 修改时间，对文件内容进行写操作，就会更新。比如：vi后保存文件。ls -l列出的时间就是这个时间。</li><li>Change 状态改变时间，通过chmod命令更改一次文件属性，这个时间就会更新。</li></ul><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>打包与压缩命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将/home文件夹下所有内容打包压缩</span><br>tar -czvf home.tar.gz /home<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件</span><br>tar -xzvf home.tar.gz<br></code></pre></td></tr></table></figure><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>分割大文件为多个小文件</p><p>参数:</p><ul><li>-b value  按value大小分割文件,即分割后每个文件大小为value(单位为byte)</li><li>-l value  按行数分割文件,即分割后每个文件行数为value</li><li>-d 使用数字作为文件名后缀</li></ul><h1 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h1><p>不带任何参数, 默认发送get请求</p><p>参数:</p><ul><li><p>-d 发送post请求的数据体</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -d <span class="hljs-string">&#x27;login=emma＆password=123&#x27;</span> -X POST https:<span class="hljs-regexp">//g</span>oogle.com/login<br></code></pre></td></tr></table></figure></li><li><p>-H  设置请求头</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> https:<span class="hljs-regexp">//g</span>oogle.com/login<br></code></pre></td></tr></table></figure></li><li><p>-o 将服务器回应保存成文件, 等同于wget</p></li><li><p>-s 不输出错误和进度信息</p></li><li><p>-X 指定请求的方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -X POST https:<span class="hljs-regexp">//</span>www.example.com<br></code></pre></td></tr></table></figure></li></ul><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><blockquote><p>语法:  xargs   [-options]    [command]</p><p>作用是将标准输入转为命令行参数</p></blockquote><p>管道符|将左侧的标准输出转化为标准输入, 供右边命令使用, 但是这需要右边命令支持标准输入作为参数, 如grep是支持的, 下面命令是可以的.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef|<span class="hljs-keyword">grep</span> java<br></code></pre></td></tr></table></figure><p>但是很多命令不支持标准输入作为参数, 如echo, 下面这条命令没有任何输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sdsd&quot;</span>|<span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure><p>下面这条命令输出 sdsd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sdsd&quot;</span>|xargs <span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure><p>参数:</p><ul><li>-d 指定分隔符,默认将换行符和空格作为分隔符,如制表符为”\t”</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">保留当前目录下所有txt格式的文件， 删除所有其他类型的文件</span><br>ls|grep -v &quot;.txt&quot;|xargs rm<br></code></pre></td></tr></table></figure><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>查看某个端口占用情况.一般查看端口冲突时可使用该软件.</p><p><code> lsof -i:port</code></p><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>nohup输出的信息不输出到文件</p><p><code>nohup ./program &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><h1 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h1><blockquote><p>相比于top显示的信息更加详细</p></blockquote><p>注意几点：</p><ul><li>htop默认会把一个进程里的线程当做一个进程来显示出来，若要关闭线程，只显示进程，按F2，再选择 Display options，再选择 Hide userland threads</li></ul><h1 id="nload"><a href="#nload" class="headerlink" title="nload"></a>nload</h1><p> 查看各个网络设备的当前网络速率，也会展示流经设备的总流量 。</p><p>也可指定网卡， 如查看网卡eth0的流量 <code>nload etho</code></p><p>注意：页面上显示的速率单位MBit&#x2F;s， 是M比特每秒， 换算成正常的MB&#x2F;s（M字节每秒）需要除以8</p><h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化成 2020-01-12 23:23:34</span><br>date &quot;+%Y-%m-%d %H:%M:%S&quot;<br><br>date -d &quot;+1 day&quot; +%Y%m%d   #显示后一天的日期 <br>date -d &quot;-1 day&quot; +%Y%m%d   #显示前一天的日期 <br>date -d &quot;-1 month&quot; +%Y%m%d #显示上一月的日期 <br>date -d &quot;+1 month&quot; +%Y%m%d #显示下一月的日期 <br>date -d &quot;-1 year&quot; +%Y%m%d  #显示前一年的日期 <br>date -d &quot;+1 year&quot; +%Y%m%d  #显示下一年的日期<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
